{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cdd-python","text":"<p>OpenAPI to/fro routes, models, and tests. Convert between docstrings, <code>class</code>es, methods, argparse, pydantic, and SQLalchemy.</p> <p>Public SDK works with filenames, source code, and even in memory constructs (e.g., as imported into your REPL).</p>"},{"location":"#features","title":"Features","text":"Type Parse Emit Convert to all other Types docstrings (between Google, NumPy, ReST formats; and betwixt type annotations and docstring) \u2705 \u2705 \u2705 <code>class</code>es \u2705 \u2705 \u2705 functions \u2705 \u2705 \u2705 <code>argparse</code> CLI generating functions \u2705 \u2705 \u2705 JSON-schema \u2705 \u2705 \u2705 SQLalchemy <code>class</code>es \u2705 \u2705 \u2705 SQLalchemy <code>Table</code>s \u2705 \u2705 \u2705 SQLalchemy hybrid <code>class</code>es \u2705 \u2705 \u2705 pydantic <code>class</code>es \u2705 \u2705 \u2705"},{"location":"#openapi-composite","title":"OpenAPI composite","text":"<p>The OpenAPI parser and emitter utilises:</p> Type Parse Emit Bottle route functions WiP WiP FastAPI route functions \u2705 \u274c JSON-schema (e.g., from SQLalchemy) \u2705 \u2705 <p>Navigate to the API Reference to see the API documentation.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cdd_1","title":"<code>cdd</code>","text":""},{"location":"api/#cdd","title":"cdd","text":"<p>Root init</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddargparse_function","title":"<code>cdd.argparse_function</code>","text":""},{"location":"api/#cdd.argparse_function","title":"cdd.argparse_function","text":"<p>Argparse function parser and emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddargparse_functionemit","title":"<code>cdd.argparse_function.emit</code>","text":""},{"location":"api/#cdd.argparse_function.emit","title":"cdd.argparse_function.emit","text":"<p>Argparse emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.argparse_function.emit.argparse_function","title":"argparse_function","text":"<pre><code>argparse_function(intermediate_repr, emit_default_doc=False, function_name='set_cli_args', function_type='static', wrap_description=False, word_wrap=True, docstring_format='rest')\n</code></pre> <p>Convert to an argparse FunctionDef</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>function_name</code> <code>name</code> <p>name of function_def</p> required <code>function_type</code> <code>Literal['self', 'cls', 'static']</code> <p>Type of function, static is static or global method, others just become first arg</p> required <code>wrap_description</code> <code>bool</code> <p>Whether to word-wrap the description. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p>AST node for function definition which constructs argparse</p> Source code in <code>cdd/argparse_function/emit.py</code> <pre><code>def argparse_function(\n    intermediate_repr,\n    emit_default_doc=False,\n    function_name=\"set_cli_args\",\n    function_type=\"static\",\n    wrap_description=False,\n    word_wrap=True,\n    docstring_format=\"rest\",\n):\n    \"\"\"\n    Convert to an argparse FunctionDef\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param function_name: name of function_def\n    :type function_name: ```str```\n\n    :param function_type: Type of function, static is static or global method, others just become first arg\n    :type function_type: ```Literal['self', 'cls', 'static']```\n\n    :param wrap_description: Whether to word-wrap the description. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type wrap_description: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :return:  AST node for function definition which constructs argparse\n    :rtype: ```FunctionDef```\n    \"\"\"\n    function_name: Optional[str] = function_name or intermediate_repr[\"name\"]\n    function_type: Optional[str] = function_type or intermediate_repr[\"type\"]\n    internal_body: Internal = get_internal_body(\n        target_name=function_name,\n        target_type=function_type,\n        intermediate_repr=intermediate_repr,\n    )\n\n    return FunctionDef(\n        args=arguments(\n            args=[cdd.shared.ast_utils.set_arg(\"argument_parser\")],\n            # None if function_type in frozenset((None, \"static\"))\n            # else set_arg(function_type),\n            defaults=[],\n            kw_defaults=[],\n            kwarg=None,\n            kwonlyargs=[],\n            posonlyargs=[],\n            vararg=None,\n            arg=None,\n        ),\n        body=list(\n            chain.from_iterable(\n                (\n                    iter(\n                        (\n                            Expr(\n                                cdd.shared.ast_utils.set_value(\n                                    docstring(\n                                        {\n                                            \"doc\": \"Set CLI arguments\",\n                                            \"params\": OrderedDict(\n                                                (\n                                                    (\n                                                        \"argument_parser\",\n                                                        {\n                                                            \"doc\": \"argument parser\",\n                                                            \"typ\": \"ArgumentParser\",\n                                                        },\n                                                    ),\n                                                )\n                                            ),\n                                            \"returns\": OrderedDict(\n                                                (\n                                                    (\n                                                        \"return_type\",\n                                                        (\n                                                            {\n                                                                \"doc\": (\n                                                                    \"argument_parser, {returns_doc}\".format(\n                                                                        returns_doc=intermediate_repr[\n                                                                            \"returns\"\n                                                                        ][\n                                                                            \"return_type\"\n                                                                        ][\n                                                                            \"doc\"\n                                                                        ]\n                                                                    )\n                                                                    if intermediate_repr[\n                                                                        \"returns\"\n                                                                    ][\n                                                                        \"return_type\"\n                                                                    ].get(\n                                                                        \"doc\"\n                                                                    )\n                                                                    else \"argument_parser\"\n                                                                ),\n                                                                \"typ\": \"Tuple[ArgumentParser, {typ}]\".format(\n                                                                    typ=intermediate_repr[\n                                                                        \"returns\"\n                                                                    ][\n                                                                        \"return_type\"\n                                                                    ][\n                                                                        \"typ\"\n                                                                    ]\n                                                                ),\n                                                            }\n                                                            if \"return_type\"\n                                                            in (\n                                                                (\n                                                                    intermediate_repr\n                                                                    or {}\n                                                                ).get(\"returns\")\n                                                                or iter(())\n                                                            )\n                                                            and intermediate_repr[\n                                                                \"returns\"\n                                                            ][\"return_type\"].get(\"typ\")\n                                                            not in none_types\n                                                            else {\n                                                                \"doc\": (\n                                                                    \"argument_parser\"\n                                                                ),\n                                                                \"typ\": \"ArgumentParser\",\n                                                            }\n                                                        ),\n                                                    ),\n                                                ),\n                                            ),\n                                        },\n                                        docstring_format=docstring_format,\n                                        word_wrap=word_wrap,\n                                        indent_level=1,\n                                    )\n                                ),\n                                lineno=None,\n                                col_offset=None,\n                            ),\n                            Assign(\n                                targets=[\n                                    Attribute(\n                                        Name(\n                                            \"argument_parser\",\n                                            Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        \"description\",\n                                        Store(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    )\n                                ],\n                                value=cdd.shared.ast_utils.set_value(\n                                    (fill if wrap_description else identity)(\n                                        intermediate_repr[\"doc\"]\n                                    )\n                                ),\n                                lineno=None,\n                                expr=None,\n                                **cdd.shared.ast_utils.maybe_type_comment\n                            ),\n                        )\n                    ),\n                    filter(\n                        None,\n                        (\n                            *(\n                                (\n                                    map(\n                                        partial(\n                                            cdd.shared.ast_utils.param2argparse_param,\n                                            word_wrap=word_wrap,\n                                            emit_default_doc=emit_default_doc,\n                                        ),\n                                        intermediate_repr[\"params\"].items(),\n                                    )\n                                )\n                                if \"params\" in intermediate_repr\n                                else ()\n                            ),\n                            *(\n                                internal_body[\n                                    (\n                                        2\n                                        if len(internal_body) &gt; 1\n                                        and isinstance(internal_body[1], Assign)\n                                        and internal_body[1].targets[0].id\n                                        == \"argument_parser\"\n                                        else 1\n                                    ) :\n                                ]\n                                if internal_body\n                                and isinstance(internal_body[0], Expr)\n                                and isinstance(\n                                    cdd.shared.ast_utils.get_value(\n                                        internal_body[0].value\n                                    ),\n                                    str,\n                                )\n                                else internal_body\n                            ),\n                            (\n                                None\n                                if internal_body\n                                and isinstance(internal_body[-1], Return)\n                                else (\n                                    Return(\n                                        value=Tuple(\n                                            ctx=Load(),\n                                            elts=[\n                                                Name(\n                                                    \"argument_parser\",\n                                                    Load(),\n                                                    lineno=None,\n                                                    col_offset=None,\n                                                ),\n                                                (\n                                                    cdd.shared.ast_utils.set_value(\n                                                        intermediate_repr[\"returns\"][\n                                                            \"return_type\"\n                                                        ][\"default\"]\n                                                    )\n                                                    if code_quoted(\n                                                        intermediate_repr[\"returns\"][\n                                                            \"return_type\"\n                                                        ][\"default\"]\n                                                    )\n                                                    else ast.parse(\n                                                        intermediate_repr[\"returns\"][\n                                                            \"return_type\"\n                                                        ][\"default\"]\n                                                    )\n                                                    .body[0]\n                                                    .value\n                                                ),\n                                            ],\n                                            expr=None,\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        expr=None,\n                                    )\n                                    if \"default\"\n                                    in (\n                                        intermediate_repr.get(\"returns\")\n                                        or {\"return_type\": iter(())}\n                                    )[\"return_type\"]\n                                    else Return(\n                                        value=Name(\n                                            \"argument_parser\",\n                                            Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        expr=None,\n                                    )\n                                )\n                            ),\n                        ),\n                    ),\n                )\n            )\n        ),\n        decorator_list=[],\n        type_params=[],\n        name=function_name,\n        returns=None,\n        lineno=None,\n        arguments_args=None,\n        identifier_name=None,\n        stmt=None,\n        **cdd.shared.ast_utils.maybe_type_comment\n    )\n</code></pre>"},{"location":"api/#cddargparse_functionparse","title":"<code>cdd.argparse_function.parse</code>","text":""},{"location":"api/#cdd.argparse_function.parse","title":"cdd.argparse_function.parse","text":"<p>Argparse function parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.argparse_function.parse.argparse_ast","title":"argparse_ast","text":"<pre><code>argparse_ast(function_def, function_type=None, function_name=None, parse_original_whitespace=False, word_wrap=False)\n</code></pre> <p>Converts an argparse AST to our IR</p> <p>Parameters:</p> Name Type Description Default <code>function_def</code> <code>FunctionDef</code> <p>AST of argparse function_def</p> required <code>function_type</code> <code>Literal['self', 'cls', 'static']</code> <p>Type of function, static is static or global method, others just become first arg</p> required <code>function_name</code> <code>name</code> <p>name of function_def</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/argparse_function/parse.py</code> <pre><code>def argparse_ast(\n    function_def,\n    function_type=None,\n    function_name=None,\n    parse_original_whitespace=False,\n    word_wrap=False,\n):\n    \"\"\"\n    Converts an argparse AST to our IR\n\n    :param function_def: AST of argparse function_def\n    :type function_def: ```FunctionDef```\n\n    :param function_type: Type of function, static is static or global method, others just become first arg\n    :type function_type: ```Literal['self', 'cls', 'static']```\n\n    :param function_name: name of function_def\n    :type function_name: ```str```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    assert isinstance(\n        function_def, FunctionDef\n    ), \"Expected `FunctionDef` got `{node_name!r}`\".format(\n        node_name=type(function_def).__name__\n    )\n\n    doc_string: Optional[str] = get_docstring(\n        function_def, clean=parse_original_whitespace\n    )\n    intermediate_repr: IntermediateRepr = {\n        \"name\": function_name or function_def.name,\n        \"type\": function_type or get_function_type(function_def),\n        \"doc\": \"\",\n        \"params\": OrderedDict(),\n    }\n    ir: IntermediateRepr = parse_docstring(\n        doc_string,\n        word_wrap=word_wrap,\n        emit_default_doc=True,\n        parse_original_whitespace=parse_original_whitespace,\n    )\n\n    # Whether a default is required, if not found in doc, infer the proper default from type\n    require_default = False\n\n    # Parse all relevant nodes from function body\n    body: FunctionDef.body = (\n        function_def.body if doc_string is None else function_def.body[1:]\n    )\n    for node in body:\n        if is_argparse_add_argument(node):\n            name, _param = parse_out_param(\n                node,\n                emit_default_doc=False,  # require_default=require_default\n            )\n            (\n                intermediate_repr[\"params\"][name].update\n                if name in intermediate_repr[\"params\"]\n                else partial(setitem, intermediate_repr[\"params\"], name)\n            )(_param)\n            if not require_default and _param.get(\"default\") is not None:\n                require_default: bool = True\n        elif isinstance(node, Assign) and is_argparse_description(node):\n            intermediate_repr[\"doc\"] = get_value(node.value)\n        elif isinstance(node, Return) and isinstance(node.value, Tuple):\n            intermediate_repr[\"returns\"] = OrderedDict(\n                (\n                    _parse_return(\n                        node,\n                        intermediate_repr=ir,\n                        function_def=function_def,\n                        emit_default_doc=False,\n                    ),\n                )\n            )\n\n    inner_body: List[Call] = cast(\n        List[Call],\n        list(\n            filterfalse(\n                is_argparse_description,\n                filterfalse(is_argparse_add_argument, body),\n            )\n        ),\n    )\n    if inner_body:\n        intermediate_repr[\"_internal\"] = {\n            \"original_doc_str\": (\n                doc_string\n                if parse_original_whitespace\n                else get_docstring(function_def, clean=False)\n            ),\n            \"body\": inner_body,\n            \"from_name\": function_def.name,\n            \"from_type\": \"static\",\n        }\n\n    return intermediate_repr\n</code></pre>"},{"location":"api/#cddargparse_functionutils","title":"<code>cdd.argparse_function.utils</code>","text":""},{"location":"api/#cdd.argparse_function.utils","title":"cdd.argparse_function.utils","text":"<p>Argparse function parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddargparse_functionutilsemit_utils","title":"<code>cdd.argparse_function.utils.emit_utils</code>","text":""},{"location":"api/#cdd.argparse_function.utils.emit_utils","title":"cdd.argparse_function.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.argparse_function</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.argparse_function.utils.emit_utils.parse_out_param","title":"parse_out_param","text":"<pre><code>parse_out_param(expr, require_default=False, emit_default_doc=True)\n</code></pre> <p>Turns the class_def repr of '--dataset_name', type=str, help='name of dataset.', required=True, default='mnist'   into        Tuple[Literal['dataset_name'], {\"typ\": Literal[\"str\"], \"doc\": Literal[\"name of dataset.\"],                                        \"default\": Literal[\"mnist\"]}]</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Expr</code> <p>Expr</p> required <code>require_default</code> <code>bool</code> <p>Whether a default is required, if not found in doc, infer the proper default from type</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> Source code in <code>cdd/argparse_function/utils/emit_utils.py</code> <pre><code>def parse_out_param(expr, require_default=False, emit_default_doc=True):\n    \"\"\"\n    Turns the class_def repr of '--dataset_name', type=str, help='name of dataset.', required=True, default='mnist'\n      into\n           Tuple[Literal['dataset_name'], {\"typ\": Literal[\"str\"], \"doc\": Literal[\"name of dataset.\"],\n                                           \"default\": Literal[\"mnist\"]}]\n\n    :param expr: Expr\n    :type expr: ```Expr```\n\n    :param require_default: Whether a default is required, if not found in doc, infer the proper default from type\n    :type require_default: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Name, dict with keys: 'typ', 'doc', 'default'\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    required: bool = get_value(\n        get_value(\n            next(\n                (\n                    keyword\n                    for keyword in expr.value.keywords\n                    if keyword.arg == \"required\"\n                ),\n                set_value(False),\n            )\n        )\n    )\n\n    typ: str = next(\n        (\n            _handle_value(get_value(key_word))\n            for key_word in expr.value.keywords\n            if key_word.arg == \"type\"\n        ),\n        \"str\",\n    )\n    name: str = get_value(expr.value.args[0])[len(\"--\") :]\n    default: Optional[Any] = next(\n        (\n            get_value(key_word.value)\n            for key_word in expr.value.keywords\n            if key_word.arg == \"default\"\n        ),\n        None,\n    )\n    doc: Optional[str] = (\n        lambda help_: (\n            help_\n            if help_ is None\n            else (\n                help_\n                if default is None\n                or emit_default_doc is False\n                or (hasattr(default, \"__len__\") and len(default) == 0)\n                or \"defaults to\" in help_\n                or \"Defaults to\" in help_\n                else \"{help} Defaults to {default}\".format(\n                    help=help_ if help_.endswith(\".\") else \"{}.\".format(help_),\n                    default=default,\n                )\n            )\n        )\n    )(\n        next(\n            (\n                get_value(key_word.value)\n                for key_word in expr.value.keywords\n                if key_word.arg == \"help\" and key_word.value\n            ),\n            None,\n        )\n    )\n    if default is None:\n        doc, default = extract_default(doc, emit_default_doc=emit_default_doc)\n    if default is None:\n        if required:\n            # if name.endswith(\"kwargs\"):\n            #    default = NoneStr\n            # else:\n            default: Optional[\n                Dict[Optional[str], Union[int, float, complex, str, bool, None]]\n            ] = (simple_types[typ] if typ in simple_types else NoneStr)\n\n        elif require_default:  # or typ.startswith(\"Optional\"):\n            default: Optional[\n                Dict[Optional[str], Union[int, float, complex, str, bool, None]]\n            ] = NoneStr\n\n    action: Optional[Any] = next(\n        (\n            get_value(key_word.value)\n            for key_word in expr.value.keywords\n            if key_word.arg == \"action\"\n        ),\n        None,\n    )\n\n    typ: Optional[Any] = next(\n        (\n            _handle_keyword(keyword, typ)\n            for keyword in expr.value.keywords\n            if keyword.arg == \"choices\"\n        ),\n        typ,\n    )\n    if action == \"append\":\n        typ: str = \"List[{typ}]\".format(typ=typ)\n\n    if not required and \"Optional\" not in typ:\n        typ: str = \"Optional[{typ}]\".format(typ=typ)\n\n    return name, dict(\n        doc=doc, typ=typ, **({} if default is None else {\"default\": default})\n    )\n</code></pre>"},{"location":"api/#cddclass_","title":"<code>cdd.class_</code>","text":""},{"location":"api/#cdd.class_","title":"cdd.class_","text":"<p>class parser and emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddclass_emit","title":"<code>cdd.class_.emit</code>","text":""},{"location":"api/#cdd.class_.emit","title":"cdd.class_.emit","text":"<p><code>class</code> emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.emit.class_","title":"class_","text":"<pre><code>class_(intermediate_repr, emit_call=False, class_name=None, class_bases=('object',), decorator_list=None, word_wrap=True, docstring_format='rest', emit_original_whitespace=False, emit_default_doc=False)\n</code></pre> <p>Construct a class</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>class_name</code> <code>name</code> <p>name of class</p> required <code>class_bases</code> <code>Iterable[str]</code> <p>bases of class (the generated class will inherit these)</p> required <code>decorator_list</code> <code>Optional[List[str]]</code> <p>List of decorators</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit original whitespace or strip it out (in docstring)</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ClassDef</code> <p>Class AST</p> Source code in <code>cdd/class_/emit.py</code> <pre><code>def class_(\n    intermediate_repr,\n    emit_call=False,\n    class_name=None,\n    class_bases=(\"object\",),\n    decorator_list=None,\n    word_wrap=True,\n    docstring_format=\"rest\",\n    emit_original_whitespace=False,\n    emit_default_doc=False,\n):\n    \"\"\"\n    Construct a class\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param class_name: name of class\n    :type class_name: ```str```\n\n    :param class_bases: bases of class (the generated class will inherit these)\n    :type class_bases: ```Iterable[str]```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[List[str]]```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param emit_original_whitespace: Whether to emit original whitespace or strip it out (in docstring)\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Class AST\n    :rtype: ```ClassDef```\n    \"\"\"\n    assert isinstance(\n        intermediate_repr, dict\n    ), \"Expected `dict` got `{type_name}`\".format(\n        type_name=type(intermediate_repr).__name__\n    )\n    assert class_name or intermediate_repr[\"name\"], \"Class has no name\"\n\n    returns: OrderedDict = (\n        intermediate_repr[\"returns\"]\n        if \"return_type\" in ((intermediate_repr or {}).get(\"returns\") or iter(()))\n        else OrderedDict()\n    )\n    if returns:\n        intermediate_repr[\"params\"].update(returns)\n        del intermediate_repr[\"returns\"]\n\n    internal_body: ClassDef.body = intermediate_repr.get(\"_internal\", {}).get(\n        \"body\", []\n    )\n    # TODO: Add correct classmethod/staticmethod to decorate function using `annotate_ancestry` and first-field checks\n    # Such that the `self.` or `cls.` rewrite only applies to non-staticmethods\n    # assert internal_body, \"Expected `internal_body` to have contents\"\n    param_names: Optional[FrozenSet[str]] = (\n        frozenset(intermediate_repr[\"params\"].keys())\n        if \"params\" in intermediate_repr\n        else None\n    )\n    if param_names:\n        if internal_body:\n            internal_body: ClassDef.body = list(\n                map(\n                    ast.fix_missing_locations,\n                    map(RewriteName(param_names).visit, internal_body),\n                )\n            )\n        elif (returns or {\"return_type\": None}).get(\"return_type\") is not None:\n            internal_body = returns[\"return_type\"]\n\n    indent_level: int = 1\n\n    _emit_docstring = partial(\n        docstring,\n        docstring_format=docstring_format,\n        indent_level=indent_level,\n        emit_default_doc=emit_default_doc,\n        emit_separating_tab=True,\n        emit_types=False,\n        word_wrap=word_wrap,\n    )\n    return ClassDef(\n        bases=list(\n            map(\n                rpartial(partial(Name, lineno=None, col_offset=None), Load()),\n                class_bases,\n            )\n        ),\n        body=list(\n            filter(\n                None,\n                chain.from_iterable(\n                    (\n                        (\n                            (\n                                lambda ds: (\n                                    None\n                                    if ds is None\n                                    else Expr(\n                                        cdd.shared.ast_utils.set_value(ds),\n                                        lineno=None,\n                                        col_offset=None,\n                                    )\n                                )\n                            )(\n                                _emit_docstring(\n                                    {\n                                        k: intermediate_repr[k]\n                                        for k in intermediate_repr\n                                        if k != \"_internal\"\n                                    },\n                                    emit_original_whitespace=emit_original_whitespace,\n                                    purpose=\"class\",\n                                ).rstrip()\n                                or None\n                            ),\n                        ),\n                        map(\n                            cdd.shared.ast_utils.param2ast,\n                            (intermediate_repr.get(\"params\") or OrderedDict()).items(),\n                        ),\n                        iter(\n                            (\n                                (\n                                    (\n                                        internal_body[0]\n                                        if len(internal_body) == 1\n                                        and isinstance(internal_body[0], FunctionDef)\n                                        and internal_body[0].name == \"__call__\"\n                                        else make_call_meth(\n                                            internal_body,\n                                            (\n                                                returns[\"return_type\"][\"default\"]\n                                                if \"default\"\n                                                in (\n                                                    (\n                                                        returns\n                                                        or {\"return_type\": iter(())}\n                                                    ).get(\"return_type\")\n                                                    or iter(())\n                                                )\n                                                else None\n                                            ),\n                                            param_names,\n                                            docstring_format=docstring_format,\n                                            word_wrap=word_wrap,\n                                        )\n                                    ),\n                                )\n                                or iter(())\n                            )\n                            if emit_call and internal_body\n                            else iter(())\n                        ),\n                    ),\n                ),\n            )\n        )\n        or [\n            Expr(\n                Constant(Ellipsis) if PY_GTE_3_8 else Ellipsis,\n                lineno=None,\n                col_offset=None,\n            )\n        ],  # empty body will cause syntax error\n        decorator_list=(\n            list(\n                map(\n                    rpartial(partial(Name, lineno=None, col_offset=None), Load()),\n                    decorator_list,\n                )\n            )\n            if decorator_list\n            else []\n        ),\n        type_params=[],\n        keywords=[],\n        name=class_name or intermediate_repr[\"name\"],\n        expr=None,\n        identifier_name=None,\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cddclass_parse","title":"<code>cdd.class_.parse</code>","text":""},{"location":"api/#cdd.class_.parse","title":"cdd.class_.parse","text":"<p><code>class</code> parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.parse.class_","title":"class_","text":"<pre><code>class_(class_def, class_name=None, merge_inner_function=None, infer_type=False, parse_original_whitespace=False, word_wrap=True)\n</code></pre> <p>Converts an AST to our IR</p> <p>Parameters:</p> Name Type Description Default <code>class_def</code> <code>Union[Module, ClassDef]</code> <p>Class AST or Module AST with a ClassDef inside</p> required <code>class_name</code> <code>Optional[str]</code> <p>Name of <code>class</code>. If None, gives first found.</p> required <code>merge_inner_function</code> <code>Optional[str]</code> <p>Name of inner function to merge. If None, merge nothing.</p> required <code>infer_type</code> <code>bool</code> <p>Whether to try inferring the typ (from the default)</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/class_/parse.py</code> <pre><code>def class_(\n    class_def,\n    class_name=None,\n    merge_inner_function=None,\n    infer_type=False,\n    parse_original_whitespace=False,\n    word_wrap=True,\n):\n    \"\"\"\n    Converts an AST to our IR\n\n    :param class_def: Class AST or Module AST with a ClassDef inside\n    :type class_def: ```Union[Module, ClassDef]```\n\n    :param class_name: Name of `class`. If None, gives first found.\n    :type class_name: ```Optional[str]```\n\n    :param merge_inner_function: Name of inner function to merge. If None, merge nothing.\n    :type merge_inner_function: ```Optional[str]```\n\n    :param infer_type: Whether to try inferring the typ (from the default)\n    :type infer_type: ```bool```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n\n    assert not isinstance(class_def, FunctionDef), \"Expected not `FunctionDef`\"\n    is_supported_ast_node: bool = isinstance(class_def, (Module, ClassDef))\n    if not is_supported_ast_node and isinstance(class_def, type):\n        return _class_from_memory(\n            class_def=class_def,\n            class_name=class_name,\n            infer_type=infer_type,\n            merge_inner_function=merge_inner_function,\n            parse_original_whitespace=parse_original_whitespace,\n            word_wrap=word_wrap,\n        )\n\n    assert (\n        is_supported_ast_node\n    ), \"Expected 'Union[Module, ClassDef]' got `{node_name!r}`\".format(\n        node_name=type(class_def).__name__\n    )\n    class_def: ClassDef = cast(\n        ClassDef, cdd.shared.ast_utils.find_ast_type(class_def, class_name)\n    )\n    doc_str: Optional[str] = get_docstring(class_def, clean=parse_original_whitespace)\n    intermediate_repr: IntermediateRepr = (\n        {\n            \"name\": class_name,\n            \"type\": \"static\",\n            \"doc\": \"\",\n            \"params\": OrderedDict(),\n            \"returns\": None,\n        }\n        if doc_str is None\n        else cdd.docstring.parse.docstring(\n            doc_str,\n            emit_default_doc=False,\n            parse_original_whitespace=parse_original_whitespace,\n        )\n    )\n\n    if \"return_type\" in intermediate_repr[\"params\"]:\n        intermediate_repr[\"returns\"] = OrderedDict(\n            ((\"return_type\", intermediate_repr[\"params\"].pop(\"return_type\")),)\n        )\n\n    body: ClassDef.body = class_def.body if doc_str is None else class_def.body[1:]\n    for e in body:\n        if isinstance(e, AnnAssign):\n            typ: str = cdd.shared.source_transformer.to_code(e.annotation).rstrip(\"\\n\")\n            val = (\n                (\n                    lambda v: (\n                        {\"default\": cdd.shared.ast_utils.NoneStr}\n                        if v is None\n                        else {\n                            \"default\": (\n                                v\n                                if type(v).__name__ in simple_types\n                                else (\n                                    lambda value: {\n                                        \"{}\": {} if isinstance(v, Dict) else set(),\n                                        \"[]\": [],\n                                        \"()\": (),\n                                    }.get(\n                                        value,\n                                        cdd.shared.ast_utils.parse_to_scalar(value),\n                                    )\n                                )(cdd.shared.source_transformer.to_code(v).rstrip(\"\\n\"))\n                            )\n                        }\n                    )\n                )(cdd.shared.ast_utils.get_value(cdd.shared.ast_utils.get_value(e)))\n                if hasattr(e, \"value\") and e.value is not None\n                else {}\n            )\n\n            # if 'str' in typ and val: val[\"default\"] = val[\"default\"].strip(\"'\")  # Unquote?\n            typ_default = (\n                {\"typ\": typ} if val is None else dict(typ=typ, **val)\n            )  # type: Union[bool, dict[str, Any]]\n\n            target_id: str = e.target.id.lstrip(\"*\")\n\n            for key in \"params\", \"returns\":\n                if target_id in (intermediate_repr[key] or iter(())):\n                    intermediate_repr[key][target_id].update(typ_default)\n                    typ_default: bool = False\n                    break\n\n            if typ_default:\n                k: str = \"returns\" if target_id == \"return_type\" else \"params\"\n                if intermediate_repr.get(k) is None:\n                    intermediate_repr[k] = OrderedDict()\n                intermediate_repr[k][target_id] = typ_default\n        elif isinstance(e, Assign):\n            val = cdd.shared.ast_utils.get_value(e)\n\n            if val is not None:\n                val = cdd.shared.ast_utils.get_value(val)\n                deque(\n                    map(\n                        lambda target: setitem(\n                            *(\n                                (\n                                    lambda _target_id: (\n                                        (\n                                            intermediate_repr[\"params\"][_target_id],\n                                            \"default\",\n                                            val,\n                                        )\n                                        if isinstance(target, Name)\n                                        and _target_id in intermediate_repr[\"params\"]\n                                        else (\n                                            intermediate_repr[\"params\"],\n                                            (\n                                                _target_id\n                                                if isinstance(target, Name)\n                                                else cdd.shared.ast_utils.get_value(\n                                                    cdd.shared.ast_utils.get_value(\n                                                        target\n                                                    )\n                                                )\n                                            ),\n                                            {\"default\": val},\n                                        )\n                                    )\n                                )(\n                                    target.id.lstrip(\"*\")\n                                    if hasattr(target, \"id\")\n                                    else target.value.id\n                                )\n                            )\n                        ),\n                        e.targets,\n                    ),\n                    maxlen=0,\n                )\n\n    intermediate_repr.update(\n        {\n            \"name\": class_name or class_def.name,\n            \"params\": OrderedDict(\n                map(\n                    partial(\n                        cdd.shared.docstring_parsers._set_name_and_type,\n                        infer_type=infer_type,\n                        word_wrap=word_wrap,\n                    ),\n                    intermediate_repr[\"params\"].items(),\n                )\n            ),\n            \"_internal\": {\n                \"original_doc_str\": (\n                    doc_str\n                    if parse_original_whitespace\n                    else get_docstring(class_def, clean=False)\n                ),\n                \"body\": cast(\n                    List[AST],\n                    list(filterfalse(rpartial(isinstance, (AnnAssign, Assign)), body)),\n                ),\n                \"from_name\": class_def.name,\n                \"from_type\": \"cls\",\n            },\n        }\n    )\n\n    if merge_inner_function is not None:\n        assert isinstance(\n            class_def, ClassDef\n        ), \"Expected `ClassDef` got `{node_name!r}`\".format(\n            node_name=type(class_def).__name__\n        )\n\n        _merge_inner_function(\n            class_def,\n            infer_type=infer_type,\n            intermediate_repr=intermediate_repr,\n            merge_inner_function=merge_inner_function,\n        )\n    return intermediate_repr\n</code></pre>"},{"location":"api/#cddclass_utils","title":"<code>cdd.class_.utils</code>","text":""},{"location":"api/#cdd.class_.utils","title":"cdd.class_.utils","text":"<p>class parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddclass_utilsemit_utils","title":"<code>cdd.class_.utils.emit_utils</code>","text":""},{"location":"api/#cdd.class_.utils.emit_utils","title":"cdd.class_.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.class_</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.utils.emit_utils.RewriteName","title":"RewriteName","text":"<pre><code>RewriteName(node_ids)\n</code></pre> <p>               Bases: <code>NodeTransformer</code></p> <p>A :class:<code>NodeTransformer</code> subclass that walks the abstract syntax tree and allows modification of nodes. Here it modifies parameter names to be <code>self.param_name</code></p> <p>Parameters:</p> Name Type Description Default <p>Set parameter</p> <p>Parameters:</p> Name Type Description Default <code>node_ids</code> <code>id</code> <p>Container of AST <code>id</code>s to match for rename</p> required Source code in <code>cdd/class_/utils/emit_utils.py</code> <pre><code>def __init__(self, node_ids):\n    \"\"\"\n    Set parameter\n\n    :param node_ids: Container of AST `id`s to match for rename\n    :type node_ids: ```Optional[Iterator[str]]```\n    \"\"\"\n    self.node_ids = node_ids\n</code></pre>"},{"location":"api/#cdd.class_.utils.emit_utils.RewriteName.visit_Name","title":"visit_Name","text":"<pre><code>visit_Name(node)\n</code></pre> <p>Rename parameter name with a <code>self.</code> attribute prefix</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Name</code> <p>The AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[Name, Attribute]</code> <p><code>Name</code> iff <code>Name</code> is not a parameter else <code>Attribute</code></p> Source code in <code>cdd/class_/utils/emit_utils.py</code> <pre><code>def visit_Name(self, node):\n    \"\"\"\n    Rename parameter name with a `self.` attribute prefix\n\n    :param node: The AST node\n    :type node: ```Name```\n\n    :return: `Name` iff `Name` is not a parameter else `Attribute`\n    :rtype: ```Union[Name, Attribute]```\n    \"\"\"\n    return (\n        Attribute(\n            Name(\"self\", Load(), lineno=None, col_offset=None),\n            node.id,\n            Load(),\n            lineno=None,\n            col_offset=None,\n        )\n        if not self.node_ids or node.id in self.node_ids\n        else ast.NodeTransformer.generic_visit(self, node)\n    )\n</code></pre>"},{"location":"api/#cddclass_utilsparse_utils","title":"<code>cdd.class_.utils.parse_utils</code>","text":""},{"location":"api/#cdd.class_.utils.parse_utils","title":"cdd.class_.utils.parse_utils","text":"<p>Utility functions for <code>cdd.parse.class</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.utils.parse_utils.get_source","title":"get_source","text":"<pre><code>get_source(obj)\n</code></pre> <p>Call inspect.getsource and raise an error unless class definition could not be found</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>object to inspect</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[str]</code> <p>The source</p> Source code in <code>cdd/class_/utils/parse_utils.py</code> <pre><code>def get_source(obj):\n    \"\"\"\n    Call inspect.getsource and raise an error unless class definition could not be found\n\n    :param obj: object to inspect\n    :type obj: ```Any```\n\n    :return: The source\n    :rtype: ```Optional[str]```\n    \"\"\"\n    try:\n        return getsource(obj)\n    except OSError as e:\n        if e.args and e.args[0] in frozenset(\n            (\n                \"could not find class definition\",\n                \"source code not available\",\n                \"could not get source code\",\n            )\n        ):\n            return None\n        raise\n</code></pre>"},{"location":"api/#cddclass_utilsshared_utils","title":"<code>cdd.class_.utils.shared_utils</code>","text":""},{"location":"api/#cdd.class_.utils.shared_utils","title":"cdd.class_.utils.shared_utils","text":"<p>Shared utility functions for <code>cdd.class_</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.utils.shared_utils.ClassEmitProtocol","title":"ClassEmitProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for class emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.utils.shared_utils.ClassEmitProtocol.__call__","title":"__call__","text":"<pre><code>__call__(intermediate_repr: IntermediateRepr, emit_call: bool = False, class_name: Optional[str] = None, class_bases: Tuple[str] = ('object',), decorator_list: Optional[List[str]] = None, word_wrap: bool = True, docstring_format: Literal['rest', 'numpydoc', 'google'] = 'rest', emit_original_whitespace: bool = False, emit_default_doc: bool = False) -&gt; ClassDef\n</code></pre> <p>Construct a class</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_call</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>class_name</code> <code>name</code> <p>name of class</p> required <code>class_bases</code> <p>bases of class (the generated class will inherit these)</p> required <code>decorator_list</code> <p>List of decorators</p> required <code>word_wrap</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>docstring_format</code> <p>Format of docstring</p> required <code>emit_original_whitespace</code> <p>Whether to emit original whitespace or strip it out (in docstring)</p> required <code>emit_default_doc</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>Class AST</p> Source code in <code>cdd/class_/utils/shared_utils.py</code> <pre><code>def __call__(\n    self,\n    intermediate_repr: IntermediateRepr,\n    emit_call: bool = False,\n    class_name: Optional[str] = None,\n    class_bases: Tuple[str] = (\"object\",),\n    decorator_list: Optional[List[str]] = None,\n    word_wrap: bool = True,\n    docstring_format: Literal[\"rest\", \"numpydoc\", \"google\"] = \"rest\",\n    emit_original_whitespace: bool = False,\n    emit_default_doc: bool = False,\n) -&gt; ClassDef:\n    \"\"\"\n    Construct a class\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n\n    :param class_name: name of class\n\n    :param class_bases: bases of class (the generated class will inherit these)\n\n    :param decorator_list: List of decorators\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n\n    :param docstring_format: Format of docstring\n\n    :param emit_original_whitespace: Whether to emit original whitespace or strip it out (in docstring)\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n\n    :return: Class AST\n    \"\"\"\n</code></pre>"},{"location":"api/#cdd.class_.utils.shared_utils.ClassParserProtocol","title":"ClassParserProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for class parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.class_.utils.shared_utils.ClassParserProtocol.__call__","title":"__call__","text":"<pre><code>__call__(class_def: Union[Module, ClassDef], class_name: Optional[str] = None, merge_inner_function: Optional[str] = None, infer_type: bool = False, parse_original_whitespace: bool = False, word_wrap: bool = True) -&gt; IntermediateRepr\n</code></pre> <p>Converts an AST to our IR</p> <p>Parameters:</p> Name Type Description Default <code>class_def</code> <p>Class AST or Module AST with a ClassDef inside</p> required <code>class_name</code> <p>Name of <code>class</code>. If None, gives first found.</p> required <code>merge_inner_function</code> <p>Name of inner function to merge. If None, merge nothing.</p> required <code>infer_type</code> <p>Whether to try inferring the typ (from the default)</p> required <code>parse_original_whitespace</code> <p>Whether to parse original whitespace or strip it out</p> required <code>word_wrap</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/class_/utils/shared_utils.py</code> <pre><code>def __call__(\n    self,\n    class_def: Union[Module, ClassDef],\n    class_name: Optional[str] = None,\n    merge_inner_function: Optional[str] = None,\n    infer_type: bool = False,\n    parse_original_whitespace: bool = False,\n    word_wrap: bool = True,\n) -&gt; IntermediateRepr:\n    \"\"\"\n    Converts an AST to our IR\n\n    :param class_def: Class AST or Module AST with a ClassDef inside\n\n    :param class_name: Name of `class`. If None, gives first found.\n\n    :param merge_inner_function: Name of inner function to merge. If None, merge nothing.\n\n    :param infer_type: Whether to try inferring the typ (from the default)\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    \"\"\"\n</code></pre>"},{"location":"api/#cddcompound","title":"<code>cdd.compound</code>","text":""},{"location":"api/#cdd.compound","title":"cdd.compound","text":"<p><code>cdd.compound</code> contains modules that combine multiple others</p> <p>This is used for OpenAPI, CLI subcommands, and similar.</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddcompounddoctrans","title":"<code>cdd.compound.doctrans</code>","text":""},{"location":"api/#cdd.compound.doctrans","title":"cdd.compound.doctrans","text":"<p>Helper to traverse the AST of the input file, extract the docstring out, parse and format to intended style, and emit</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.doctrans.doctrans","title":"doctrans","text":"<pre><code>doctrans(filename, docstring_format, type_annotations, no_word_wrap)\n</code></pre> <p>Transform the docstrings found within provided filename to intended docstring_format</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Python file to convert docstrings within. Edited in place.</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>type_annotations</code> <code>bool</code> <p>True to have type annotations (3.6+), False to place in docstring</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required Source code in <code>cdd/compound/doctrans.py</code> <pre><code>def doctrans(filename, docstring_format, type_annotations, no_word_wrap):\n    \"\"\"\n    Transform the docstrings found within provided filename to intended docstring_format\n\n    :param filename: Python file to convert docstrings within. Edited in place.\n    :type filename: ```str```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param type_annotations: True to have type annotations (3.6+), False to place in docstring\n    :type type_annotations: ```bool```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n    \"\"\"\n    with open(filename, \"rt\") as f:\n        original_source: str = f.read()\n    node: Module = ast_parse(original_source, skip_docstring_remit=False)\n    original_module: Module = deepcopy(node)\n\n    node: Module = fix_missing_locations(\n        DocTrans(\n            docstring_format=docstring_format,\n            word_wrap=no_word_wrap is None,\n            type_annotations=type_annotations,\n            existing_type_annotations=has_type_annotations(node),\n            whole_ast=original_module,\n        ).visit(node)\n    )\n\n    if not cmp_ast(node, original_module):\n        cst_list: List[NamedTuple] = list(cst_parse(original_source))\n\n        # Carefully replace only docstrings, function return annotations, assignment and annotation assignments.\n        # Maintaining all other existing whitespace, comments, &amp;etc.\n        doctransify_cst(cst_list, node)\n\n        with open(filename, \"wt\") as f:\n            f.write(\"\".join(map(attrgetter(\"value\"), cst_list)))\n</code></pre>"},{"location":"api/#cddcompounddoctrans_utils","title":"<code>cdd.compound.doctrans_utils</code>","text":""},{"location":"api/#cdd.compound.doctrans_utils","title":"cdd.compound.doctrans_utils","text":"<p>Helpers to traverse the AST, extract the docstring out, parse and format to intended style</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.doctrans_utils.DocTrans","title":"DocTrans","text":"<pre><code>DocTrans(docstring_format, word_wrap, type_annotations, existing_type_annotations, whole_ast)\n</code></pre> <p>               Bases: <code>NodeTransformer</code></p> <p>Walk the nodes modifying the docstring and inlining||commenting types as it goes</p> <p>Parameters:</p> Name Type Description Default <p>Transform the docstrings found to intended docstring_format, potentially manipulating type annotations also</p> <p>Parameters:</p> Name Type Description Default <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>type_annotations</code> <code>bool</code> <p>True to have type annotations (3.6+), False to place in docstring</p> required <code>existing_type_annotations</code> <code>bool</code> <p>Whether there are any type annotations (3.6+)</p> required <code>whole_ast</code> <code>AST``</code> <p>The entire input AST, useful for lookups by location</p> required Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def __init__(\n    self,\n    docstring_format,\n    word_wrap,\n    type_annotations,\n    existing_type_annotations,\n    whole_ast,\n):\n    \"\"\"\n    Transform the docstrings found to intended docstring_format, potentially manipulating type annotations also\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param type_annotations: True to have type annotations (3.6+), False to place in docstring\n    :type type_annotations: ```bool```\n\n    :param existing_type_annotations: Whether there are any type annotations (3.6+)\n    :type existing_type_annotations: ```bool```\n\n    :param whole_ast: The entire input AST, useful for lookups by location\n    :type whole_ast: ```AST``\n    \"\"\"\n\n    self.docstring_format = docstring_format\n    self.word_wrap = word_wrap\n    self.type_annotations = type_annotations\n    self.existing_type_annotations = existing_type_annotations\n    if not hasattr(whole_ast, \"_location\"):\n        self.whole_ast = deepcopy(whole_ast)\n        annotate_ancestry(self.whole_ast)\n    else:\n        self.whole_ast = whole_ast\n    self.memoized = {}\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.DocTrans.visit_AnnAssign","title":"visit_AnnAssign","text":"<pre><code>visit_AnnAssign(node)\n</code></pre> <p>Handle <code>AnnAssign</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AnnAssign</code> <p>AnnAssign</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[AnnAssign, Assign]</code> <p><code>AnnAssign</code> if <code>type_annotations</code> and type found else <code>Assign</code></p> Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def visit_AnnAssign(self, node):\n    \"\"\"\n    Handle `AnnAssign`\n\n    :param node: AnnAssign\n    :type node: ```AnnAssign```\n\n    :return: `AnnAssign` if `type_annotations` and type found else `Assign`\n    :rtype: ```Union[AnnAssign, Assign]```\n    \"\"\"\n    if self.type_annotations:\n        node.annotation = self._get_ass_typ(node)\n        setattr(node, \"type_comment\", None)\n        return node\n\n    return Assign(\n        targets=[node.target],\n        lineno=node.lineno,\n        col_offset=getattr(node, \"col_offset\", None),\n        end_lineno=getattr(node, \"end_lineno\", None),\n        end_col_offset=getattr(node, \"end_col_offset\", None),\n        type_comment=to_type_comment(node.annotation),\n        # `var: int` is valid and turning it to `var = None  # type_comment int` would\n        # be wrong, as the upcoming smarter type tracer will reverse this to `var: Optional[int] = None`\n        value=set_value(none_types[-1]) if node.value is None else node.value,\n    )\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.DocTrans.visit_Assign","title":"visit_Assign","text":"<pre><code>visit_Assign(node)\n</code></pre> <p>Handle <code>Assign</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Assign</code> <p>Assign</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[Assign, AnnAssign]</code> <p><code>AnnAssign</code> if <code>type_annotations</code> and type found else <code>Assign</code></p> Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def visit_Assign(self, node):\n    \"\"\"\n    Handle `Assign`\n\n    :param node: Assign\n    :type node: ```Assign```\n\n    :return: `AnnAssign` if `type_annotations` and type found else `Assign`\n    :rtype: ```Union[Assign, AnnAssign]```\n    \"\"\"\n    typ = self._get_ass_typ(node)\n    annotation = (\n        None if not self.type_annotations or typ is None else to_annotation(typ)\n    )\n    if annotation:\n        assert len(node.targets) == 1\n        return AnnAssign(\n            annotation=to_annotation(typ),\n            lineno=node.lineno,\n            col_offset=getattr(node, \"col_offset\", None),\n            end_lineno=getattr(node, \"end_lineno\", None),\n            end_col_offset=getattr(node, \"end_col_offset\", None),\n            simple=1,\n            target=node.targets[0],\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            value=node.value,\n            **maybe_type_comment,\n        )\n    else:\n        setattr(node, \"type_comment\", typ)\n    return node\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.DocTrans.visit_FunctionDef","title":"visit_FunctionDef","text":"<pre><code>visit_FunctionDef(node)\n</code></pre> <p>visits the <code>FunctionDef</code>, potentially augmenting its docstring and argument types</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>FunctionDef</code> <p>FunctionDef</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p>Potentially changed FunctionDef</p> Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def visit_FunctionDef(self, node):\n    \"\"\"\n    visits the `FunctionDef`, potentially augmenting its docstring and argument types\n\n    :param node: FunctionDef\n    :type node: ```FunctionDef```\n\n    :return: Potentially changed FunctionDef\n    :rtype: ```FunctionDef```\n    \"\"\"\n    return self._handle_function(node, get_docstring(node, clean=False))\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.clear_annotation","title":"clear_annotation","text":"<pre><code>clear_annotation(node)\n</code></pre> <p>Remove annotations and type_comments from node</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>AST node with annotations and type_comments set to <code>None</code></p> Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def clear_annotation(node):\n    \"\"\"\n    Remove annotations and type_comments from node\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: AST node with annotations and type_comments set to `None`\n    :rtype: ```AST```\n    \"\"\"\n    if getattr(node, \"annotation\", None) is not None:\n        node.annotation = None\n    if getattr(node, \"type_comment\", None) is not None:\n        setattr(node, \"type_comment\", None)\n    return node\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.doctransify_cst","title":"doctransify_cst","text":"<pre><code>doctransify_cst(cst_list, node)\n</code></pre> <p>Carefully replace only docstrings, function return annotations, assignment and annotation assignments. (maintaining all other existing whitespace, comments, &amp;etc.); and only when cdd has changed them</p> <p>Parameters:</p> Name Type Description Default <code>cst_list</code> <code>list[NamedTuple]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> required <code>node</code> <code>AST</code> <p>AST node with a <code>.body</code>, probably the <code>ast.Module</code></p> required Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def doctransify_cst(cst_list, node):\n    \"\"\"\n    Carefully replace only docstrings, function return annotations, assignment and annotation assignments.\n    (maintaining all other existing whitespace, comments, &amp;etc.); and only when cdd has changed them\n\n    :param cst_list: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :type cst_list: ```list[NamedTuple]```\n\n    :param node: AST node with a `.body`, probably the `ast.Module`\n    :type node: ```AST```\n    \"\"\"\n    for _node in filter(rpartial(hasattr, \"_location\"), walk(node)):\n        is_func: bool = isinstance(_node, (AsyncFunctionDef, FunctionDef))\n        if isinstance(_node, ClassDef) or is_func:\n            cst_idx, cst_node = cdd.shared.ast_cst_utils.find_cst_at_ast(\n                cst_list, _node\n            )\n\n            if cst_node is None:\n                continue\n\n            cdd.shared.ast_cst_utils.maybe_replace_doc_str_in_function_or_class(\n                _node, cst_idx, cst_list\n            )\n\n            if not is_func:\n                continue\n\n            cur_ast_node: AST = ast_parse(\n                reindent_block_with_pass_body(cst_list[cst_idx].value),\n                skip_annotate=True,\n                skip_docstring_remit=True,\n            ).body[0]\n\n            cdd.shared.ast_cst_utils.maybe_replace_function_return_type(\n                _node, cur_ast_node, cst_idx, cst_list\n            )\n            cdd.shared.ast_cst_utils.maybe_replace_function_args(\n                _node, cur_ast_node, cst_idx, cst_list\n            )\n</code></pre>"},{"location":"api/#cdd.compound.doctrans_utils.has_type_annotations","title":"has_type_annotations","text":"<pre><code>has_type_annotations(node)\n</code></pre> <p>Whether the node\u2014incl. any nodes within this node\u2014have type annotations</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required Source code in <code>cdd/compound/doctrans_utils.py</code> <pre><code>def has_type_annotations(node):\n    \"\"\"\n    Whether the node\u2014incl. any nodes within this node\u2014have type annotations\n\n    :param node: AST node\n    :type node: ```AST```\n    \"\"\"\n    return any(\n        filter(\n            lambda _node: hasattr(_node, \"annotation\")\n            and _node.annotation is not None\n            or hasattr(_node, \"returns\")\n            and _node.returns is not None,\n            walk(node),\n        )\n    )\n</code></pre>"},{"location":"api/#cddcompoundexmod","title":"<code>cdd.compound.exmod</code>","text":""},{"location":"api/#cdd.compound.exmod","title":"cdd.compound.exmod","text":"<p>Not a dead module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.exmod.exmod","title":"exmod","text":"<pre><code>exmod(emit_name, module, blacklist, whitelist, output_directory, target_module_name, mock_imports, emit_sqlalchemy_submodule, extra_modules, no_word_wrap, recursive, dry_run, filesystem_layout='as_input', extra_modules_to_all=None)\n</code></pre> <p>Expose module as <code>emit</code> types into <code>output_directory</code></p> <p>Parameters:</p> Name Type Description Default <code>emit_name</code> <code>list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]</code> <p>What type(s) to generate.</p> required <code>module</code> <code>str</code> <p>Module name or path</p> required <code>blacklist</code> <code>Union[list[str], tuple[str]]</code> <p>Modules/FQN to omit. If unspecified will emit all (unless whitelist).</p> required <code>whitelist</code> <code>Union[list[str], tuple[str]]</code> <p>Modules/FQN to emit. If unspecified will emit all (minus blacklist).</p> required <code>output_directory</code> <code>str</code> <p>Where to place the generated exposed interfaces to the given <code>--module</code>.</p> required <code>target_module_name</code> <code>Optional[str]</code> <p>Target module name</p> required <code>mock_imports</code> <code>bool</code> <p>Whether to generate mock TensorFlow imports</p> required <code>emit_sqlalchemy_submodule</code> <code>bool</code> <p>Whether to emit submodule \"sqlalchemy_mod/{init,connection,create_tables}.py\"</p> required <code>extra_modules</code> <code>Optional[List[str]]</code> <p>Additional module(s) to expose; specifiable multiple times. Prepended to symbol auto-importer</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>recursive</code> <code>bool</code> <p>Recursively traverse module hierarchy and recreate hierarchy with exposed interfaces</p> required <code>dry_run</code> <code>bool</code> <p>Show what would be created; don't actually write to the filesystem</p> required <code>filesystem_layout</code> <code>Literal[\"java\", \"as_input\"]</code> <p>Hierarchy of folder and file names generated. \"java\" is file per package per name.</p> required <code>extra_modules_to_all</code> <code>Optional[tuple[tuple[str, frozenset], ...]]</code> <p>Internal arg. Prepended to symbol resolver. E.g., <code>((\"ast\", {\"List\"}),)</code>.</p> required Source code in <code>cdd/compound/exmod.py</code> <pre><code>def exmod(\n    emit_name,\n    module,\n    blacklist,\n    whitelist,\n    output_directory,\n    target_module_name,\n    mock_imports,\n    emit_sqlalchemy_submodule,\n    extra_modules,\n    no_word_wrap,\n    recursive,\n    dry_run,\n    filesystem_layout=\"as_input\",\n    extra_modules_to_all=None,\n):\n    \"\"\"\n    Expose module as `emit` types into `output_directory`\n\n    :param emit_name: What type(s) to generate.\n    :type emit_name: ```list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                     \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]```\n\n    :param module: Module name or path\n    :type module: ```str```\n\n    :param blacklist: Modules/FQN to omit. If unspecified will emit all (unless whitelist).\n    :type blacklist: ```Union[list[str], tuple[str]]```\n\n    :param whitelist: Modules/FQN to emit. If unspecified will emit all (minus blacklist).\n    :type whitelist: ```Union[list[str], tuple[str]]```\n\n    :param output_directory: Where to place the generated exposed interfaces to the given `--module`.\n    :type output_directory: ```str```\n\n    :param target_module_name: Target module name\n    :type target_module_name: ```Optional[str]```\n\n    :param mock_imports: Whether to generate mock TensorFlow imports\n    :type mock_imports: ```bool```\n\n    :param emit_sqlalchemy_submodule: Whether to emit submodule \"sqlalchemy_mod/{__init__,connection,create_tables}.py\"\n    :type emit_sqlalchemy_submodule: ```bool```\n\n    :param extra_modules: Additional module(s) to expose; specifiable multiple times. Prepended to symbol auto-importer\n    :type extra_modules: ```Optional[List[str]]```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param recursive: Recursively traverse module hierarchy and recreate hierarchy with exposed interfaces\n    :type recursive: ```bool```\n\n    :param dry_run: Show what would be created; don't actually write to the filesystem\n    :type dry_run: ```bool```\n\n    :param filesystem_layout: Hierarchy of folder and file names generated. \"java\" is file per package per name.\n    :type filesystem_layout: ```Literal[\"java\", \"as_input\"]```\n\n    :param extra_modules_to_all: Internal arg. Prepended to symbol resolver. E.g., `((\"ast\", {\"List\"}),)`.\n    :type extra_modules_to_all: ```Optional[tuple[tuple[str, frozenset], ...]]```\n    \"\"\"\n    output_directory = path.realpath(output_directory)\n    extra_modules_to_all = (\n        cdd.shared.ast_utils.module_to_all(extra_modules)\n        if extra_modules is not None and extra_modules_to_all is None\n        else tuple()\n    )  # type: tuple[tuple[str, frozenset], ...]\n    if not isinstance(emit_name, str):\n        deque(\n            map(\n                partial(\n                    exmod,\n                    module=module,\n                    blacklist=blacklist,\n                    whitelist=whitelist,\n                    mock_imports=mock_imports,\n                    filesystem_layout=filesystem_layout,\n                    emit_sqlalchemy_submodule=emit_sqlalchemy_submodule,\n                    extra_modules=extra_modules,\n                    no_word_wrap=no_word_wrap,\n                    output_directory=output_directory,\n                    target_module_name=target_module_name,\n                    recursive=recursive,\n                    dry_run=dry_run,\n                    extra_modules_to_all=extra_modules_to_all,\n                ),\n                emit_name or iter(()),\n            ),\n            maxlen=0,\n        )\n    elif dry_run:\n        print(\n            \"mkdir\\t'{output_directory}'\".format(\n                output_directory=path.normcase(output_directory)\n            ),\n            file=cdd.compound.exmod_utils.EXMOD_OUT_STREAM,\n        )\n    elif not path.isdir(output_directory):\n        makedirs(output_directory)\n\n    emit_name: Optional[str] = (\n        emit_name[0]\n        if emit_name is not None\n        and len(emit_name) == 1\n        and isinstance(emit_name, (list, tuple))\n        else emit_name\n    )\n    assert isinstance(\n        emit_name, (str, type(None))\n    ), \"Expected `str` got `{emit_name_type!r}`\".format(emit_name_type=type(emit_name))\n\n    module_root, _, submodule = module.rpartition(\".\")\n    module_name, new_module_name = (\n        module,\n        (\n            target_module_name or \"___\".join((module_root, \"gold\"))\n            if module_root\n            else \"gold\"\n        ),\n    )\n\n    sqlalchemy_mod: str = \"sqlalchemy_mod\"\n    sqlalchemy_mod_dir_join: typing.Union[\n        typing.Callable[[str], str], typing.Callable[[], str]\n    ] = partial(path.join, output_directory, \"sqlalchemy_mod\")\n    sqlalchemy_mod_dir = sqlalchemy_mod_dir_join()\n    make_sqlalchemy_mod: bool = (\n        emit_name in frozenset((\"sqlalchemy\", \"sqlalchemy_hybrid\", \"sqlalchemy_table\"))\n        and emit_sqlalchemy_submodule\n        and not path.isdir(sqlalchemy_mod_dir)\n    )\n    if make_sqlalchemy_mod:\n        extra_modules_to_all = _create_sqlalchemy_mod(\n            extra_modules_to_all,\n            output_directory,\n            sqlalchemy_mod,\n            sqlalchemy_mod_dir,\n            sqlalchemy_mod_dir_join,\n        )\n    try:\n        module_root_dir: str = path.dirname(\n            find_module_filepath(\n                *(module_root, submodule) if module_root else (module_name, None)\n            )\n        )\n    except AssertionError as e:\n        raise ModuleNotFoundError(e)\n\n    _exmod_single_folder = partial(\n        exmod_single_folder,\n        emit_name=emit_name,\n        blacklist=blacklist,\n        whitelist=whitelist,\n        mock_imports=mock_imports,\n        no_word_wrap=no_word_wrap,\n        dry_run=dry_run,\n        module_root=module_root,\n        new_module_name=new_module_name,\n        filesystem_layout=filesystem_layout,\n        extra_modules_to_all=extra_modules_to_all,\n        first_output_directory=output_directory,\n    )\n    packages: typing.List[str] = find_packages(\n        module_root_dir,\n        include=whitelist if whitelist else (\"*\",),\n        exclude=blacklist if blacklist else iter(()),\n    )\n\n    _exmod_single_folder(\n        module=module,\n        module_name=module_name,\n        module_root_dir=module_root_dir,\n        output_directory=output_directory,\n    )\n    output_directory_basename = path.basename(output_directory)\n    imports = (\n        [output_directory_basename] if make_sqlalchemy_mod else None\n    )  # type: Optional[list[str]]\n    _exmod_single_folder_kwargs: Tuple[\n        TypedDict(\n            \"_exmod_single_folder_kwargs\",\n            {\n                \"module\": module,\n                \"module_name\": module_name,\n                \"module_root_dir\": module_root_dir,\n                \"output_directory\": output_directory,\n            },\n        )\n    ] = tuple(\n        chain.from_iterable(\n            (\n                (\n                    {\n                        \"module\": module,\n                        \"module_name\": module_name,\n                        \"module_root_dir\": module_root_dir,\n                        \"output_directory\": output_directory,\n                    },\n                ),\n                (\n                    map(\n                        lambda package: (\n                            lambda pkg_relative_dir: (\n                                imports is not None\n                                and imports.append(\n                                    path.join(\n                                        output_directory_basename,\n                                        pkg_relative_dir,\n                                    ).replace(path.sep, \".\")\n                                )\n                                or {\n                                    \"module\": \".\".join((module, package)),\n                                    \"module_name\": package,\n                                    \"module_root_dir\": path.join(\n                                        module_root_dir, pkg_relative_dir\n                                    ),\n                                    \"output_directory\": path.join(\n                                        output_directory, pkg_relative_dir\n                                    ),\n                                }\n                            )\n                        )(package.replace(\".\", path.sep)),\n                        packages,\n                    )\n                    if recursive\n                    else iter(())\n                ),\n            )\n        )\n    )\n\n    if make_sqlalchemy_mod:\n        _add_imports_to_sqlalchemy_create_all(imports, sqlalchemy_mod_dir_join)\n\n    # This could be executed in parallel for efficiency\n    deque(\n        map(\n            lambda kwargs: _exmod_single_folder(**kwargs),\n            _exmod_single_folder_kwargs,\n        ),\n        maxlen=0,\n    )\n\n    return\n</code></pre>"},{"location":"api/#cdd.compound.exmod.exmod_single_folder","title":"exmod_single_folder","text":"<pre><code>exmod_single_folder(emit_name, module, blacklist, whitelist, output_directory, first_output_directory, mock_imports, no_word_wrap, dry_run, module_root_dir, module_root, module_name, new_module_name, filesystem_layout, extra_modules_to_all)\n</code></pre> <p>Expose module as <code>emit</code> types into <code>output_directory</code>. Single folder (non-recursive).</p> <p>Parameters:</p> Name Type Description Default <code>emit_name</code> <code>list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]</code> <p>What type(s) to generate.</p> required <code>module</code> <code>str</code> <p>Module name or path</p> required <code>blacklist</code> <code>Union[list[str], tuple[str]]</code> <p>Modules/FQN to omit. If unspecified will emit all (unless whitelist).</p> required <code>whitelist</code> <code>Union[list[str], tuple[str]]</code> <p>Modules/FQN to emit. If unspecified will emit all (minus blacklist).</p> required <code>output_directory</code> <code>str</code> <p>Where to place the generated exposed interfaces to the given <code>--module</code>.</p> required <code>first_output_directory</code> <code>str</code> <p>Initial output directory (e.g., direct from <code>--output-directory</code>)</p> required <code>mock_imports</code> <code>bool</code> <p>Whether to generate mock TensorFlow imports</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>dry_run</code> <code>bool</code> <p>Show what would be created; don't actually write to the filesystem</p> required <code>module_root_dir</code> <code>str</code> required <code>module_root</code> <code>str</code> required <code>module_name</code> <code>str</code> required <code>new_module_name</code> <code>str</code> required <code>filesystem_layout</code> <code>Literal[\"java\", \"as_input\"]</code> <p>Hierarchy of folder and file names generated. \"java\" is file per package per name.</p> required <code>extra_modules_to_all</code> <code>Optional[tuple[tuple[str, frozenset], ...]]</code> <p>Internal arg. Prepended to symbol resolver. E.g., <code>((\"ast\", {\"List\"}),)</code>.</p> required Source code in <code>cdd/compound/exmod.py</code> <pre><code>def exmod_single_folder(\n    emit_name,\n    module,\n    blacklist,\n    whitelist,\n    output_directory,\n    first_output_directory,\n    mock_imports,\n    no_word_wrap,\n    dry_run,\n    module_root_dir,\n    module_root,\n    module_name,\n    new_module_name,\n    filesystem_layout,\n    extra_modules_to_all,\n):\n    \"\"\"\n    Expose module as `emit` types into `output_directory`. Single folder (non-recursive).\n\n    :param emit_name: What type(s) to generate.\n    :type emit_name: ```list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                     \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]```\n\n    :param module: Module name or path\n    :type module: ```str```\n\n    :param blacklist: Modules/FQN to omit. If unspecified will emit all (unless whitelist).\n    :type blacklist: ```Union[list[str], tuple[str]]```\n\n    :param whitelist: Modules/FQN to emit. If unspecified will emit all (minus blacklist).\n    :type whitelist: ```Union[list[str], tuple[str]]```\n\n    :param output_directory: Where to place the generated exposed interfaces to the given `--module`.\n    :type output_directory: ```str```\n\n    :param first_output_directory: Initial output directory (e.g., direct from `--output-directory`)\n    :type first_output_directory: ```str```\n\n    :param mock_imports: Whether to generate mock TensorFlow imports\n    :type mock_imports: ```bool```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param dry_run: Show what would be created; don't actually write to the filesystem\n    :type dry_run: ```bool```\n\n    :param module_root_dir:\n    :type module_root_dir: ```str```\n\n    :param module_root:\n    :type module_root: ```str```\n\n    :param module_name:\n    :type module_name: ```str```\n\n    :param new_module_name:\n    :type new_module_name: ```str```\n\n    :param filesystem_layout: Hierarchy of folder and file names generated. \"java\" is file per package per name.\n    :type filesystem_layout: ```Literal[\"java\", \"as_input\"]```\n\n    :param extra_modules_to_all: Internal arg. Prepended to symbol resolver. E.g., `((\"ast\", {\"List\"}),)`.\n    :type extra_modules_to_all: ```Optional[tuple[tuple[str, frozenset], ...]]```\n    \"\"\"\n    mod_path: str = (\n        module_name\n        if module_name.startswith(module_root + \".\")\n        else \".\".join((module_root, module_name))\n    )\n    blacklist, whitelist = map(\n        frozenset, (blacklist or iter(()), whitelist or iter(()))\n    )\n    proceed: bool = any(\n        (\n            sum(map(len, (blacklist, whitelist))) == 0,\n            mod_path not in blacklist and (mod_path in whitelist or not whitelist),\n        )\n    )\n    if not proceed:\n        return\n\n    _emit_files_from_module_and_return_imports = partial(\n        cdd.compound.exmod_utils.emit_files_from_module_and_return_imports,\n        new_module_name=new_module_name,\n        emit_name=emit_name,\n        output_directory=output_directory,\n        first_output_directory=first_output_directory,\n        mock_imports=mock_imports,\n        no_word_wrap=no_word_wrap,\n        dry_run=dry_run,\n        filesystem_layout=filesystem_layout,\n        extra_modules_to_all=extra_modules_to_all,\n    )\n\n    imports = _emit_files_from_module_and_return_imports(\n        module_name=module_name, module=module, module_root_dir=module_root_dir\n    )  # type: Optional[list[ImportFrom]]\n    if not imports:\n        # Case: no obvious folder hierarchy, so parse the `__init__` file in root\n        top_level_init = path.join(module_root_dir, INIT_FILENAME)\n        with open(top_level_init, \"rt\") as f:\n            mod: Module = parse(f.read(), filename=top_level_init)\n\n        # TODO: Optimise these imports\n        imports = list(\n            chain.from_iterable(\n                map(\n                    lambda filepath_name_module: _emit_files_from_module_and_return_imports(\n                        module_root_dir=filepath_name_module[0],\n                        module_name=filepath_name_module[1],\n                        module=filepath_name_module[2],\n                    ),\n                    map(\n                        lambda filepath2modname_group: (\n                            filepath2modname_group[0][0],\n                            filepath2modname_group[0][1],\n                            reduce(\n                                partial(merge_modules, deduplicate_names=True),\n                                map(itemgetter(1), filepath2modname_group[1]),\n                            ),\n                        ),\n                        groupby(\n                            sorted(\n                                map(\n                                    lambda import_from: (\n                                        (\n                                            lambda module_filepath: (\n                                                (module_filepath, import_from.module),\n                                                construct_module_with_symbols(\n                                                    parse(\n                                                        read_file_to_str(\n                                                            module_filepath\n                                                        )\n                                                    ),\n                                                    map(\n                                                        attrgetter(\"name\"),\n                                                        import_from.names,\n                                                    ),\n                                                ),\n                                            )\n                                        )(\n                                            find_module_filepath(\n                                                *import_from.module.rsplit(\".\", 1)\n                                            )\n                                        )\n                                    ),\n                                    filter(rpartial(isinstance, ImportFrom), mod.body),\n                                ),\n                                key=itemgetter(0),\n                            ),\n                            key=itemgetter(0),\n                        ),\n                    ),\n                )\n            )\n        )  # type: list[ImportFrom]\n\n    # assert imports, \"Module contents are empty at {!r}\".format(module_root_dir)\n    modules_names: Tuple[str, ...] = cast(\n        Tuple[str, ...],\n        tuple(\n            map(\n                lambda name_module: (\n                    name_module[0],\n                    tuple(map(itemgetter(1), name_module[1])),\n                ),\n                groupby(\n                    map(\n                        lambda node_mod: (\n                            node_mod[0],\n                            node_mod[2].module,\n                        ),\n                        imports,\n                    ),\n                    itemgetter(0),\n                ),\n            )\n        ),\n    )\n\n    init_filepath: str = path.join(\n        output_directory,\n        *(\n            (INIT_FILENAME,)\n            if output_directory.endswith(\n                \"{}{}\".format(path.sep, new_module_name.replace(\".\", path.sep))\n            )\n            else (new_module_name, INIT_FILENAME)\n        )\n    )\n    if dry_run:\n        print(\n            \"write\\t'{init_filepath}'\".format(\n                init_filepath=path.normcase(init_filepath)\n            ),\n            file=cdd.compound.exmod_utils.EXMOD_OUT_STREAM,\n        )\n    else:\n        makedirs(path.dirname(init_filepath), exist_ok=True)\n        cdd.shared.emit.file.file(\n            deduplicate_sorted_imports(\n                Module(\n                    body=list(\n                        chain.from_iterable(\n                            (\n                                (\n                                    Expr(\n                                        set_value(\"\\nExport internal imports\\n\"),\n                                        lineno=None,\n                                        col_offset=None,\n                                    ),\n                                ),\n                                map(\n                                    lambda module_names: ImportFrom(\n                                        module=module_names[0],\n                                        names=list(\n                                            map(\n                                                lambda names: alias(\n                                                    names,\n                                                    None,\n                                                    identifier=None,\n                                                    identifier_name=None,\n                                                ),\n                                                module_names[1],\n                                            )\n                                        ),\n                                        level=1,\n                                        identifier=None,\n                                    ),\n                                    modules_names,\n                                ),\n                                (\n                                    Assign(\n                                        targets=[\n                                            Name(\n                                                \"__all__\",\n                                                Store(),\n                                                lineno=None,\n                                                col_offset=None,\n                                            )\n                                        ],\n                                        value=List(\n                                            ctx=Load(),\n                                            elts=list(\n                                                map(\n                                                    set_value,\n                                                    sorted(\n                                                        frozenset(\n                                                            chain.from_iterable(\n                                                                map(\n                                                                    itemgetter(1),\n                                                                    modules_names,\n                                                                )\n                                                            ),\n                                                        )\n                                                    ),\n                                                )\n                                            ),\n                                            expr=None,\n                                        ),\n                                        expr=None,\n                                        lineno=None,\n                                        **maybe_type_comment\n                                    ),\n                                ),\n                            )\n                        )\n                    ),\n                    stmt=None,\n                    type_ignores=[],\n                )\n            ),\n            init_filepath,\n            mode=\"wt\",\n        )\n</code></pre>"},{"location":"api/#cddcompoundexmod_utils","title":"<code>cdd.compound.exmod_utils</code>","text":""},{"location":"api/#cdd.compound.exmod_utils","title":"cdd.compound.exmod_utils","text":"<p>Exmod utils</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.exmod_utils.emit_file_on_hierarchy","title":"emit_file_on_hierarchy","text":"<pre><code>emit_file_on_hierarchy(name_orig_ir, emit_name, module_name, new_module_name, mock_imports, filesystem_layout, extra_modules_to_all, output_directory, first_output_directory, no_word_wrap, dry_run)\n</code></pre> <p>Generate Java-package\u2014or match input\u2014style file hierarchy from fully-qualified module name</p> <p>Parameters:</p> Name Type Description Default <code>name_orig_ir</code> <code>str</code> <p>FQ module name, original filename path, IR</p> required <code>emit_name</code> <code>list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]</code> <p>What type(s) to generate.</p> required <code>module_name</code> <code>str</code> <p>Name of [original] module</p> required <code>new_module_name</code> <code>str</code> <p>Name of [new] module</p> required <code>mock_imports</code> <code>bool</code> <p>Whether to generate mock TensorFlow imports</p> required <code>filesystem_layout</code> <code>Literal[\"java\", \"as_input\"]</code> <p>Hierarchy of folder and file names generated. \"java\" is file per package per name.</p> required <code>extra_modules_to_all</code> <code>Optional[tuple[tuple[str, frozenset], ...]]</code> <p>Internal arg. Prepended to symbol resolver. E.g., <code>((\"ast\", {\"List\"}),)</code>.</p> required <code>output_directory</code> <code>str</code> <p>Where to place the generated exposed interfaces to the given <code>--module</code>.</p> required <code>first_output_directory</code> <code>str</code> <p>Initial output directory (e.g., direct from <code>--output-directory</code>)</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>dry_run</code> <code>bool</code> <p>Show what would be created; don't actually write to the filesystem</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Tuple[Optional[str], str, ImportFrom]]</code> <p>(mod_name or None, relative_filename_path, ImportFrom) to generated module</p> Source code in <code>cdd/compound/exmod_utils.py</code> <pre><code>def emit_file_on_hierarchy(\n    name_orig_ir,\n    emit_name,\n    module_name,\n    new_module_name,\n    mock_imports,\n    filesystem_layout,\n    extra_modules_to_all,\n    output_directory,\n    first_output_directory,\n    no_word_wrap,\n    dry_run,\n):\n    \"\"\"\n    Generate Java-package\u2014or match input\u2014style file hierarchy from fully-qualified module name\n\n    :param name_orig_ir: FQ module name, original filename path, IR\n    :type name_orig_ir: ```tuple[str, str, dict]```\n\n    :param emit_name: What type(s) to generate.\n    :type emit_name: ```list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                     \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]```\n\n    :param module_name: Name of [original] module\n    :type module_name: ```str```\n\n    :param new_module_name: Name of [new] module\n    :type new_module_name: ```str```\n\n    :param mock_imports: Whether to generate mock TensorFlow imports\n    :type mock_imports: ```bool```\n\n    :param filesystem_layout: Hierarchy of folder and file names generated. \"java\" is file per package per name.\n    :type filesystem_layout: ```Literal[\"java\", \"as_input\"]```\n\n    :param extra_modules_to_all: Internal arg. Prepended to symbol resolver. E.g., `((\"ast\", {\"List\"}),)`.\n    :type extra_modules_to_all: ```Optional[tuple[tuple[str, frozenset], ...]]```\n\n    :param output_directory: Where to place the generated exposed interfaces to the given `--module`.\n    :type output_directory: ```str```\n\n    :param first_output_directory: Initial output directory (e.g., direct from `--output-directory`)\n    :type first_output_directory: ```str```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param dry_run: Show what would be created; don't actually write to the filesystem\n    :type dry_run: ```bool```\n\n    :return: (mod_name or None, relative_filename_path, ImportFrom) to generated module\n    :rtype: ```Optional[Tuple[Optional[str], str, ImportFrom]]```\n    \"\"\"\n    mod_name, _, name = name_orig_ir[0].rpartition(\".\")\n    original_relative_filename_path, ir = name_orig_ir[1], name_orig_ir[2]\n    assert original_relative_filename_path\n\n    relative_filename_path: str = original_relative_filename_path\n    module_name_as_path: str = module_name.replace(\".\", path.sep)\n    if relative_filename_path.startswith(module_name_as_path + path.sep):\n        relative_filename_path: str = relative_filename_path[\n            len(module_name_as_path + path.sep) :\n        ]\n    if not name and ir.get(\"name\") is not None:\n        name: Optional[str] = ir.get(\"name\")\n\n    output_dir_is_module: bool = output_directory.replace(path.sep, \".\").endswith(\n        new_module_name\n    )\n    mod_path: str = path.join(\n        output_directory,\n        *(\n            ()\n            if output_dir_is_module\n            else (new_module_name, mod_name.replace(\".\", path.sep))\n        )\n    )\n    # print(\"mkdir\\t{mod_path!r}\".format(mod_path=mod_path), file=EXMOD_OUT_STREAM)\n    if not path.isdir(mod_path):\n        if dry_run:\n            print(\n                \"mkdir\\t'{mod_path}'\".format(mod_path=path.normcase(mod_path)),\n                file=EXMOD_OUT_STREAM,\n            )\n        else:\n            makedirs(mod_path)\n\n    init_filepath: str = path.join(path.dirname(mod_path), INIT_FILENAME)\n    if dry_run:\n        print(\n            \"touch\\t'{init_filepath}'\".format(\n                init_filepath=path.normcase(init_filepath)\n            ),\n            file=EXMOD_OUT_STREAM,\n        )\n    else:\n        open(init_filepath, \"a\").close()\n\n    emit_filename, init_filepath = (\n        map(\n            partial(\n                path.join,\n                output_directory,\n                *() if output_dir_is_module else (new_module_name,)\n            ),\n            (\n                relative_filename_path,\n                path.join(\n                    path.dirname(relative_filename_path),\n                    INIT_FILENAME,\n                ),\n            ),\n        )\n        if filesystem_layout == \"as_input\"\n        else map(\n            partial(path.join, mod_path),\n            (\n                \"{name}{extsep}py\".format(name=name, extsep=extsep),\n                INIT_FILENAME,\n            ),\n        )\n    )\n    symbol_in_file: bool = path.isfile(emit_filename)\n    isfile_emit_filename: bool = symbol_in_file\n    existent_mod: Optional[Module] = None\n    if isfile_emit_filename:\n        with open(emit_filename, \"rt\") as f:\n            emit_filename_contents: str = f.read()\n        existent_mod: Module = ast_parse(\n            emit_filename_contents, skip_docstring_remit=True, filename=emit_filename\n        )  # Also, useful as this catches syntax errors\n        symbol_in_file: bool = any(\n            filter(\n                partial(eq, name),\n                map(\n                    attrgetter(\"name\"),\n                    filter(rpartial(hasattr, \"name\"), existent_mod.body),\n                ),\n            )\n        )\n    else:\n        emit_filename_dir: str = path.dirname(emit_filename)\n        if not path.isdir(emit_filename_dir):\n            (\n                print(\n                    \"mkdir\\t'{emit_filename_dir}'\".format(\n                        emit_filename_dir=path.normcase(emit_filename_dir)\n                    ),\n                    file=EXMOD_OUT_STREAM,\n                )\n                if dry_run\n                else makedirs(emit_filename_dir)\n            )\n\n    if not symbol_in_file and (ir.get(\"name\") or ir[\"params\"] or ir[\"returns\"]):\n        _emit_symbol(\n            name_orig_ir=name_orig_ir,\n            emit_name=emit_name,\n            module_name=module_name,\n            emit_filename=emit_filename,\n            existent_mod=existent_mod,\n            init_filepath=init_filepath,\n            intermediate_repr=ir,\n            isfile_emit_filename=isfile_emit_filename,\n            name=name,\n            mock_imports=mock_imports,\n            extra_modules_to_all=extra_modules_to_all,\n            no_word_wrap=no_word_wrap,\n            first_output_directory=first_output_directory,\n            dry_run=dry_run,\n        )\n</code></pre>"},{"location":"api/#cdd.compound.exmod_utils.emit_files_from_module_and_return_imports","title":"emit_files_from_module_and_return_imports","text":"<pre><code>emit_files_from_module_and_return_imports(module_name, module_root_dir, new_module_name, emit_name, module, output_directory, first_output_directory, mock_imports, no_word_wrap, dry_run, filesystem_layout, extra_modules_to_all)\n</code></pre> <p>Emit type <code>emit_name</code> of all files in <code>module_root_dir</code> into <code>output_directory</code> on <code>new_module_name</code> hierarchy. Then return the new imports.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of existing module</p> required <code>module_root_dir</code> <code>str</code> <p>Root dir of existing module</p> required <code>new_module_name</code> <code>str</code> <p>New module name</p> required <code>emit_name</code> <code>list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]</code> <p>What type(s) to generate.</p> required <code>module</code> <code>Module</code> <p>Module itself</p> required <code>output_directory</code> <code>str</code> <p>Where to place the generated exposed interfaces to the given <code>--module</code>.</p> required <code>first_output_directory</code> <code>str</code> <p>Initial output directory (e.g., direct from <code>--output-directory</code>)</p> required <code>mock_imports</code> <code>bool</code> <p>Whether to generate mock TensorFlow imports</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>dry_run</code> <code>bool</code> <p>Show what would be created; don't actually write to the filesystem</p> required <code>filesystem_layout</code> <code>Literal[\"java\", \"as_input\"]</code> <p>Hierarchy of folder and file names generated. \"java\" is file per package per name.</p> required <code>extra_modules_to_all</code> <code>Optional[tuple[tuple[str, frozenset], ...]]</code> <p>Internal arg. Prepended to symbol resolver. E.g., <code>((\"ast\", {\"List\"}),)</code>.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[Tuple[Optional[str], str, ImportFrom]]</code> <p>List of (mod_name or None, relative_filename_path, ImportFrom) to generated module(s)</p> Source code in <code>cdd/compound/exmod_utils.py</code> <pre><code>def emit_files_from_module_and_return_imports(\n    module_name,\n    module_root_dir,\n    new_module_name,\n    emit_name,\n    module,\n    output_directory,\n    first_output_directory,\n    mock_imports,\n    no_word_wrap,\n    dry_run,\n    filesystem_layout,\n    extra_modules_to_all,\n):\n    \"\"\"\n    Emit type `emit_name` of all files in `module_root_dir` into `output_directory`\n    on `new_module_name` hierarchy. Then return the new imports.\n\n    :param module_name: Name of existing module\n    :type module_name: ```str```\n\n    :param module_root_dir: Root dir of existing module\n    :type module_root_dir: ```str```\n\n    :param new_module_name: New module name\n    :type new_module_name: ```str```\n\n    :param emit_name: What type(s) to generate.\n    :type emit_name: ```list[Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                     \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]]```\n\n    :param module: Module itself\n    :type module: ```Module```\n\n    :param output_directory: Where to place the generated exposed interfaces to the given `--module`.\n    :type output_directory: ```str```\n\n    :param first_output_directory: Initial output directory (e.g., direct from `--output-directory`)\n    :type first_output_directory: ```str```\n\n    :param mock_imports: Whether to generate mock TensorFlow imports\n    :type mock_imports: ```bool```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param dry_run: Show what would be created; don't actually write to the filesystem\n    :type dry_run: ```bool```\n\n    :param filesystem_layout: Hierarchy of folder and file names generated. \"java\" is file per package per name.\n    :type filesystem_layout: ```Literal[\"java\", \"as_input\"]```\n\n    :param extra_modules_to_all: Internal arg. Prepended to symbol resolver. E.g., `((\"ast\", {\"List\"}),)`.\n    :type extra_modules_to_all: ```Optional[tuple[tuple[str, frozenset], ...]]```\n\n    :return: List of (mod_name or None, relative_filename_path, ImportFrom) to generated module(s)\n    :rtype: ```list[Tuple[Optional[str], str, ImportFrom]]```\n    \"\"\"\n    _emit_file_on_hierarchy = partial(\n        emit_file_on_hierarchy,\n        emit_name=emit_name,\n        module_name=module_name,\n        new_module_name=new_module_name,\n        mock_imports=mock_imports,\n        filesystem_layout=filesystem_layout,\n        output_directory=output_directory,\n        first_output_directory=first_output_directory,\n        extra_modules_to_all=extra_modules_to_all,\n        no_word_wrap=no_word_wrap,\n        dry_run=dry_run,\n    )\n\n    # Might need some `groupby` in case multiple files are in the one project; same for `get_module_contents`\n    return list(\n        filter(\n            None,\n            map(\n                _emit_file_on_hierarchy,\n                map(\n                    lambda name_source: (\n                        name_source[0],\n                        (\n                            path.join(output_directory, path.basename(module_root_dir))\n                            if path.isfile(module_root_dir)\n                            else (\n                                lambda filename: (\n                                    filename[len(module_name) + 1 :]\n                                    if filename.startswith(module_name)\n                                    else filename\n                                )\n                            )(\n                                relative_filename(\n                                    name_source[1].__file__\n                                    if hasattr(name_source[1], \"__file__\")\n                                    else getfile(name_source[1])\n                                )\n                            )\n                        ),\n                        (\n                            {\"params\": OrderedDict(), \"returns\": OrderedDict()}\n                            if dry_run\n                            else (\n                                lambda parser: (\n                                    partial(parser, merge_inner_function=\"__init__\")\n                                    if parser is cdd.class_.parse.class_\n                                    else parser\n                                )\n                            )(get_parser(name_source[1], \"infer\"))(name_source[1])\n                        ),\n                    ),\n                    map(\n                        lambda name_source: (\n                            (\n                                name_source[0][len(module_name) + 1 :]\n                                if name_source[0].startswith(module_name)\n                                else name_source[0]\n                            ),\n                            name_source[1],\n                        ),\n                        get_module_contents(\n                            module, module_root_dir=module_root_dir\n                        ).items(),\n                    ),\n                ),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.compound.exmod_utils.get_module_contents","title":"get_module_contents","text":"<pre><code>get_module_contents(obj, module_root_dir, current_module=None, _result={})\n</code></pre> <p>Helper function to get the recursive inner module contents</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Something to <code>dir</code> on</p> required <code>module_root_dir</code> <code>str</code> <p>Root of module</p> required <code>current_module</code> <code>Optional[str]</code> <p>The current module</p> required <code>_result</code> <code>dict</code> <p>The result var (used internally as accumulator)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Dict[str,Generator[Any]]</code> <p>fully-qualified module name to values (could be modules, classes, and whatever other symbols are exposed)</p> Source code in <code>cdd/compound/exmod_utils.py</code> <pre><code>def get_module_contents(obj, module_root_dir, current_module=None, _result={}):\n    \"\"\"\n    Helper function to get the recursive inner module contents\n\n    :param obj: Something to `dir` on\n    :type obj: ```Any```\n\n    :param module_root_dir: Root of module\n    :type module_root_dir: ```str```\n\n    :param current_module: The current module\n    :type current_module: ```Optional[str]```\n\n    :param _result: The result var (used internally as accumulator)\n    :type _result: ```dict```\n\n    :return: fully-qualified module name to values (could be modules, classes, and whatever other symbols are exposed)\n    :rtype: ```Dict[str,Generator[Any]]```\n    \"\"\"\n    module_root_dir_init: str = path.join(module_root_dir, INIT_FILENAME)\n    # process_module_contents = partial(\n    #     _process_module_contents,\n    #     _result=_result,\n    #     current_module=current_module,\n    #     module_root_dir=module_root_dir,\n    # )\n    if path.isfile(module_root_dir):\n        with open(module_root_dir, \"rt\") as f:\n            mod: Module = ast_parse(\n                f.read(), filename=module_root_dir, skip_docstring_remit=True\n            )\n\n        # Bring in imported symbols that should be exposed based on `__all__`\n        all_magic_var = next(\n            map(\n                lambda assign: frozenset(\n                    map(cdd.shared.ast_utils.get_value, assign.value.elts)\n                ),\n                filter(\n                    lambda assign: len(assign.targets) == 1\n                    and isinstance(assign.targets[0], Name)\n                    and assign.targets[0].id == \"__all__\",\n                    filter(rpartial(isinstance, Assign), mod.body),\n                ),\n            ),\n            iter(()),\n        )  # type: Union[list[str], Iterator]\n        mod_to_symbol: defaultdict[Any, list] = defaultdict(list)\n        deque(\n            (\n                mod_to_symbol[import_from.module].append(name.name)\n                for import_from in filter(\n                    rpartial(isinstance, ImportFrom), ast_walk(mod)\n                )\n                for name in import_from.names\n                if name.asname is None\n                and name.name in all_magic_var\n                or name.asname in all_magic_var\n            ),\n            maxlen=0,\n        )\n        res: Dict[str, AST] = {\n            \"{module_name}{submodule_name}.{node_name}\".format(\n                module_name=\"{}.\".format(module_name) if module_name else \"\",\n                submodule_name=submodule_name,\n                node_name=node.name,\n            ): node\n            for module_name, submodule_names in mod_to_symbol.items()\n            for submodule_name in submodule_names\n            for node in (\n                lambda module_filepath: (\n                    iter(())\n                    if module_filepath is None\n                    else ast_parse(\n                        read_file_to_str(module_filepath),\n                        module_filepath,\n                        skip_docstring_remit=True,\n                    ).body\n                )\n            )(\n                cdd.shared.pure_utils.find_module_filepath(\n                    module_name, submodule_name, none_when_no_spec=True\n                )\n            )\n            if hasattr(node, \"name\")\n        }\n        res.update(\n            dict(\n                map(\n                    lambda node: (\n                        (\n                            node.name\n                            if current_module is None\n                            else \"{current_module}.{name}\".format(\n                                current_module=current_module, name=node.name\n                            )\n                        ),\n                        node,\n                    ),\n                    filter(lambda node: hasattr(node, \"name\"), mod.body),\n                )\n            )\n        )\n        return res\n    elif path.isfile(module_root_dir_init):\n        return get_module_contents(\n            obj=obj,\n            module_root_dir=module_root_dir_init,\n            current_module=current_module,\n            _result=_result,\n        )\n    # assert not isinstance(\n    #     obj, (int, float, complex, str, bool, type(None))\n    # ), \"module is unexpected type: {!r}\".format(type(obj).__name__)\n    # for name, symbol in no_magic_or_builtin_dir2attr(obj).items():\n    #     process_module_contents(name=name, symbol=symbol)\n    return _result\n</code></pre>"},{"location":"api/#cddcompoundgen","title":"<code>cdd.compound.gen</code>","text":""},{"location":"api/#cdd.compound.gen","title":"cdd.compound.gen","text":"<p>Functionality to generate classes, functions, and/or argparse functions from the input mapping</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.gen.gen","title":"gen","text":"<pre><code>gen(name_tpl, input_mapping, parse_name, emit_name, output_filename, prepend=None, imports_from_file=None, emit_call=False, emit_default_doc=True, emit_and_infer_imports=False, decorator_list=None, phase=0, no_word_wrap=None)\n</code></pre> <p>Generate classes, functions, and/or argparse functions from the input mapping</p> <p>Parameters:</p> Name Type Description Default <code>name_tpl</code> <code>str</code> <p>Template for the name, e.g., <code>{name}Config</code>.</p> required <code>input_mapping</code> <code>str</code> <p>Fully-qualified module, filepath, or directory.</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\", \"infer\"]</code> <p>Which type to parse.</p> required <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>output_filename</code> <code>str</code> <p>Output file to write to</p> required <code>prepend</code> <code>Optional[str]</code> <p>Prepend file with this. Use ' ' for newlines.</p> required <code>imports_from_file</code> <code>Optional[str]</code> <p>Extract imports from file and append to <code>output_file</code>. If module or other symbol path given, resolve file then use it.</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>emit_and_infer_imports</code> <code>bool</code> <p>Whether to emit and infer imports at the top of the generated code</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>phase</code> <code>int</code> <p>Which phase to run through. E.g., SQLalchemy may require multiple phases to resolve foreign keys</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required Source code in <code>cdd/compound/gen.py</code> <pre><code>def gen(\n    name_tpl,\n    input_mapping,\n    parse_name,\n    emit_name,\n    output_filename,\n    prepend=None,\n    imports_from_file=None,\n    emit_call=False,\n    emit_default_doc=True,\n    emit_and_infer_imports=False,\n    decorator_list=None,\n    phase=0,\n    no_word_wrap=None,\n):\n    \"\"\"\n    Generate classes, functions, and/or argparse functions from the input mapping\n\n    :param name_tpl: Template for the name, e.g., `{name}Config`.\n    :type name_tpl: ```str```\n\n    :param input_mapping: Fully-qualified module, filepath, or directory.\n    :type input_mapping: ```str```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\", \"infer\"]```\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param output_filename: Output file to write to\n    :type output_filename: ```str```\n\n    :param prepend: Prepend file with this. Use '\\n' for newlines.\n    :type prepend: ```Optional[str]```\n\n    :param imports_from_file: Extract imports from file and append to `output_file`.\n        If module or other symbol path given, resolve file then use it.\n    :type imports_from_file: ```Optional[str]```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param emit_and_infer_imports: Whether to emit and infer imports at the top of the generated code\n    :type emit_and_infer_imports: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param phase: Which phase to run through. E.g., SQLalchemy may require multiple phases to resolve foreign keys\n    :type phase: ```int```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n    \"\"\"\n    extra_symbols = {}\n    if phase &gt; 0 and emit_name in frozenset(\n        (\"sqlalchemy\", \"sqlalchemy_hybrid\", \"sqlalchemy_table\")\n    ):\n        if phase == 1:\n            return cdd.sqlalchemy.utils.emit_utils.update_with_imports_from_columns(\n                output_filename\n            )\n        elif phase == 2:\n            return cdd.sqlalchemy.utils.emit_utils.update_fk_for_file(output_filename)\n        else:\n            raise NotImplementedError(\"phase {}\".format(phase))\n    elif imports_from_file is None:\n        imports: str = \"\"\n    else:\n        if prepend:\n            prepend_imports: Union[Import, ImportFrom] = get_at_root(\n                ast.parse(prepend.strip()), (Import, ImportFrom)\n            )\n\n            # def rewrite_typings(node):\n            #     \"\"\"\n            #     Python &lt; 3.8 must use `typings_extensions` for `Literal`\n            #\n            #     :param node: import node\n            #     :type node: ```Union[Import, ImportFrom]```\n            #\n            #     :return: The import potentially rewritten or None\n            #     :rtype: ```Optional[Union[Import, ImportFrom]]```\n            #     \"\"\"\n            #     if isinstance(node, ImportFrom) and node.module == \"typing\":\n            #         len_names = len(node.names)\n            #         if len_names == 1 and node.names[0].name == \"Literal\":\n            #             rewrite_typings.found_literal = True\n            #             return None\n            #         else:\n            #             node.names = list(\n            #                 filter(\n            #                     None,\n            #                     map(\n            #                         lambda _alias: None\n            #                         if _alias.name == \"Literal\"\n            #                         else _alias,\n            #                         node.names,\n            #                     ),\n            #                 )\n            #             )\n            #             if len(node.names) != len_names:\n            #                 rewrite_typings.found_literal = True\n            #     return node\n            #\n            # rewrite_typings.found_literal = False\n            # prepend_imports = list(filter(None, map(rewrite_typings, prepend_imports)))\n            # if rewrite_typings.found_literal:\n            #     prepend_imports.append(\n            #         ImportFrom(\n            #             level=0,\n            #             module=\"typing_extensions\"\n            #             if sys.version_info[:2] &lt; (3, 8)\n            #             else \"typing\",\n            #             names=[alias(asname=None, name=\"Literal\")],\n            #             lineno=None,\n            #             col_offset=None,\n            #         )\n            #     )\n\n            eval(\n                compile(\n                    to_code(\n                        ast.fix_missing_locations(\n                            Module(body=prepend_imports, stmt=None, type_ignores=[])\n                        )\n                    ),\n                    filename=\"&lt;string&gt;\",\n                    mode=\"exec\",\n                ),\n                extra_symbols,\n            )\n            # This leaks to the global scope\n            globals().update(extra_symbols)\n        with open(\n            (\n                imports_from_file\n                if path.isfile(imports_from_file)\n                else getfile(get_module(imports_from_file, extra_symbols=extra_symbols))\n            ),\n            \"rt\",\n        ) as f:\n            imports: str = \"\".join(\n                map(to_code, get_at_root(ast.parse(f.read()), (Import, ImportFrom)))\n            )\n\n    module_path, _, symbol_name = input_mapping.rpartition(\".\")\n\n    emit_name: str = sanitise_emit_name(emit_name)\n    if path.isfile(input_mapping):\n        input_mapping = file_to_input_mapping(input_mapping, parse_name)\n    elif path.isdir(input_mapping):\n        _input_mapping = {}\n        deque(\n            map(\n                _input_mapping.update,\n                map(\n                    partial(\n                        file_to_input_mapping,\n                        parse_name=parse_name,\n                    ),\n                    map(partial(path.join, input_mapping), listdir(input_mapping)),\n                ),\n            ),\n            maxlen=0,\n        )\n        input_mapping = _input_mapping\n        del _input_mapping\n    else:\n        input_mod = get_module(module_path, extra_symbols=extra_symbols)\n        input_mapping = (\n            getattr(input_mod, symbol_name)\n            if hasattr(input_mod, symbol_name)\n            else get_input_mapping_from_path(emit_name, module_path, symbol_name)\n        )\n    input_mapping_it = (\n        input_mapping.items() if hasattr(input_mapping, \"items\") else input_mapping\n    )\n\n    return (\n        cdd.json_schema.emit.json_schema_file(\n            {\n                name: get_emitter(emit_name)(\n                    get_parser(node, parse_name)(node),\n                    emit_default_doc=emit_default_doc,\n                    word_wrap=no_word_wrap is None,\n                    **get_emit_kwarg(\n                        decorator_list, emit_call, emit_name, name_tpl, name\n                    ),\n                )\n                for name, node in input_mapping_it\n            },\n            output_filename,\n        )\n        if emit_name == \"json_schema\"\n        else gen_file(\n            name_tpl,\n            input_mapping_it,\n            parse_name,\n            emit_name,\n            output_filename,\n            prepend,\n            emit_call,\n            emit_and_infer_imports,\n            emit_default_doc,\n            decorator_list,\n            no_word_wrap,\n            imports,\n        )\n    )\n</code></pre>"},{"location":"api/#cddcompoundgen_utils","title":"<code>cdd.compound.gen_utils</code>","text":""},{"location":"api/#cdd.compound.gen_utils","title":"cdd.compound.gen_utils","text":"<p>Utility functions for <code>cdd.gen</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.gen_utils.file_to_input_mapping","title":"file_to_input_mapping","text":"<pre><code>file_to_input_mapping(filepath, parse_name)\n</code></pre> <p>Create an <code>input_mapping</code> from a given file, i.e. Dict[str, AST]</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Location of JSON or Python file</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                              \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\", \"infer\"]</code> <p>Which type to parse.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict``</code> <p>Dictionary of string (name) to AST node</p> Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def file_to_input_mapping(filepath, parse_name):\n    \"\"\"\n    Create an `input_mapping` from a given file, i.e. Dict[str, AST]\n\n    :param filepath: Location of JSON or Python file\n    :type filepath: ```str```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\", \"infer\"]```\n\n    :return: Dictionary of string (name) to AST node\n    :rtype: ```dict``\n    \"\"\"\n    if (\n        parse_name == \"json_schema\"\n        or parse_name == \"infer\"\n        and filepath.endswith(\"{}json\".format(path.extsep))\n    ):\n        with open(filepath, \"rt\") as f:\n            json_contents = load(f)\n        name: str = path.basename(filepath)\n        if \"name\" not in json_contents:\n            json_contents[\"name\"] = pascal_to_upper_camelcase(name)\n        input_mapping = {name: json_contents}  # type: dict[str, Union[str, AST]]\n    else:\n        with open(filepath, \"rt\") as f:\n            mod = ast_parse(f.read())\n\n        input_mapping = dict(\n            map(\n                lambda node: (node.name, node),\n                filter(\n                    rpartial(\n                        isinstance,\n                        (\n                            tuple(kind2instance_type.values())\n                            if parse_name == \"infer\"\n                            else kind2instance_type[parse_name]\n                        ),\n                    ),\n                    mod.body,\n                ),\n            ),\n        )\n    return input_mapping\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.gen_file","title":"gen_file","text":"<pre><code>gen_file(name_tpl, input_mapping_it, parse_name, emit_name, output_filename, prepend, emit_call, emit_and_infer_imports, emit_default_doc, decorator_list, no_word_wrap, imports, functions_and_classes=None)\n</code></pre> <p>Generate Python file of containing <code>input_mapping_it</code>.values converted to <code>emit_name</code></p> <p>Parameters:</p> Name Type Description Default <code>name_tpl</code> <code>str</code> <p>Template for the name, e.g., <code>{name}Config</code>.</p> required <code>input_mapping_it</code> <code>Iterator[tuple[str, AST]]</code> <p>Import location of mapping/2-tuple collection.</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to parse.</p> required <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>output_filename</code> <code>str</code> <p>Output file to write to</p> required <code>prepend</code> <code>Optional[str]</code> <p>Prepend file with this. Use ' ' for newlines.</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>emit_and_infer_imports</code> <code>bool</code> <p>Whether to emit and infer imports at the top of the generated code</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>imports</code> <code>str</code> <p>Import to preclude in Python file</p> required <code>functions_and_classes</code> <code>Optional[tuple[AST]]</code> <p>Functions and classes that have been preparsed</p> required Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def gen_file(\n    name_tpl,\n    input_mapping_it,\n    parse_name,\n    emit_name,\n    output_filename,\n    prepend,\n    emit_call,\n    emit_and_infer_imports,\n    emit_default_doc,\n    decorator_list,\n    no_word_wrap,\n    imports,\n    functions_and_classes=None,\n):\n    \"\"\"\n    Generate Python file of containing `input_mapping_it`.values converted to `emit_name`\n\n    :param name_tpl: Template for the name, e.g., `{name}Config`.\n    :type name_tpl: ```str```\n\n    :param input_mapping_it: Import location of mapping/2-tuple collection.\n    :type input_mapping_it: ```Iterator[tuple[str, AST]]```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param output_filename: Output file to write to\n    :type output_filename: ```str```\n\n    :param prepend: Prepend file with this. Use '\\n' for newlines.\n    :type prepend: ```Optional[str]```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param emit_and_infer_imports: Whether to emit and infer imports at the top of the generated code\n    :type emit_and_infer_imports: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param imports: Import to preclude in Python file\n    :type imports: ```str```\n\n    :param functions_and_classes: Functions and classes that have been preparsed\n    :type functions_and_classes: ```Optional[tuple[AST]]```\n    \"\"\"\n    parsed_ast = gen_module(\n        decorator_list,\n        emit_and_infer_imports,\n        emit_call,\n        emit_default_doc,\n        emit_name,\n        functions_and_classes,\n        imports,\n        input_mapping_it,\n        name_tpl,\n        no_word_wrap,\n        parse_name,\n        prepend,\n    )\n    assert (\n        len(parsed_ast.body) &gt; 1\n        or not isinstance(parsed_ast.body[0], Assign)\n        and any(\n            filter(\n                lambda target: isinstance(target, Name) and target.id == \"__all__\",\n                parsed_ast.body[0].targets,\n            )\n        )\n    ), \"Nothing will be append to {!r}\".format(output_filename)\n    with open(output_filename, \"a\") as f:\n        f.write(to_code(parsed_ast))\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.gen_module","title":"gen_module","text":"<pre><code>gen_module(decorator_list, emit_and_infer_imports, emit_call, emit_default_doc, emit_name, functions_and_classes, imports, input_mapping_it, name_tpl, no_word_wrap, parse_name, prepend, global__all__=None)\n</code></pre> <p>Generate Python module <code>input_mapping_it</code>.values converted to <code>emit_name</code></p> <p>Parameters:</p> Name Type Description Default <code>name_tpl</code> <code>str</code> <p>Template for the name, e.g., <code>{name}Config</code>.</p> required <code>input_mapping_it</code> <code>Iterator[tuple[str, AST]]</code> <p>Import location of mapping/2-tuple collection.</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                  \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to parse.</p> required <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>prepend</code> <code>Optional[str]</code> <p>Prepend file with this. Use ' ' for newlines.</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>emit_and_infer_imports</code> <code>bool</code> <p>Whether to emit and infer imports at the top of the generated code</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>imports</code> <code>Optional[str]</code> <p>Import to preclude in Python file</p> required <code>functions_and_classes</code> <code>Optional[Tuple[AST]]</code> <p>Functions and classes that have been preparsed</p> required <code>global__all__</code> <code>list[str]</code> <p><code>__all__</code> symbols for that magic</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Module with everything contained inside, e.g., all the imports, parsed out functions and classes</p> Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def gen_module(\n    decorator_list,\n    emit_and_infer_imports,\n    emit_call,\n    emit_default_doc,\n    emit_name,\n    functions_and_classes,\n    imports,\n    input_mapping_it,\n    name_tpl,\n    no_word_wrap,\n    parse_name,\n    prepend,\n    global__all__=None,\n):\n    \"\"\"\n    Generate Python module `input_mapping_it`.values converted to `emit_name`\n\n    :param name_tpl: Template for the name, e.g., `{name}Config`.\n    :type name_tpl: ```str```\n\n    :param input_mapping_it: Import location of mapping/2-tuple collection.\n    :type input_mapping_it: ```Iterator[tuple[str, AST]]```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param prepend: Prepend file with this. Use '\\n' for newlines.\n    :type prepend: ```Optional[str]```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param emit_and_infer_imports: Whether to emit and infer imports at the top of the generated code\n    :type emit_and_infer_imports: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param imports: Import to preclude in Python file\n    :type imports: ```Optional[str]```\n\n    :param functions_and_classes: Functions and classes that have been preparsed\n    :type functions_and_classes: ```Optional[Tuple[AST]]```\n\n    :param global__all__: `__all__` symbols for that magic\n    :type global__all__: ```list[str]```\n\n    :return: Module with everything contained inside, e.g., all the imports, parsed out functions and classes\n    :rtype: ```Module```\n    \"\"\"\n    if global__all__ is None:\n        global__all__ = []  # type: list[str]\n    if functions_and_classes is None:\n        functions_and_classes = get_functions_and_classes(\n            decorator_list,\n            emit_call,\n            emit_default_doc,\n            emit_name,\n            global__all__,\n            input_mapping_it,\n            name_tpl,\n            no_word_wrap,\n            parse_name,\n        )  # type: tuple[Union[FunctionDef, ClassDef]]\n    if emit_and_infer_imports:\n        imports: str = \"{}{}\".format(\n            imports or \"\",\n            \" \".join(\n                map(\n                    to_code,\n                    optimise_imports(chain(*map(infer_imports, functions_and_classes))),\n                )\n            ),\n        )\n\n    # Too many params! - Clean things up for debugging:\n    del (\n        decorator_list,\n        emit_call,\n        emit_default_doc,\n        emit_name,\n        input_mapping_it,\n        name_tpl,\n        no_word_wrap,\n        parse_name,\n    )\n\n    content: str = \"{prepend}{imports}\\n{functions_and_classes}\\n{__all__}\".format(\n        prepend=\"\" if prepend is None else prepend,\n        imports=imports,  # TODO: Optimize imports programmatically (akin to `autoflake --remove-all-unused-imports`)\n        functions_and_classes=\"\\n\\n\".join(map(to_code, functions_and_classes)),\n        __all__=to_code(\n            Assign(\n                targets=[Name(\"__all__\", Store(), lineno=None, col_offset=None)],\n                value=ast.parse(  # `TypeError: Type List cannot be instantiated; use list() instead`\n                    str(\n                        list(\n                            map(\n                                lambda s: s.rstrip(\"\\n\").strip(\"'\").strip('\"'),\n                                map(to_code, map(set_value, global__all__)),\n                            )\n                        )\n                    )\n                )\n                .body[0]\n                .value,\n                expr=None,\n                lineno=None,\n                **maybe_type_comment,\n            )\n        ),\n    )\n    parsed_ast: Module = ast.parse(content)\n    # TODO: Shebang line first, then docstring, then imports\n    doc_str: Optional[str] = ast.get_docstring(parsed_ast, clean=True)\n    whole = tuple(\n        map(\n            lambda node: (\n                (node, None) if isinstance(node, (Import, ImportFrom)) else (None, node)\n            ),\n            parsed_ast.body,\n        )\n    )\n    parsed_ast.body = list(\n        filter(\n            None,\n            chain.from_iterable(\n                (\n                    parsed_ast.body[:1] if doc_str else iter(()),\n                    sorted(\n                        map(itemgetter(0), whole),\n                        key=lambda import_from: getattr(import_from, \"module\", None)\n                        == \"__future__\",\n                        reverse=True,\n                    ),\n                    map(itemgetter(1), whole[1:] if doc_str else whole),\n                ),\n            ),\n        )\n    )\n    return parsed_ast\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.get_emit_kwarg","title":"get_emit_kwarg","text":"<pre><code>get_emit_kwarg(decorator_list, emit_call, emit_name, name_tpl, name)\n</code></pre> <p>Emit keyword arguments have different requirements dependent on emitter Determine correct one, and always include the name.</p> <p>Parameters:</p> Name Type Description Default <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                             \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>name_tpl</code> <code>str</code> <p>Template for the name, e.g., <code>{name}Config</code>.</p> required <code>name</code> <code>str</code> <p>Interpolates into <code>name_tpl</code></p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict``</code> <p>Dictionary of keyword arguments targeted the specialised emit function.</p> Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def get_emit_kwarg(decorator_list, emit_call, emit_name, name_tpl, name):\n    \"\"\"\n    Emit keyword arguments have different requirements dependent on emitter\n    Determine correct one, and always include the name.\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param name_tpl: Template for the name, e.g., `{name}Config`.\n    :type name_tpl: ```str```\n\n    :param name: Interpolates into `name_tpl`\n    :type name: ```str```\n\n    :return: Dictionary of keyword arguments targeted the specialised emit function.\n    :rtype: ```dict``\n    \"\"\"\n    return (\n        lambda _name: {\n            \"argparse_function\": {\"function_name\": _name},\n            \"class_\": {\n                \"class_name\": _name,\n                \"decorator_list\": decorator_list,\n                \"emit_call\": emit_call,\n            },\n            \"function\": {\n                \"function_name\": _name,\n            },\n            \"json_schema\": {\n                \"identifier\": _name,\n            },\n            \"sqlalchemy\": {\"table_name\": _name},\n            \"sqlalchemy_hybrid\": {\"table_name\": _name},\n            \"sqlalchemy_table\": {\"table_name\": _name},\n        }[emit_name]\n    )(None if name == \"infer\" else ensure_valid_identifier(name_tpl.format(name=name)))\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.get_functions_and_classes","title":"get_functions_and_classes","text":"<pre><code>get_functions_and_classes(decorator_list, emit_call, emit_default_doc, emit_name, global__all__, input_mapping_it, name_tpl, no_word_wrap, parse_name)\n</code></pre> <p>Emitted functions and/or classes</p> <p>Parameters:</p> Name Type Description Default <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>emit_call</code> <code>bool</code> <p>Whether to emit a <code>__call__</code> method from the <code>_internal</code> IR subdict</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                             \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>global__all__</code> <code>list[str]</code> <p><code>__all__</code> symbols for that magic</p> required <code>input_mapping_it</code> <code>Iterator[Tuple[str,AST]]</code> <p>Import location of mapping/2-tuple collection.</p> required <code>name_tpl</code> <code>str</code> <p>Template for the name, e.g., <code>{name}Config</code>.</p> required <code>no_word_wrap</code> <code>Optional[Literal[True]]</code> <p>Whether word-wrap is disabled (on emission).</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                              \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to parse.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[Union[FunctionDef, ClassDef]]</code> <p>Side-effect of appending <code>__all__</code>, this returns emitted values out of <code>input_mapping_it</code></p> Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def get_functions_and_classes(\n    decorator_list,\n    emit_call,\n    emit_default_doc,\n    emit_name,\n    global__all__,\n    input_mapping_it,\n    name_tpl,\n    no_word_wrap,\n    parse_name,\n):\n    \"\"\"\n    Emitted functions and/or classes\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param emit_call: Whether to emit a `__call__` method from the `_internal` IR subdict\n    :type emit_call: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n\n    :param global__all__: `__all__` symbols for that magic\n    :type global__all__: ```list[str]```\n\n    :param input_mapping_it: Import location of mapping/2-tuple collection.\n    :type input_mapping_it: ```Iterator[Tuple[str,AST]]```\n\n    :param name_tpl: Template for the name, e.g., `{name}Config`.\n    :type name_tpl: ```str```\n\n    :param no_word_wrap: Whether word-wrap is disabled (on emission).\n    :type no_word_wrap: ```Optional[Literal[True]]```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :return: Side-effect of appending `__all__`, this returns emitted values out of `input_mapping_it`\n    :rtype: ```tuple[Union[FunctionDef, ClassDef]]```\n    \"\"\"\n    emitter = get_emitter(emit_name)\n    return tuple(\n        print(\"\\nGenerating: {name!r}\".format(name=name))\n        or global__all__.append(name_tpl.format(name=name))\n        or emitter(\n            get_parser(obj, parse_name)(obj),\n            emit_default_doc=emit_default_doc,\n            word_wrap=no_word_wrap is None,\n            **get_emit_kwarg(decorator_list, emit_call, emit_name, name_tpl, name),\n        )\n        for name, obj in input_mapping_it\n    )\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.get_input_mapping_from_path","title":"get_input_mapping_from_path","text":"<pre><code>get_input_mapping_from_path(emit_name, module_path, symbol_name)\n</code></pre> <p>Given (module_path, symbol_name) acquire file path, <code>ast.parse</code> out all top-level symbols matching <code>emit_name</code></p> <p>Parameters:</p> Name Type Description Default <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                             \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to generate.</p> required <code>module_path</code> <code>str</code> <p>Module path</p> required <code>symbol_name</code> <code>str</code> <p>Symbol to import from module</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Dictionary of (name, AST) where AST is produced by a cdd emitter matching <code>emit_name</code></p> Source code in <code>cdd/compound/gen_utils.py</code> <pre><code>def get_input_mapping_from_path(emit_name, module_path, symbol_name):\n    \"\"\"\n    Given (module_path, symbol_name) acquire file path, `ast.parse` out all top-level symbols matching `emit_name`\n\n    :param emit_name: Which type to generate.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :param module_path: Module path\n    :type module_path: ```str```\n\n    :param symbol_name: Symbol to import from module\n    :type symbol_name: ```str```\n\n    :return: Dictionary of (name, AST) where AST is produced by a cdd emitter matching `emit_name`\n    :rtype: ```dict```\n    \"\"\"\n    module_filepath = find_module_filepath(module_path, symbol_name)\n    with open(module_filepath, \"rt\") as f:\n        input_ast_mod: Module = ast.parse(f.read())\n    type_instance_must_be = kind2instance_type.get(emit_name, (FunctionDef, ClassDef))\n    input_mapping = dict(\n        map(\n            lambda ir: (ir[\"name\"], ir),\n            map(\n                lambda node: get_parser(node, emit_name)(node),\n                filter(\n                    rpartial(\n                        isinstance,\n                        type_instance_must_be,\n                    ),\n                    input_ast_mod.body,\n                ),\n            ),\n        )\n    )\n    assert input_mapping, \"Nothing parsed out of {!r}\".format(module_filepath)\n    return input_mapping\n</code></pre>"},{"location":"api/#cdd.compound.gen_utils.get_parser","title":"get_parser","text":"<pre><code>get_parser(node, parse_name)\n</code></pre> <p>Get parser function specialised for input <code>node</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>Node to parse</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                              \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\",\"infer\"]</code> <p>Which type to parse.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Callable[[...], dict]`</code> <p>Function which returns intermediate_repr</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def get_parser(node, parse_name):\n    \"\"\"\n    Get parser function specialised for input `node`\n\n    :param node: Node to parse\n    :type node: ```AST```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\",\"infer\"]```\n\n    :return: Function which returns intermediate_repr\n    :rtype: ```Callable[[...], dict]````\n    \"\"\"\n    if parse_name in (None, \"infer\"):\n        parse_name: str = infer(node)\n    parse_name: str = {\n        \"class\": \"class_\",\n        \"sqlalchemy_hybrid\": \"sqlalchemy\",\n        \"sqlalchemy_table\": \"sqlalchemy\",\n    }.get(parse_name, parse_name)\n    return getattr(import_module(\".\".join((\"cdd\", parse_name, \"parse\"))), parse_name)\n</code></pre>"},{"location":"api/#cddcompoundopenapi","title":"<code>cdd.compound.openapi</code>","text":""},{"location":"api/#cdd.compound.openapi","title":"cdd.compound.openapi","text":"<p>Parsers and emitters for OpenAPI</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddcompoundopenapiemit","title":"<code>cdd.compound.openapi.emit</code>","text":""},{"location":"api/#cdd.compound.openapi.emit","title":"cdd.compound.openapi.emit","text":"<p>OpenAPI emitter function(s)</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.emit.openapi","title":"openapi","text":"<pre><code>openapi(name_model_route_id_cruds)\n</code></pre> <p>Emit OpenAPI dict</p> <p>Parameters:</p> Name Type Description Default <code>name_model_route_id_cruds</code> <code>Iterable[NameModelRouteIdCrud]</code> <p>Collection of (name, model, route, id, crud)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>OpenAPI dict</p> Source code in <code>cdd/compound/openapi/emit.py</code> <pre><code>def openapi(name_model_route_id_cruds):\n    \"\"\"\n    Emit OpenAPI dict\n\n    :param name_model_route_id_cruds: Collection of (name, model, route, id, crud)\n    :type name_model_route_id_cruds: ```Iterable[NameModelRouteIdCrud]```\n\n    :return: OpenAPI dict\n    :rtype: ```dict```\n    \"\"\"\n    paths, components = {}, {\n        \"requestBodies\": {},\n        \"schemas\": {\n            \"ServerError\": {\n                k: v for k, v in server_error_schema.items() if not k.startswith(\"$\")\n            }\n        },\n    }\n\n    deque(\n        map(\n            lambda name_model_route_id_crud: components_paths_from_name_model_route_id_crud(\n                components, paths, *name_model_route_id_crud\n            ),\n            name_model_route_id_cruds,\n        ),\n        maxlen=0,\n    )\n\n    return {\n        \"openapi\": \"3.0.0\",\n        \"info\": {\"version\": \"0.0.1\", \"title\": \"REST API\"},\n        # \"servers\": [{\"url\": \"https://example.io/v1\"}],\n        \"components\": components,\n        \"paths\": paths,\n    }\n</code></pre>"},{"location":"api/#cddcompoundopenapigen_openapi","title":"<code>cdd.compound.openapi.gen_openapi</code>","text":""},{"location":"api/#cdd.compound.openapi.gen_openapi","title":"cdd.compound.openapi.gen_openapi","text":"<p>All encompassing solution to generating the OpenAPI schema</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.gen_openapi.openapi_bulk","title":"openapi_bulk","text":"<pre><code>openapi_bulk(app_name, model_paths, routes_paths)\n</code></pre> <p>Generate OpenAPI from models, routes on app</p> <p>Parameters:</p> Name Type Description Default <code>app_name</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>model_paths</code> <code>list[str]</code> <p>The path/module-resolution(s) whence the model(s) can be found</p> required <code>routes_paths</code> <code>list[str]</code> <p>The path/module-resolution(s) whence the route(s) can be found</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>OpenAPI dictionary</p> Source code in <code>cdd/compound/openapi/gen_openapi.py</code> <pre><code>def openapi_bulk(app_name, model_paths, routes_paths):\n    \"\"\"\n    Generate OpenAPI from models, routes on app\n\n    :param app_name: Variable name (Bottle App)\n    :type app_name: ```str```\n\n    :param model_paths: The path/module-resolution(s) whence the model(s) can be found\n    :type model_paths: ```list[str]```\n\n    :param routes_paths: The path/module-resolution(s) whence the route(s) can be found\n    :type routes_paths: ```list[str]```\n\n    :return: OpenAPI dictionary\n    :rtype: ```dict```\n    \"\"\"\n    request_bodies: OpenAPI_requestBodies = {}\n\n    def parse_model(filename):\n        \"\"\"\n        :param filename: The filename to open and parse AST out of\n        :type filename: ```str```\n\n        :return: Iterable of tuples of the found kind\n        :rtype: ```Iterable[tuple[AST, ...], ...]```\n        \"\"\"\n        with open(filename, \"rb\") as f:\n            parsed_ast: Module = ast.parse(f.read())\n\n        return filter(\n            lambda node: (infer(node) or \"\").startswith(\"sqlalchemy\"),\n            filter(rpartial(isinstance, (Call, ClassDef)), ast.walk(parsed_ast)),\n        )\n\n    def parse_route(filename):\n        \"\"\"\n        :param filename: The filename to open and parse AST out of\n        :type filename: ```str```\n\n        :return: Iterable of tuples of the found kind\n        :rtype: ```Iterable[tuple[AST, ...], ...]```\n        \"\"\"\n        with open(filename, \"rb\") as f:\n            parsed_ast: Module = ast.parse(f.read())\n\n        return filter(\n            lambda node: next(\n                get_route_meta(Module(body=[node], type_ignores=[], stmt=None))\n            )[1]\n            == app_name,\n            filter(rpartial(isinstance, FunctionDef), parsed_ast.body),\n        )\n\n    def construct_parameters_and_request_bodies(route, path_dict):\n        \"\"\"\n        Construct `parameters` and `requestBodies`\n\n        :param route: Route path, like \"/api/foo\"\n        :type route: ```str```\n\n        :param path_dict: OpenAPI paths key\n        :type path_dict: ```dict```\n\n        :return: (route, path_dict) with `\"parameters\"` key potentially set\n        :rtype: ```tuple[str, dict]```\n        \"\"\"\n        if \":\" in route:\n            path_dict[\"parameters\"] = []\n            object_name: str = path_dict.get(\n                \"get\", path_dict.get(\"delete\", {\"summary\": \"`Object`\"})\n            )[\"summary\"]\n            fst: int = object_name.find(\"`\")\n            object_name: str = (\n                object_name[fst + 1 : object_name.find(\"`\", fst + 1)] or \"Object\"\n            )\n\n            route: str = \"/\".join(\n                map(\n                    lambda r: (\n                        (\n                            lambda pk: (\n                                path_dict[\"parameters\"].append(\n                                    {\n                                        \"description\": (\n                                            \"Primary key of target `{}`\".format(\n                                                object_name\n                                            )\n                                        ),\n                                        \"in\": \"path\",\n                                        \"name\": pk,\n                                        \"required\": True,\n                                        \"schema\": {\"type\": \"string\"},\n                                    }\n                                )\n                                or \"{{{}}}\".format(pk)\n                            )\n                        )(r[1:])\n                        if r.startswith(\":\")\n                        else r\n                    ),\n                    route.split(\"/\"),\n                )\n            )\n\n        request_bodies.update(\n            map(\n                lambda body_name: (\n                    body_name,\n                    (\n                        lambda key: {\n                            \"content\": {\n                                \"application/json\": {\n                                    \"schema\": {\n                                        \"$ref\": \"#/components/schemas/{key}\".format(\n                                            key=key\n                                        )\n                                    }\n                                }\n                            },\n                            \"description\": \"A `{key}` object.\".format(key=key),\n                            \"required\": True,\n                        }\n                    )(body_name.rpartition(\"Body\")[0]),\n                ),\n                map(\n                    lambda ref: ref.rpartition(\"/\")[2],\n                    map(\n                        itemgetter(\"$ref\"),\n                        filter(\n                            None,\n                            map(\n                                rpartial(dict.get, \"requestBody\"),\n                                filter(rpartial(isinstance, dict), path_dict.values()),\n                            ),\n                        ),\n                    ),\n                ),\n            )\n        )\n\n        return route, path_dict\n\n    return {\n        \"openapi\": \"3.0.0\",\n        \"info\": {\"version\": \"0.0.1\", \"title\": \"REST API\"},\n        # \"servers\": [{\"url\": \"https://example.io/v1\"}],\n        \"components\": {\n            \"requestBodies\": request_bodies,\n            \"schemas\": {\n                key: {k: v for k, v in val.items() if not k.startswith(\"$\")}\n                for key, val in dict(\n                    map(\n                        lambda table: (\n                            table[\"name\"].replace(\"_tbl\", \"\", 1).title(),\n                            cdd.json_schema.emit.json_schema(table),\n                        ),\n                        map(\n                            lambda node: (\n                                cdd.sqlalchemy.parse.sqlalchemy_table(node)\n                                if isinstance(node, (AnnAssign, Assign, Call))\n                                else cdd.sqlalchemy.parse.sqlalchemy(node)\n                            ),\n                            chain.from_iterable(map(parse_model, model_paths)),\n                        ),\n                    ),\n                    ServerError=server_error_schema,\n                ).items()\n            },\n        },\n        \"paths\": dict(\n            map(\n                lambda k_v: construct_parameters_and_request_bodies(\n                    k_v[0], update_d(*map(itemgetter(1), k_v[1]))\n                ),\n                groupby(\n                    map(\n                        lambda route: (\n                            get_value(route.decorator_list[0].args[0]),\n                            {\n                                route.decorator_list[\n                                    0\n                                ].func.attr: cdd.routes.parse.bottle.bottle(route)\n                            },\n                        ),\n                        chain.from_iterable(map(parse_route, routes_paths)),\n                    ),\n                    key=itemgetter(0),\n                ),\n            )\n        ),\n    }\n</code></pre>"},{"location":"api/#cddcompoundopenapigen_routes","title":"<code>cdd.compound.openapi.gen_routes</code>","text":""},{"location":"api/#cdd.compound.openapi.gen_routes","title":"cdd.compound.openapi.gen_routes","text":"<p>Generate routes</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.gen_routes.gen_routes","title":"gen_routes","text":"<pre><code>gen_routes(app, model_path, model_name, crud, route)\n</code></pre> <p>Generate route(s)</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>model_path</code> <code>str</code> <p>The path/module-resolution whence the model is</p> required <code>model_name</code> <code>str</code> <p>Name of the model to recover from the <code>model_path</code></p> required <code>crud</code> <code>Union[Literal['C', 'R'], Literal['C', 'U'], Literal['C', 'D'], Literal['R', 'C'],                      Literal['R', 'U'], Literal['R', 'D'], Literal['U', 'C'], Literal['U', 'R'],                      Literal['U', 'D'], Literal['D', 'C'], Literal['D', 'R'], Literal['D', 'U'],                      Literal['C', 'R', 'U'], Literal['C', 'R', 'D'], Literal['C', 'U', 'R'],                      Literal['C', 'U', 'D'], Literal['C', 'D', 'R'], Literal['C', 'D', 'U'],                      Literal['R', 'C', 'U'], Literal['R', 'C', 'D'], Literal['R', 'U', 'C'],                      Literal['R', 'U', 'D'], Literal['R', 'D', 'C'], Literal['R', 'D', 'U'],                      Literal['U', 'C', 'R'], Literal['U', 'C', 'D'], Literal['U', 'R', 'C'],                      Literal['U', 'R', 'D'], Literal['U', 'D', 'C'], Literal['U', 'D', 'R'],                      Literal['D', 'C', 'R'], Literal['D', 'C', 'U'], Literal['D', 'R', 'C'],                      Literal['D', 'R', 'U'], Literal['D', 'U', 'C'], Literal['D', 'U', 'R']]</code> <p>(C)reate (R)ead (U)pdate (D)elete, like \"CRUD\" for all or \"CD\" for \"Create\" and \"Delete\"</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterator[FunctionDef]</code> <p>Iterator of functions representing relevant CRUD operations</p> Source code in <code>cdd/compound/openapi/gen_routes.py</code> <pre><code>def gen_routes(app, model_path, model_name, crud, route):\n    \"\"\"\n    Generate route(s)\n\n    :param app: Variable name (Bottle App)\n    :type app: ```str```\n\n    :param model_path: The path/module-resolution whence the model is\n    :type model_path: ```str```\n\n    :param model_name: Name of the model to recover from the `model_path`\n    :type model_name: ```str```\n\n    :param crud: (C)reate (R)ead (U)pdate (D)elete, like \"CRUD\" for all or \"CD\" for \"Create\" and \"Delete\"\n    :type crud: ```Union[Literal['C', 'R'], Literal['C', 'U'], Literal['C', 'D'], Literal['R', 'C'],\n                         Literal['R', 'U'], Literal['R', 'D'], Literal['U', 'C'], Literal['U', 'R'],\n                         Literal['U', 'D'], Literal['D', 'C'], Literal['D', 'R'], Literal['D', 'U'],\n                         Literal['C', 'R', 'U'], Literal['C', 'R', 'D'], Literal['C', 'U', 'R'],\n                         Literal['C', 'U', 'D'], Literal['C', 'D', 'R'], Literal['C', 'D', 'U'],\n                         Literal['R', 'C', 'U'], Literal['R', 'C', 'D'], Literal['R', 'U', 'C'],\n                         Literal['R', 'U', 'D'], Literal['R', 'D', 'C'], Literal['R', 'D', 'U'],\n                         Literal['U', 'C', 'R'], Literal['U', 'C', 'D'], Literal['U', 'R', 'C'],\n                         Literal['U', 'R', 'D'], Literal['U', 'D', 'C'], Literal['U', 'D', 'R'],\n                         Literal['D', 'C', 'R'], Literal['D', 'C', 'U'], Literal['D', 'R', 'C'],\n                         Literal['D', 'R', 'U'], Literal['D', 'U', 'C'], Literal['D', 'U', 'R']]```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :return: Iterator of functions representing relevant CRUD operations\n    :rtype: ```Iterator[FunctionDef]```\n    \"\"\"\n    model_path: str = filename_from_mod_or_filename(model_path)\n\n    assert path.isfile(model_path)\n    with open(model_path, \"rt\") as f:\n        mod: Module = ast.parse(f.read())\n\n    sqlalchemy_node: Optional[ClassDef] = next(\n        filter(\n            lambda node: isinstance(node, ClassDef)\n            and (\n                node.name == model_name\n                or isinstance(node.name, Name)\n                and node.name.id == model_name\n            ),\n            ast.walk(mod),\n        ),\n        None,\n    )\n    sqlalchemy_ir: IntermediateRepr = cdd.sqlalchemy.parse.sqlalchemy(\n        Module(body=[sqlalchemy_node], stmt=None, type_ignores=[])\n    )\n    primary_key: str = next(\n        map(\n            itemgetter(0),\n            filter(\n                lambda param: param[1][\"doc\"].startswith(\"[PK]\"),\n                sqlalchemy_ir[\"params\"].items(),\n            ),\n        ),\n        next(iter(sqlalchemy_ir[\"params\"].keys())),\n    )\n    _route_config: dict[str, Union[str, int]] = {\n        \"app\": app,\n        \"name\": model_name,\n        \"route\": route,\n        \"variant\": -1,\n    }\n    routes: List[str] = []\n    if \"C\" in crud:\n        routes.append(cdd.routes.emit.bottle.create(**_route_config))\n    _route_config[\"primary_key\"] = primary_key\n\n    funcs: dict[str, Optional[Callable[[str, str, str, Any, int], str]]] = {\n        \"R\": cdd.routes.emit.bottle.read,\n        \"U\": None,\n        \"D\": cdd.routes.emit.bottle.destroy,\n    }\n    routes.extend(funcs[key](**_route_config) for key in funcs if key in crud)\n    return (\n        map(itemgetter(0), map(attrgetter(\"body\"), map(ast.parse, routes))),\n        primary_key,\n    )\n</code></pre>"},{"location":"api/#cdd.compound.openapi.gen_routes.upsert_routes","title":"upsert_routes","text":"<pre><code>upsert_routes(app, routes, routes_path, route, primary_key)\n</code></pre> <p>Upsert the <code>routes</code> to the <code>routes_path</code>, on merge use existing body and replace interface/prototype</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>routes</code> <code>Iterator[FunctionDef]</code> <p>Iterator of functions representing relevant CRUD operations</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <code>primary_key</code> <code>str</code> <p>The primary key or id to lookup on for the route</p> required <code>routes_path</code> <code>str</code> <p>The path/module-resolution whence the routes are / will be</p> required Source code in <code>cdd/compound/openapi/gen_routes.py</code> <pre><code>def upsert_routes(app, routes, routes_path, route, primary_key):\n    \"\"\"\n    Upsert the `routes` to the `routes_path`, on merge use existing body and replace interface/prototype\n\n    :param app: Variable name (Bottle App)\n    :type app: ```str```\n\n    :param routes: Iterator of functions representing relevant CRUD operations\n    :type routes: ```Iterator[FunctionDef]```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :param primary_key: The primary key or id to lookup on for the route\n    :type primary_key: ```str```\n\n    :param routes_path: The path/module-resolution whence the routes are / will be\n    :type routes_path: ```str```\n    \"\"\"\n    routes_path: str = filename_from_mod_or_filename(routes_path)\n\n    if not path.isfile(routes_path):\n        with open(routes_path, \"wt\") as f:\n            f.write(\n                \"\\n\\n\".join(\n                    chain.from_iterable(\n                        (\n                            (\n                                route_prelude.replace(\n                                    \"rest_api =\", \"{app} =\".format(app=app)\n                                ),\n                            ),\n                            map(to_code, routes),\n                        )\n                    )\n                )\n            )\n        return\n\n    with open(routes_path, \"rt\") as f:\n        mod: Module = ast.parse(f.read())\n\n    def get_names(functions):\n        \"\"\"\n        Derive a method_name -&gt; FunctionDef dictionary\n\n        :param functions: Routing functions\n        :type functions: ```Iterator[FunctionDef]```\n\n        :return: Dict of `method_name` to `FunctionDef`\n        :rtype: ```Dict[str, FunctionDef]```\n        \"\"\"\n        return dict(\n            map(\n                lambda func: (\n                    next(\n                        map(\n                            lambda call: call.func.attr,\n                            filter(\n                                lambda call: all(\n                                    (\n                                        isinstance(call.func, Attribute),\n                                        call.func.attr in methods,\n                                    )\n                                ),\n                                filter(rpartial(isinstance, Call), func.decorator_list),\n                            ),\n                        )\n                    ),\n                    func,\n                ),\n                functions,\n            )\n        )\n\n    routes_required: Dict[str, FunctionDef] = get_names(routes)\n    routes_existing: Dict[str, FunctionDef] = get_names(\n        filter(\n            lambda node: any(\n                filter(\n                    lambda call: all(\n                        (\n                            isinstance(call.func, Attribute),\n                            call.func.attr in methods,\n                            get_value(call.args[0])\n                            == \"{route}{rest}\".format(\n                                route=route,\n                                rest=(\n                                    \"\"\n                                    if call.func.attr == \"post\"\n                                    else \"/:{primary_key}\".format(\n                                        primary_key=primary_key\n                                    )\n                                ),\n                            ),\n                            call.func.value.id == app,\n                        )\n                    ),\n                    filter(rpartial(isinstance, Call), node.decorator_list),\n                )\n            ),\n            filter(rpartial(isinstance, FunctionDef), ast.walk(mod)),\n        )\n    )\n    missing_routes = (\n        routes_required.keys() &amp; routes_existing.keys() ^ routes_required.keys()\n    )  # type: dict_keys[str, str]\n\n    if not missing_routes:\n        return\n\n    with open(routes_path, \"a\") as f:\n        f.write(\n            \"\\n\\n\".join(\n                map(\n                    to_code,\n                    map(\n                        routes_required.__getitem__,\n                        sorted(\n                            missing_routes,\n                            key={\n                                \"post\": 0,\n                                \"get\": 1,\n                                \"update\": 2,\n                                \"delete\": 3,\n                            }.__getitem__,\n                        ),\n                    ),\n                )\n            )\n        )\n</code></pre>"},{"location":"api/#cddcompoundopenapiparse","title":"<code>cdd.compound.openapi.parse</code>","text":""},{"location":"api/#cdd.compound.openapi.parse","title":"cdd.compound.openapi.parse","text":"<p>OpenAPI parsers</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.parse.openapi","title":"openapi","text":"<pre><code>openapi(openapi_str, routes_dict, summary)\n</code></pre> <p>OpenAPI parser</p> <p>Parameters:</p> Name Type Description Default <code>openapi_str</code> <code>str</code> <p>The OpenAPI str</p> required <code>routes_dict</code> <code>dict</code> <p>Has keys (\"route\", \"name\", \"method\")</p> required <code>summary</code> <code>str</code> <p>summary string (used as fallback)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>OpenAPI dictionary</p> Source code in <code>cdd/compound/openapi/parse.py</code> <pre><code>def openapi(openapi_str, routes_dict, summary):\n    \"\"\"\n    OpenAPI parser\n\n    :param openapi_str: The OpenAPI str\n    :type openapi_str: ```str```\n\n    :param routes_dict: Has keys (\"route\", \"name\", \"method\")\n    :type routes_dict: ```dict```\n\n    :param summary: summary string (used as fallback)\n    :type summary: ```str```\n\n    :return: OpenAPI dictionary\n    \"\"\"\n    entities: List[str] = extract_entities(openapi_str)\n\n    non_error_entity: Optional[str] = None\n\n    for entity in entities:\n        openapi_str: str = openapi_str.replace(\n            \"$ref: ```{entity}```\".format(entity=entity),\n            \"{{'$ref': '#/components/schemas/{entity}'}}\".format(entity=entity),\n        )\n        if entity != \"ServerError\":\n            non_error_entity: str = entity\n    openapi_d: dict = (loads if openapi_str.startswith(\"{\") else safe_load)(openapi_str)\n    if non_error_entity is not None:\n        openapi_d[\"summary\"] = \"{located} `{entity}` object.\".format(\n            located=\"A\", entity=non_error_entity\n        )\n        if routes_dict[\"method\"] in frozenset((\"post\", \"patch\")):\n            openapi_d[\"requestBody\"] = {\n                \"$ref\": \"#/components/requestBodies/{entity}Body\".format(\n                    entity=non_error_entity\n                ),\n                \"required\": True,\n            }\n    else:\n        openapi_d[\"summary\"] = summary\n    if \"responses\" in openapi_d:\n        openapi_d[\"responses\"] = {k: v or {} for k, v in openapi_d[\"responses\"].items()}\n    return openapi_d\n</code></pre>"},{"location":"api/#cddcompoundopenapiutils","title":"<code>cdd.compound.openapi.utils</code>","text":""},{"location":"api/#cdd.compound.openapi.utils","title":"cdd.compound.openapi.utils","text":"<p>OpenAPI parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddcompoundopenapiutilsemit_openapi_utils","title":"<code>cdd.compound.openapi.utils.emit_openapi_utils</code>","text":""},{"location":"api/#cdd.compound.openapi.utils.emit_openapi_utils","title":"cdd.compound.openapi.utils.emit_openapi_utils","text":"<p>Utility functions for <code>cdd.emit.openapi</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.utils.emit_openapi_utils.components_paths_from_name_model_route_id_crud","title":"components_paths_from_name_model_route_id_crud","text":"<pre><code>components_paths_from_name_model_route_id_crud(components, paths, name, model, route, _id, crud)\n</code></pre> <p>Update <code>components</code> and <code>paths</code> from <code>(name, model, route, _id, crud)</code></p> <p>Parameters:</p> Name Type Description Default <code>components</code> <code>dict</code> <p>OpenAPI components (updated by this function)</p> required <code>paths</code> <code>dict</code> <p>OpenAPI paths (updated by this function)</p> required <code>name</code> <code>str</code> <p>Name of the entity</p> required <code>model</code> <code>dict</code> <p>Schema of entity</p> required <code>route</code> <code>str</code> <p>API path</p> required <code>_id</code> <code>str</code> <p>Primary key to access identity by id</p> required <code>crud</code> <code>Union[Literal['C', 'R'], Literal['C', 'U'], Literal['C', 'D'], Literal['R', 'C'],                      Literal['R', 'U'], Literal['R', 'D'], Literal['U', 'C'], Literal['U', 'R'],                      Literal['U', 'D'], Literal['D', 'C'], Literal['D', 'R'], Literal['D', 'U'],                      Literal['C', 'R', 'U'], Literal['C', 'R', 'D'], Literal['C', 'U', 'R'],                      Literal['C', 'U', 'D'], Literal['C', 'D', 'R'], Literal['C', 'D', 'U'],                      Literal['R', 'C', 'U'], Literal['R', 'C', 'D'], Literal['R', 'U', 'C'],                      Literal['R', 'U', 'D'], Literal['R', 'D', 'C'], Literal['R', 'D', 'U'],                      Literal['U', 'C', 'R'], Literal['U', 'C', 'D'], Literal['U', 'R', 'C'],                      Literal['U', 'R', 'D'], Literal['U', 'D', 'C'], Literal['U', 'D', 'R'],                      Literal['D', 'C', 'R'], Literal['D', 'C', 'U'], Literal['D', 'R', 'C'],                      Literal['D', 'R', 'U'], Literal['D', 'U', 'C'], Literal['D', 'U', 'R']]</code> <p>(C)reate (R)ead (U)pdate (D)elete, like \"CRUD\" for all or \"CD\" for \"Create\" and \"Delete\"</p> required Source code in <code>cdd/compound/openapi/utils/emit_openapi_utils.py</code> <pre><code>def components_paths_from_name_model_route_id_crud(\n    components, paths, name, model, route, _id, crud\n):\n    \"\"\"\n    Update `components` and `paths` from `(name, model, route, _id, crud)`\n\n    :param components: OpenAPI components (updated by this function)\n    :type components: ```dict```\n\n    :param paths: OpenAPI paths (updated by this function)\n    :type paths: ```dict```\n\n    :param name: Name of the entity\n    :type name: ```str```\n\n    :param model: Schema of entity\n    :type model: ```dict```\n\n    :param route: API path\n    :type route: ```str```\n\n    :param _id: Primary key to access identity by id\n    :type _id: ```str```\n\n    :param crud: (C)reate (R)ead (U)pdate (D)elete, like \"CRUD\" for all or \"CD\" for \"Create\" and \"Delete\"\n    :type crud: ```Union[Literal['C', 'R'], Literal['C', 'U'], Literal['C', 'D'], Literal['R', 'C'],\n                         Literal['R', 'U'], Literal['R', 'D'], Literal['U', 'C'], Literal['U', 'R'],\n                         Literal['U', 'D'], Literal['D', 'C'], Literal['D', 'R'], Literal['D', 'U'],\n                         Literal['C', 'R', 'U'], Literal['C', 'R', 'D'], Literal['C', 'U', 'R'],\n                         Literal['C', 'U', 'D'], Literal['C', 'D', 'R'], Literal['C', 'D', 'U'],\n                         Literal['R', 'C', 'U'], Literal['R', 'C', 'D'], Literal['R', 'U', 'C'],\n                         Literal['R', 'U', 'D'], Literal['R', 'D', 'C'], Literal['R', 'D', 'U'],\n                         Literal['U', 'C', 'R'], Literal['U', 'C', 'D'], Literal['U', 'R', 'C'],\n                         Literal['U', 'R', 'D'], Literal['U', 'D', 'C'], Literal['U', 'D', 'R'],\n                         Literal['D', 'C', 'R'], Literal['D', 'C', 'U'], Literal['D', 'R', 'C'],\n                         Literal['D', 'R', 'U'], Literal['D', 'U', 'C'], Literal['D', 'U', 'R']]```\n    \"\"\"\n    _request_body: bool = False\n    if \"C\" in crud:\n        paths[route] = {\n            \"post\": {\n                \"summary\": \"A `{name}` object.\".format(name=name),\n                \"requestBody\": {\n                    \"required\": True,\n                    \"$ref\": \"#/components/requestBodies/{name}Body\".format(name=name),\n                },\n                \"responses\": {\n                    \"201\": {\n                        \"description\": \"A `{name}` object.\".format(name=name),\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/{name}\".format(\n                                        name=name\n                                    )\n                                }\n                            }\n                        },\n                    },\n                    \"400\": {\n                        \"description\": \"A `ServerError` object.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/ServerError\"}\n                            }\n                        },\n                    },\n                },\n            }\n        }\n        _request_body: bool = True\n    if not frozenset(crud) - frozenset(\"CRUD\"):\n        _route: str = \"{route}/{{{id}}}\".format(route=route, id=_id)\n        paths[_route] = {\n            \"parameters\": [\n                {\n                    \"name\": _id,\n                    \"in\": \"path\",\n                    \"description\": \"Primary key of target `{name}`\".format(name=name),\n                    \"required\": True,\n                    \"schema\": {\"type\": \"string\"},\n                }\n            ]\n        }\n        if \"R\" in crud:\n            paths[_route][\"get\"] = {\n                \"summary\": \"A `{name}` object.\".format(name=name),\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A `{name}` object.\".format(name=name),\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\n                                    \"$ref\": \"#/components/schemas/{name}\".format(\n                                        name=name\n                                    )\n                                }\n                            }\n                        },\n                    },\n                    \"404\": {\n                        \"description\": \"A `ServerError` object.\",\n                        \"content\": {\n                            \"application/json\": {\n                                \"schema\": {\"$ref\": \"#/components/schemas/ServerError\"}\n                            }\n                        },\n                    },\n                },\n            }\n\n        # if \"U\" in crud:\n        #     _request_body = True\n        #     raise NotImplementedError(\n        #         \"UPDATE: https://github.com/sqlalchemy/sqlalchemy/discussions/5940\"\n        #     )\n\n        if \"D\" in crud:\n            paths[_route][\"delete\"] = {\n                \"summary\": \"Delete one `{name}`\".format(name=name),\n                \"responses\": {\"204\": {}},\n            }\n    components[\"schemas\"][name] = {\n        k: v for k, v in model.items() if not k.startswith(\"$\")\n    }\n    if _request_body:\n        components[\"requestBodies\"][\"{name}Body\".format(name=name)] = {\n            \"description\": \"A `{name}` object.\".format(name=name),\n            \"required\": True,\n            \"content\": {\n                \"application/json\": {\n                    \"schema\": {\"$ref\": \"#/components/schemas/{name}\".format(name=name)}\n                }\n            },\n        }\n</code></pre>"},{"location":"api/#cddcompoundopenapiutilsemit_utils","title":"<code>cdd.compound.openapi.utils.emit_utils</code>","text":""},{"location":"api/#cdd.compound.openapi.utils.emit_utils","title":"cdd.compound.openapi.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.sqlalchemy</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddcompoundopenapiutilsparse_utils","title":"<code>cdd.compound.openapi.utils.parse_utils</code>","text":""},{"location":"api/#cdd.compound.openapi.utils.parse_utils","title":"cdd.compound.openapi.utils.parse_utils","text":"<p>Utility functions for <code>cdd.parse.openapi</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.openapi.utils.parse_utils.extract_entities","title":"extract_entities","text":"<pre><code>extract_entities(openapi_str)\n</code></pre> <p>Extract entities from an OpenAPI string, where entities are defines as anything within \"```\"</p> <p>Parameters:</p> Name Type Description Default <code>openapi_str</code> <code>str</code> <p>The OpenAPI str</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[str]</code> <p>Entities</p> Source code in <code>cdd/compound/openapi/utils/parse_utils.py</code> <pre><code>def extract_entities(openapi_str):\n    \"\"\"\n    Extract entities from an OpenAPI string, where entities are defines as anything within \"```\"\n\n    :param openapi_str: The OpenAPI str\n    :type openapi_str: ```str```\n\n    :return: Entities\n    :rtype: ```list[str]```\n    \"\"\"\n    entities, ticks, space, stack = [], 0, 0, []\n\n    def add_then_clear_stack():\n        \"\"\"\n        Join entity, if non-empty add to entities. Clear stack.\n        \"\"\"\n        entity: str = \"\".join(stack)\n        if entity:\n            entities.append(entity)\n        stack.clear()\n\n    for idx, ch in enumerate(openapi_str):\n        if ch.isspace():\n            space += 1\n            add_then_clear_stack()\n            ticks: int = 0\n        elif ticks &gt; 2:\n            ticks, space = 0, 0\n            stack and add_then_clear_stack()\n            stack.append(ch)\n        elif ch == \"`\":\n            ticks += 1\n        elif stack:\n            stack.append(ch)\n    add_then_clear_stack()\n    return entities\n</code></pre>"},{"location":"api/#cddcompoundsync_properties","title":"<code>cdd.compound.sync_properties</code>","text":""},{"location":"api/#cdd.compound.sync_properties","title":"cdd.compound.sync_properties","text":"<p>Functionality to synchronise properties</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.compound.sync_properties.sync_properties","title":"sync_properties","text":"<pre><code>sync_properties(input_eval, input_filename, input_params, output_filename, output_params, output_param_wrap=None)\n</code></pre> <p>Sync one property, inline to a file</p> <p>Parameters:</p> Name Type Description Default <code>input_eval</code> <code>bool</code> <p>Whether to evaluate the <code>param</code>, or just leave it</p> required <code>input_filename</code> <code>str</code> <p>Filename to find <code>param</code> from</p> required <code>input_params</code> <code>list[str]</code> <p>Locations within file of properties. Can be top level like <code>['a']</code> for <code>a=5</code> or with the <code>.</code> syntax as in <code>output_params</code>.</p> required <code>output_filename</code> <code>str</code> <p>Filename that will be edited in place, the property within this file (to update) is selected by <code>output_param</code></p> required <code>output_params</code> <code>list[str]</code> <p>Parameters to update. E.g., <code>['A.F']</code> for <code>class A: F = None</code>, <code>['f.g']</code> for <code>def f(g): pass</code></p> required <code>output_param_wrap</code> <p><code>Optional[str]</code></p> required Source code in <code>cdd/compound/sync_properties.py</code> <pre><code>def sync_properties(\n    input_eval,\n    input_filename,\n    input_params,\n    output_filename,\n    output_params,\n    output_param_wrap=None,\n):\n    \"\"\"\n    Sync one property, inline to a file\n\n    :param input_eval: Whether to evaluate the `param`, or just leave it\n    :type input_eval: ```bool```\n\n    :param input_filename: Filename to find `param` from\n    :type input_filename: ```str```\n\n    :param input_params: Locations within file of properties.\n       Can be top level like `['a']` for `a=5` or with the `.` syntax as in `output_params`.\n    :type input_params: ```list[str]```\n\n    :param output_filename: Filename that will be edited in place, the property within this file (to update)\n     is selected by `output_param`\n    :type output_filename: ```str```\n\n    :param output_params: Parameters to update. E.g., `['A.F']` for `class A: F = None`, `['f.g']` for `def f(g): pass`\n    :type output_params: ```list[str]```\n\n    :param output_param_wrap: Wrap all input_str params with this. E.g., `Optional[Union[{output_param}, str]]`\n    :param output_param_wrap: ```Optional[str]```\n    \"\"\"\n    with open(path.realpath(path.expanduser(input_filename)), \"rt\") as f:\n        input_ast = ast_parse(f.read(), filename=input_filename)\n\n    with open(path.realpath(path.expanduser(output_filename)), \"rt\") as f:\n        output_ast = ast_parse(f.read(), filename=output_filename)\n\n    assert len(input_params) == len(output_params)\n    for input_param, output_param in zip(input_params, output_params):\n        output_ast = sync_property(\n            input_eval,\n            input_param,\n            input_ast,\n            input_filename,\n            output_param,\n            output_param_wrap,\n            output_ast,\n        )\n\n    cdd.shared.emit.file.file(output_ast, output_filename, mode=\"wt\", skip_black=False)\n</code></pre>"},{"location":"api/#cdd.compound.sync_properties.sync_property","title":"sync_property","text":"<pre><code>sync_property(input_eval, input_param, input_ast, input_filename, output_param, output_param_wrap, output_ast)\n</code></pre> <p>Sync a single property</p> <p>Parameters:</p> Name Type Description Default <code>input_eval</code> <code>bool</code> <p>Whether to evaluate the <code>param</code>, or just leave it</p> required <code>input_param</code> <code>list[str]</code> <p>Location within file of property. Can be top level like <code>'a'</code> for <code>a=5</code> or with the <code>.</code> syntax as in <code>output_params</code>.</p> required <code>input_ast</code> <code>AST</code> <p>AST of the input file</p> required <code>input_filename</code> <code>str</code> <p>Filename of the input (used in <code>eval</code>)</p> required <code>output_param</code> <code>str</code> <p>Parameters to update. E.g., <code>'A.F'</code> for <code>class A: F = None</code>, <code>'f.g'</code> for <code>def f(g): pass</code></p> required <code>output_param_wrap</code> <p><code>Optional[str]</code></p> required <code>output_ast</code> <code>AST</code> <p>AST of the input file</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>New AST derived from <code>output_ast</code></p> Source code in <code>cdd/compound/sync_properties.py</code> <pre><code>def sync_property(\n    input_eval,\n    input_param,\n    input_ast,\n    input_filename,\n    output_param,\n    output_param_wrap,\n    output_ast,\n):\n    \"\"\"\n    Sync a single property\n\n    :param input_eval: Whether to evaluate the `param`, or just leave it\n    :type input_eval: ```bool```\n\n    :param input_param: Location within file of property.\n       Can be top level like `'a'` for `a=5` or with the `.` syntax as in `output_params`.\n    :type input_param: ```list[str]```\n\n    :param input_ast: AST of the input file\n    :type input_ast: ```AST```\n\n    :param input_filename: Filename of the input (used in `eval`)\n    :type input_filename: ```str```\n\n    :param output_param: Parameters to update. E.g., `'A.F'` for `class A: F = None`, `'f.g'` for `def f(g): pass`\n    :type output_param: ```str```\n\n    :param output_param_wrap: Wrap all input_str params with this. E.g., `Optional[Union[{output_param}, str]]`\n    :param output_param_wrap: ```Optional[str]```\n\n    :param output_ast: AST of the input file\n    :type output_ast: ```AST```\n\n    :return: New AST derived from `output_ast`\n    :rtype: ```AST```\n    \"\"\"\n    search: List[str] = list(strip_split(output_param, \".\"))\n    if input_eval:\n        if input_param.count(\".\") != 0:\n            raise NotImplementedError(\"Anything not on the top-level of the module\")\n\n        local = {}\n        output = eval(compile(input_ast, filename=input_filename, mode=\"exec\"), local)\n        assert output is None\n        replacement_node = ast.AnnAssign(\n            annotation=it2literal(local[input_param]),\n            simple=1,\n            target=ast.Name(\n                # input_param\n                search[-1],\n                ast.Store(),\n            ),\n            value=None,\n            expr=None,\n            expr_annotation=None,\n            expr_target=None,\n            col_offset=None,\n            lineno=None,\n        )\n    else:\n        assert isinstance(\n            input_ast, ast.Module\n        ), \"Expected `Module` got `{type_name}`\".format(\n            type_name=type(input_ast).__name__\n        )\n        annotate_ancestry(input_ast)\n        replacement_node = find_in_ast(list(strip_split(input_param, \".\")), input_ast)\n\n    assert replacement_node is not None\n    if output_param_wrap is not None:\n        if hasattr(replacement_node, \"annotation\"):\n            if replacement_node.annotation is not None:\n                replacement_node.annotation = (\n                    ast.parse(\n                        output_param_wrap.format(\n                            output_param=to_code(replacement_node.annotation)\n                        )\n                    )\n                    .body[0]\n                    .value\n                )\n        else:\n            raise NotImplementedError(type(replacement_node).__name__)\n\n    rewrite_at_query: RewriteAtQuery = RewriteAtQuery(\n        search=search,\n        replacement_node=replacement_node,\n    )\n\n    gen_ast = rewrite_at_query.visit(output_ast)\n\n    assert (\n        rewrite_at_query.replaced is True\n    ), \"Failed to update with {replacement_node_str!r}\".format(\n        replacement_node_str=to_code(replacement_node)\n    )\n    return gen_ast\n</code></pre>"},{"location":"api/#cdddocstring","title":"<code>cdd.docstring</code>","text":""},{"location":"api/#cdd.docstring","title":"cdd.docstring","text":"<p>docstring parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdddocstringemit","title":"<code>cdd.docstring.emit</code>","text":""},{"location":"api/#cdd.docstring.emit","title":"cdd.docstring.emit","text":"<p>Docstring emitter.</p> <p>Emits into these formats from the cdd_python common IR format:  - ReST docstring format (Sphinx)  - numpydoc docstring format  - Google's docstring format</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.docstring.emit.docstring","title":"docstring","text":"<pre><code>docstring(intermediate_repr, docstring_format='rest', purpose='function', word_wrap=True, indent_level=0, emit_separating_tab=True, emit_types=True, emit_original_whitespace=False, emit_default_doc=True)\n</code></pre> <p>Converts an IR to a docstring</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>purpose</code> <code>Literal['class', 'function']</code> required <code>if purpose == 'function' elif purpose == 'class' then </code> <p>:param<code>if purpose == 'function' elif purpose == 'class' then</code></p> required <code>:cvar`</code> <p>:cvar`</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>indent_level</code> <code>int</code> <p>indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs</p> required <code>emit_separating_tab</code> <code>bool</code> required <code>and return and desc</code> <p>:param and return and desc</p> required <code>emit_types</code> <code>bool</code> required <code>lines</code> <code>:type` lines</code> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit original whitespace or strip it out</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>docstring</p> Source code in <code>cdd/docstring/emit.py</code> <pre><code>def docstring(\n    intermediate_repr,\n    docstring_format=\"rest\",\n    purpose=\"function\",\n    word_wrap=True,\n    indent_level=0,\n    emit_separating_tab=True,\n    emit_types=True,\n    emit_original_whitespace=False,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Converts an IR to a docstring\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param purpose: Emit `:param` if purpose == 'function' elif purpose == 'class' then `:cvar`\n    :type purpose: ```Literal['class', 'function']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param indent_level: indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs\n    :type indent_level: ```int```\n\n    :param emit_separating_tab: Whether to put a tab between :param and return and desc\n    :type emit_separating_tab: ```bool```\n\n    :param emit_types: Whether to show `:type` lines\n    :type emit_types: ```bool```\n\n    :param emit_original_whitespace: Whether to emit original whitespace or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: docstring\n    :rtype: ```str```\n    \"\"\"\n    # _sep = tab * indent_level\n    params = \"\\n{maybe_nl}\".format(\n        maybe_nl=\"\\n\" if docstring_format == \"rest\" and purpose != \"class\" else \"\"\n    ).join(\n        (\n            lambda param_lines: (\n                [getattr(ARG_TOKENS, docstring_format)[0]] + param_lines\n                if param_lines and docstring_format != \"rest\"\n                else param_lines\n            )\n        )(\n            list(\n                map(\n                    partial(\n                        emit_param_str,\n                        style=docstring_format,\n                        purpose=purpose,\n                        emit_type=emit_types,\n                        emit_default_doc=emit_default_doc,\n                        word_wrap=word_wrap,\n                    ),\n                    (intermediate_repr[\"params\"] or OrderedDict()).items(),\n                ),\n            )\n        )\n    )\n\n    returns = (\n        (\n            lambda line_: (\n                \"\".join(\n                    \"{maybe_nl0_and_token}{maybe_nl1}{returns_doc}\".format(\n                        maybe_nl0_and_token=(\n                            \"\"\n                            if docstring_format == \"rest\"\n                            else \"\\n{return_token}\".format(\n                                return_token=getattr(RETURN_TOKENS, docstring_format)[0]\n                            )\n                        ),\n                        maybe_nl1=\"\" if not params or params[-1] == \"\\n\" else \"\\n\",\n                        returns_doc=line_,\n                    )\n                )\n                if line_\n                else \"\"\n            )\n        )(\n            next(\n                map(\n                    partial(\n                        emit_param_str,\n                        style=docstring_format,\n                        purpose=purpose,\n                        emit_type=emit_types,\n                        emit_default_doc=emit_default_doc,\n                        word_wrap=word_wrap,\n                    ),\n                    intermediate_repr[\"returns\"].items(),\n                ),\n                None,\n            )\n        )\n        if \"return_type\" in (intermediate_repr.get(\"returns\") or iter(()))\n        else \"\"\n    )\n\n    params_end_nls = num_of_nls(params, end=True)\n    returns_end_nls = num_of_nls(returns, end=True)\n\n    candidate_args_returns = \"{params}{maybe_nl0}{returns}{maybe_nl1}\".format(\n        params=params,\n        maybe_nl0=\"\\n\" if params_end_nls &lt; 2 and returns else \"\",\n        returns=returns,\n        maybe_nl1=(\n            \"\\n\"\n            if not returns and params_end_nls &gt; 0 or returns and returns_end_nls == 0\n            else \"\"\n        ),\n    )\n\n    original_doc_str: str = intermediate_repr.get(\"_internal\", {}).get(\n        \"original_doc_str\", \"\"\n    )\n    if original_doc_str:\n        header, _, footer = parse_docstring_into_header_args_footer(\n            candidate_args_returns, original_doc_str\n        )\n        header = (\n            intermediate_repr.get(\"doc\", \"\") if not header and not footer else header\n        )\n    else:\n        header, footer = intermediate_repr.get(\"doc\", \"\"), \"\"\n\n    candidate_doc_str: str = header_args_footer_to_str(\n        header=header,\n        args_returns=\"\" if candidate_args_returns.isspace() else candidate_args_returns,\n        footer=footer,\n    )\n\n    if not candidate_doc_str or candidate_doc_str.isspace():\n        return \"\"\n\n    prev_nl, next_nl = 0, candidate_doc_str.find(\"\\n\")\n    current_indent, line = 0, None\n\n    # One line only\n    if next_nl == -1:\n        # current_indent:int = count_iter_items(takewhile(str.isspace, candidate_doc_str))\n        # _sep = (indent_level - current_indent) * tab\n        return (\n            candidate_doc_str\n            if candidate_doc_str[0] == \"\\n\"\n            else \"\\n{_sep}{candidate_doc_str}\".format(\n                _sep=\"\", candidate_doc_str=candidate_doc_str\n            )\n        )\n    else:\n        # Ignore starting newlines/whitespace only lines, keep munching until last line\n        while next_nl &gt; -1:\n            line = candidate_doc_str[prev_nl:next_nl]\n            if not line.isspace():\n                break\n            # prev_nl = next_nl\n            # current_indent:int = count_iter_items(takewhile(str.isspace, line))\n\n    if indent_level &gt; current_indent:\n        _tab = (indent_level - current_indent) * tab\n        lines = ([line] if line else []) + candidate_doc_str[\n            (\n                next_nl\n                if len(candidate_doc_str) == next_nl\n                or next_nl + 1 &lt; len(candidate_doc_str)\n                and candidate_doc_str[next_nl + 1] != \"\\n\"\n                else next_nl + 1\n            ) :\n        ].splitlines()\n        candidate_doc_str: str = \"\\n\".join(\n            map(\n                lambda _line: (\n                    \"{_tab}{_line}\".format(_tab=_tab, _line=_line)\n                    if _line or emit_separating_tab\n                    # and not _line.startswith(_tab)\n                    else _line\n                ),\n                lines,\n            )\n        )\n        if len(lines) &gt; 1:\n            candidate_doc_str: str = (\n                \"{maybe_nl}{candidate_doc_str}{maybe_nl_tab}\".format(\n                    maybe_nl=\"\\n\" if candidate_doc_str.startswith(_tab) else \"\",\n                    candidate_doc_str=candidate_doc_str,\n                    maybe_nl_tab=(\n                        \"\"\n                        if candidate_doc_str[-1] == \"\\n\"\n                        else \"\\n{_tab}\".format(_tab=_tab)\n                    ),\n                )\n            )\n\n    return candidate_doc_str\n</code></pre>"},{"location":"api/#cdddocstringparse","title":"<code>cdd.docstring.parse</code>","text":""},{"location":"api/#cdd.docstring.parse","title":"cdd.docstring.parse","text":"<p>Docstring parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.docstring.parse.docstring","title":"docstring","text":"<pre><code>docstring(doc_string, infer_type=False, return_tuple=False, parse_original_whitespace=False, emit_default_prop=True, emit_default_doc=True)\n</code></pre> <p>Converts a docstring to an AST</p> <p>Parameters:</p> Name Type Description Default <code>doc_string</code> <code>Union[str, Dict]</code> <p>docstring portion</p> required <code>infer_type</code> <code>bool</code> <p>Whether to try inferring the typ (from the default)</p> required <code>return_tuple</code> <code>Tuple</code> <p>Whether to return a tuple, or just the intermediate_repr</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <code>emit_default_prop</code> <code>dict</code> <p>Whether to include the default dictionary property.</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Union[dict, Tuple[dict, bool]]]</code> <p>intermediate_repr, whether it returns or not</p> Source code in <code>cdd/docstring/parse.py</code> <pre><code>def docstring(\n    doc_string,\n    infer_type=False,\n    return_tuple=False,\n    parse_original_whitespace=False,\n    emit_default_prop=True,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Converts a docstring to an AST\n\n    :param doc_string: docstring portion\n    :type doc_string: ```Union[str, Dict]```\n\n    :param infer_type: Whether to try inferring the typ (from the default)\n    :type infer_type: ```bool```\n\n    :param return_tuple: Whether to return a tuple, or just the intermediate_repr\n    :type return_tuple: ```bool```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :param emit_default_prop: Whether to include the default dictionary property.\n    :type emit_default_prop: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: intermediate_repr, whether it returns or not\n    :rtype: ```Optional[Union[dict, Tuple[dict, bool]]]```\n    \"\"\"\n    assert isinstance(\n        doc_string, str\n    ), \"Expected `str` got `{doc_string_type!r}`\".format(\n        doc_string_type=type(doc_string).__name__\n    )\n    parsed: IntermediateRepr = (\n        doc_string\n        if isinstance(doc_string, dict)\n        else cdd.shared.docstring_parsers.parse_docstring(\n            doc_string,\n            infer_type=infer_type,\n            emit_default_prop=emit_default_prop,\n            emit_default_doc=emit_default_doc,\n            parse_original_whitespace=parse_original_whitespace,\n        )\n    )\n\n    if return_tuple:\n        return parsed, (\n            \"returns\" in parsed\n            and parsed[\"returns\"] is not None\n            and \"return_type\" in (parsed.get(\"returns\") or iter(()))\n        )\n\n    return parsed\n</code></pre>"},{"location":"api/#cdddocstringutils","title":"<code>cdd.docstring.utils</code>","text":""},{"location":"api/#cdd.docstring.utils","title":"cdd.docstring.utils","text":"<p>docstring parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdddocstringutilsemit_utils","title":"<code>cdd.docstring.utils.emit_utils</code>","text":""},{"location":"api/#cdd.docstring.utils.emit_utils","title":"cdd.docstring.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.docstring</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.docstring.utils.emit_utils.interpolate_defaults","title":"interpolate_defaults","text":"<pre><code>interpolate_defaults(param, default_search_announce=None, require_default=False, emit_default_doc=True)\n</code></pre> <p>Correctly set the 'default' and 'doc' parameters</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>default_search_announce</code> <code>Optional[Union[str, Iterable[str]]]</code> <p>Default text(s) to look for. If None, uses default specified in default_utils.</p> required <code>require_default</code> <code>bool</code> <p>Whether a default is required, if not found in doc, infer the proper default from type</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> Source code in <code>cdd/docstring/utils/emit_utils.py</code> <pre><code>def interpolate_defaults(\n    param, default_search_announce=None, require_default=False, emit_default_doc=True\n):\n    \"\"\"\n    Correctly set the 'default' and 'doc' parameters\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :param default_search_announce: Default text(s) to look for. If None, uses default specified in default_utils.\n    :type default_search_announce: ```Optional[Union[str, Iterable[str]]]```\n\n    :param require_default: Whether a default is required, if not found in doc, infer the proper default from type\n    :type require_default: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Name, dict with keys: 'typ', 'doc', 'default'\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    name, _param = param\n    del param\n    if \"doc\" in _param:\n        doc, default = extract_default(\n            _param[\"doc\"],\n            typ=_param.get(\"typ\"),\n            default_search_announce=default_search_announce,\n            emit_default_doc=emit_default_doc,\n        )\n        _param[\"doc\"] = doc\n        if default is not None:\n            _param[\"default\"] = unquote(default)\n    if require_default and _param.get(\"default\") is None:\n        # if (\n        #     \"typ\" in _param\n        #     and _param[\"typ\"] not in frozenset((\"Any\", \"object\"))\n        #     and not _param[\"typ\"].startswith(\"Optional\")\n        # ):\n        #     _param[\"typ\"] = \"Optional[{}]\".format(_param[\"typ\"])\n        _param[\"default\"] = (\n            simple_types[_param[\"typ\"]]\n            if _param.get(\"typ\", memoryview) in simple_types\n            else cdd.shared.ast_utils.NoneStr\n        )\n\n    return name, _param\n</code></pre>"},{"location":"api/#cdddocstringutilsparse_utils","title":"<code>cdd.docstring.utils.parse_utils</code>","text":""},{"location":"api/#cdd.docstring.utils.parse_utils","title":"cdd.docstring.utils.parse_utils","text":"<p>Docstring parse utils</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.docstring.utils.parse_utils.parse_adhoc_doc_for_typ","title":"parse_adhoc_doc_for_typ","text":"<pre><code>parse_adhoc_doc_for_typ(doc, name, default_is_none)\n</code></pre> <p>Google's Keras and other frameworks have an adhoc syntax.</p> <p>Call this function after the first-pass; i.e., after the arg {name, doc, typ, default} are 'known'.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>str</code> <p>Possibly ambiguous docstring for argument, that might hint as to the type</p> required <code>name</code> <code>str</code> <p>Name of argument; useful for debugging and if the name hints as to the type</p> required <code>default_is_none</code> <code>bool</code> <p>Whether the default is <code>NoneStr</code></p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[str]</code> <p>The type (if determined) else <code>None</code></p> Source code in <code>cdd/docstring/utils/parse_utils.py</code> <pre><code>def parse_adhoc_doc_for_typ(doc, name, default_is_none):\n    \"\"\"\n    Google's Keras and other frameworks have an adhoc syntax.\n\n    Call this function after the first-pass; i.e., after the arg {name, doc, typ, default} are 'known'.\n\n    :param doc: Possibly ambiguous docstring for argument, that *might* hint as to the type\n    :type doc: ```str```\n\n    :param name: Name of argument; useful for debugging and if the name hints as to the type\n    :type name: ```str```\n\n    :param default_is_none: Whether the default is `NoneStr`\n    :type default_is_none: ```bool```\n\n    :return: The type (if determined) else `None`\n    :rtype: ```Optional[str]```\n    \"\"\"\n    if not doc:\n        return None\n\n    wrap: str = \"Optional[{}]\" if default_is_none else \"{}\"\n\n    words: List[Union[List[str], str]] = [[]]\n    candidate_type, fst_sentence, sentence = _parse_adhoc_doc_for_typ_phase0(doc, words)\n\n    if sentence is not None:\n        sentence, wrap_type_with = _parse_adhoc_doc_for_typ_phase1(sentence, words)\n\n        new_candidate_type: Optional[str] = cast(\n            Optional[str], _union_literal_from_sentence(sentence)\n        )\n        if new_candidate_type is not None:\n            if (\n                new_candidate_type.startswith(\"Literal[\")\n                and candidate_type in simple_types\n                and candidate_type is not None\n            ):\n                wrap_type_with = \"Union[{}, \" + \"{}]\".format(candidate_type)\n            candidate_type: str = (\n                new_candidate_type[len(\"Union[\") : -len(\"]\")]\n                if wrap_type_with == \"Mapping[{}]\"\n                else new_candidate_type\n            )\n        if candidate_type is not None:\n            return wrap_type_with.format(candidate_type)\n\n    if fst_sentence is not None:\n        whole_sentence_as_type: Optional[str] = type_to_name.get(\n            fst_sentence.rstrip(\".\")\n        )\n        if whole_sentence_as_type is not None:\n            return whole_sentence_as_type\n    if candidate_type is not None:\n        return candidate_type\n    elif len(words) &gt; 2:\n        if \"/\" in words[2]:\n            return \"Union[{}]\".format(\",\".join(deduplicate(words[2].split(\"/\"))))\n        candidate_type: Optional[str] = next(\n            map(\n                adhoc_3_tuple_to_type.__getitem__,\n                filter(\n                    partial(contains, adhoc_3_tuple_to_type),\n                    sliding_window(words, 3),\n                ),\n            ),\n            None,\n        )\n\n    return candidate_type if candidate_type is None else wrap.format(candidate_type)\n</code></pre>"},{"location":"api/#cddfunction","title":"<code>cdd.function</code>","text":""},{"location":"api/#cdd.function","title":"cdd.function","text":"<p>function parser and emitter module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddfunctionemit","title":"<code>cdd.function.emit</code>","text":""},{"location":"api/#cdd.function.emit","title":"cdd.function.emit","text":"<p>Function/method emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.function.emit.function","title":"function","text":"<pre><code>function(intermediate_repr, function_name, function_type, word_wrap=True, emit_default_doc=False, docstring_format='rest', indent_level=2, emit_separating_tab=PY3_8, type_annotations=True, emit_as_kwonlyargs=True, emit_original_whitespace=False)\n</code></pre> <p>Construct a function from our IR</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>function_name</code> <code>name</code> <p>name of function_def</p> required <code>function_type</code> <code>Optional[Literal['self', 'cls', 'static']]</code> <p>Type of function, static is static or global method, others just become first arg</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>indent_level</code> <code>int</code> <p>docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs</p> required <code>emit_separating_tab</code> <code>bool</code> required <code>and return and desc</code> <p>:param and return and desc</p> required <code>type_annotations</code> <code>bool</code> <p>True to have type annotations (3.6+), False to place in docstring</p> required <code>emit_as_kwonlyargs</code> <code>bool</code> <p>Whether argument(s) emitted must be keyword only</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit an original whitespace (in docstring) or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p>AST node for function definition</p> Source code in <code>cdd/function/emit.py</code> <pre><code>def function(\n    intermediate_repr,\n    function_name,\n    function_type,\n    word_wrap=True,\n    emit_default_doc=False,\n    docstring_format=\"rest\",\n    indent_level=2,\n    emit_separating_tab=PY3_8,\n    type_annotations=True,\n    emit_as_kwonlyargs=True,\n    emit_original_whitespace=False,\n):\n    \"\"\"\n    Construct a function from our IR\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param function_name: name of function_def\n    :type function_name: ```Optional[str]```\n\n    :param function_type: Type of function, static is static or global method, others just become first arg\n    :type function_type: ```Optional[Literal['self', 'cls', 'static']]```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param indent_level: docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs\n    :type indent_level: ```int```\n\n    :param emit_separating_tab: docstring decider for whether to put a tab between :param and return and desc\n    :type emit_separating_tab: ```bool```\n\n    :param type_annotations: True to have type annotations (3.6+), False to place in docstring\n    :type type_annotations: ```bool```\n\n    :param emit_as_kwonlyargs: Whether argument(s) emitted must be keyword only\n    :type emit_as_kwonlyargs: ```bool```\n\n    :param emit_original_whitespace: Whether to emit an original whitespace (in docstring) or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :return: AST node for function definition\n    :rtype: ```FunctionDef```\n    \"\"\"\n    params_no_kwargs = tuple(\n        filter(\n            lambda param: not param[0].endswith(\"kwargs\"),\n            intermediate_repr[\"params\"].items(),\n        )\n    )\n\n    function_name: Optional[str] = function_name or intermediate_repr[\"name\"]\n    function_type: Optional[str] = function_type or intermediate_repr[\"type\"]\n\n    args = (\n        []\n        if function_type in frozenset((None, \"static\"))\n        else [cdd.shared.ast_utils.set_arg(function_type)]\n    )\n    from cdd.shared.emit.utils.emitter_utils import ast_parse_fix\n\n    args_from_params = list(\n        map(\n            lambda param: cdd.shared.ast_utils.set_arg(\n                annotation=(\n                    (\n                        Name(param[1][\"typ\"], Load(), lineno=None, col_offset=None)\n                        if param[1][\"typ\"] in simple_types\n                        else ast_parse_fix(param[1][\"typ\"])\n                    )\n                    if type_annotations and \"typ\" in param[1]\n                    else None\n                ),\n                arg=param[0],\n            ),\n            params_no_kwargs,\n        ),\n    )\n    defaults_from_params = list(\n        map(\n            lambda param: (\n                cdd.shared.ast_utils.set_value(None)\n                if param[1].get(\"default\") in none_types\n                else cdd.shared.ast_utils.set_value(param[1].get(\"default\"))\n            ),\n            params_no_kwargs,\n        )\n    )\n    if emit_as_kwonlyargs:\n        kwonlyargs, kw_defaults, defaults = args_from_params, defaults_from_params, []\n    else:\n        kwonlyargs, kw_defaults, defaults = [], [], defaults_from_params\n        args += args_from_params\n\n    internal_body: Internal = get_internal_body(\n        target_name=function_name,\n        target_type=function_type,\n        intermediate_repr=intermediate_repr,\n    )\n    return_val = (\n        Return(\n            value=ast.parse(\n                intermediate_repr[\"returns\"][\"return_type\"][\"default\"].strip(\"`\")\n            )\n            .body[0]\n            .value,\n            expr=None,\n        )\n        if (intermediate_repr.get(\"returns\") or {\"return_type\": {}})[\"return_type\"].get(\n            \"default\"\n        )\n        else None\n    )\n\n    return FunctionDef(\n        args=arguments(\n            args=args,\n            defaults=defaults,\n            kw_defaults=kw_defaults,\n            kwarg=next(\n                map(\n                    lambda param: cdd.shared.ast_utils.set_arg(param[0]),\n                    filter(\n                        lambda param: param[0].endswith(\"kwargs\"),\n                        intermediate_repr[\"params\"].items(),\n                    ),\n                ),\n                None,\n            ),\n            kwonlyargs=kwonlyargs,\n            posonlyargs=[],\n            vararg=None,\n            arg=None,\n        ),\n        body=list(\n            filter(\n                None,\n                (\n                    Expr(\n                        cdd.shared.ast_utils.set_value(\n                            docstring(\n                                intermediate_repr,\n                                docstring_format=docstring_format,\n                                emit_default_doc=emit_default_doc,\n                                emit_original_whitespace=emit_original_whitespace,\n                                emit_separating_tab=emit_separating_tab,\n                                emit_types=not type_annotations,\n                                indent_level=indent_level,\n                                word_wrap=word_wrap,\n                            )\n                        ),\n                        lineno=None,\n                        col_offset=None,\n                    ),\n                    *(\n                        internal_body[:-1]\n                        if internal_body\n                        and isinstance(internal_body[-1], Return)\n                        and return_val\n                        else internal_body\n                    ),\n                    return_val,\n                ),\n            )\n        ),\n        decorator_list=[],\n        type_params=[],\n        name=function_name,\n        returns=(\n            ast.parse(intermediate_repr[\"returns\"][\"return_type\"][\"typ\"]).body[0].value\n            if type_annotations\n            and (intermediate_repr.get(\"returns\") or {\"return_type\": {}})[\n                \"return_type\"\n            ].get(\"typ\")\n            else None\n        ),\n        lineno=None,\n        arguments_args=None,\n        identifier_name=None,\n        stmt=None,\n        **cdd.shared.ast_utils.maybe_type_comment\n    )\n</code></pre>"},{"location":"api/#cddfunctionparse","title":"<code>cdd.function.parse</code>","text":""},{"location":"api/#cdd.function.parse","title":"cdd.function.parse","text":"<p>Function parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.function.parse.function","title":"function","text":"<pre><code>function(function_def, infer_type=False, parse_original_whitespace=False, word_wrap=True, function_type=None, function_name=None)\n</code></pre> <p>Converts a method to our IR</p> <p>Parameters:</p> Name Type Description Default <code>function_def</code> <code>Union[FunctionDef, FunctionType]</code> <p>AST node for function definition</p> required <code>infer_type</code> <code>bool</code> <p>Whether to try inferring the typ (from the default)</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>function_type</code> <code>Literal['self', 'cls', 'static']</code> <p>Type of function, static is static or global method, others just become first arg</p> required <code>function_name</code> <code>name</code> <p>name of function_def</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/function/parse.py</code> <pre><code>def function(\n    function_def,\n    infer_type=False,\n    parse_original_whitespace=False,\n    word_wrap=True,\n    function_type=None,\n    function_name=None,\n):\n    \"\"\"\n    Converts a method to our IR\n\n    :param function_def: AST node for function definition\n    :type function_def: ```Union[FunctionDef, FunctionType]```\n\n    :param infer_type: Whether to try inferring the typ (from the default)\n    :type infer_type: ```bool```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param function_type: Type of function, static is static or global method, others just become first arg\n    :type function_type: ```Literal['self', 'cls', 'static']```\n\n    :param function_name: name of function_def\n    :type function_name: ```Optional[str]```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    if isinstance(function_def, FunctionType):\n        # Dynamic function, i.e., this isn't source code; and is in your memory\n        ir: IntermediateRepr = cdd.shared.parse.utils.parser_utils._inspect(\n            function_def,\n            function_name,\n            parse_original_whitespace=parse_original_whitespace,\n            word_wrap=word_wrap,\n        )\n        parsed_source: FunctionDef = cast(\n            FunctionDef, ast.parse(getsource(function_def).lstrip()).body[0]\n        )\n        original_doc_str: Optional[str] = ast.get_docstring(\n            parsed_source, clean=parse_original_whitespace\n        )\n        body: FunctionDef.body = (\n            parsed_source.body if original_doc_str is None else parsed_source.body[1:]\n        )\n        ir[\"_internal\"] = {\n            \"original_doc_str\": (\n                original_doc_str\n                if parse_original_whitespace\n                else ast.get_docstring(parsed_source, clean=False)\n            ),\n            \"body\": cast(\n                List[AST],\n                list(filterfalse(rpartial(isinstance, (AnnAssign, Assign)), body)),\n            ),\n            \"from_name\": parsed_source.name,\n            \"from_type\": \"cls\",\n        }\n        return ir\n\n    assert isinstance(\n        function_def, FunctionDef\n    ), \"Expected `FunctionDef` got `{node_name!r}`\".format(\n        node_name=type(function_def).__name__\n    )\n    assert (\n        function_name is None or function_def.name == function_name\n    ), \"Expected {function_name!r} got {function_def_name!r}\".format(\n        function_name=function_name, function_def_name=function_def.name\n    )\n\n    found_type = cdd.shared.ast_utils.get_function_type(function_def)\n\n    # Read docstring\n    doc_str: Optional[str] = (\n        get_docstring(function_def, clean=parse_original_whitespace)\n        if isinstance(function_def, FunctionDef)\n        else None\n    )\n\n    function_def: FunctionDef = deepcopy(function_def)\n    function_def.args.args = (\n        function_def.args.args if found_type == \"static\" else function_def.args.args[1:]\n    )\n\n    if doc_str is None:\n        intermediate_repr: IntermediateRepr = {\n            \"name\": function_name or function_def.name,\n            \"params\": OrderedDict(),\n            \"returns\": None,\n            \"_internal\": {},\n        }\n    else:\n        intermediate_repr: IntermediateRepr = cdd.docstring.parse.docstring(\n            doc_str.replace(\":cvar\", \":param\"),\n            parse_original_whitespace=parse_original_whitespace,\n            infer_type=infer_type,\n        )\n        intermediate_repr[\"_internal\"] = {\n            \"original_doc_str\": (\n                doc_str\n                if parse_original_whitespace\n                else (\n                    get_docstring(function_def, clean=False)\n                    if isinstance(function_def, FunctionDef)\n                    else None\n                )\n            )\n        }\n\n    intermediate_repr.update(\n        {\n            \"name\": function_name or function_def.name,\n            \"type\": function_type or found_type,\n        }\n    )\n\n    intermediate_repr[\"_internal\"].update(\n        {\n            \"from_name\": function_def.name,\n            \"from_type\": found_type,\n        }\n    )\n    function_def.body = function_def.body if doc_str is None else function_def.body[1:]\n    if function_def.body:\n        intermediate_repr[\"_internal\"][\"body\"] = function_def.body\n\n    params_to_append = OrderedDict()\n    if (\n        hasattr(function_def.args, \"kwarg\")\n        and function_def.args.kwarg\n        and function_def.args.kwarg.arg in intermediate_repr[\"params\"]\n    ):\n        _param = intermediate_repr[\"params\"].pop(function_def.args.kwarg.arg)\n        assert \"typ\" in _param\n        _param[\"default\"] = cdd.shared.ast_utils.NoneStr\n        params_to_append[function_def.args.kwarg.arg] = _param\n        del _param\n\n    # Set defaults\n\n    # Fill with `None`s when no default is given to make the `zip` below it work cleanly\n    for args, defaults in (\n        (\"args\", \"defaults\"),\n        (\"kwonlyargs\", \"kw_defaults\"),\n    ):\n        diff = abs(\n            len(getattr(function_def.args, args))\n            - len(getattr(function_def.args, defaults))\n        )\n        if diff:\n            setattr(\n                function_def.args,\n                defaults,\n                list(islice(cycle((None,)), diff))\n                + getattr(function_def.args, defaults),\n            )\n    cdd.shared.parse.utils.parser_utils.ir_merge(\n        intermediate_repr,\n        {\n            \"params\": OrderedDict(\n                (\n                    cdd.shared.ast_utils.func_arg2param(\n                        getattr(function_def.args, args)[idx],\n                        default=getattr(function_def.args, defaults)[idx],\n                    )\n                    for args, defaults in (\n                        (\"args\", \"defaults\"),\n                        (\"kwonlyargs\", \"kw_defaults\"),\n                    )\n                    for idx in range(len(getattr(function_def.args, args)))\n                )\n            ),\n            \"returns\": None,\n        },\n    )\n\n    intermediate_repr[\"params\"].update(params_to_append)\n    intermediate_repr[\"params\"] = OrderedDict(\n        map(\n            partial(\n                cdd.shared.docstring_parsers._set_name_and_type,\n                infer_type=infer_type,\n                word_wrap=word_wrap,\n            ),\n            intermediate_repr[\"params\"].items(),\n        )\n    )\n\n    # Convention - the final top-level `return` is the default\n    intermediate_repr: IntermediateRepr = _interpolate_return(\n        function_def, intermediate_repr\n    )\n    if \"return_type\" in (intermediate_repr.get(\"returns\") or iter(())):\n        intermediate_repr[\"returns\"] = OrderedDict(\n            map(\n                partial(\n                    cdd.shared.docstring_parsers._set_name_and_type,\n                    infer_type=infer_type,\n                    word_wrap=word_wrap,\n                ),\n                intermediate_repr[\"returns\"].items(),\n            )\n        )\n    return intermediate_repr\n</code></pre>"},{"location":"api/#cddfunctionutils","title":"<code>cdd.function.utils</code>","text":""},{"location":"api/#cdd.function.utils","title":"cdd.function.utils","text":"<p>function parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddfunctionutilsemit_utils","title":"<code>cdd.function.utils.emit_utils</code>","text":""},{"location":"api/#cdd.function.utils.emit_utils","title":"cdd.function.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.function_utils</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.function.utils.emit_utils.make_call_meth","title":"make_call_meth","text":"<pre><code>make_call_meth(body, return_type, param_names, docstring_format, word_wrap)\n</code></pre> <p>Construct a <code>__call__</code> method from the provided <code>body</code></p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>list[AST]</code> <p>The body, probably from a <code>FunctionDef.body</code></p> required <code>return_type</code> <code>Optional[str]</code> <p>The return type of the parent symbol (probably class). Used to fill in <code>__call__</code> return.</p> required <code>param_names</code> <code>id</code> <p>Container of AST <code>id</code>s to match for rename</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p>Internal function for <code>__call__</code></p> Source code in <code>cdd/function/utils/emit_utils.py</code> <pre><code>def make_call_meth(body, return_type, param_names, docstring_format, word_wrap):\n    \"\"\"\n    Construct a `__call__` method from the provided `body`\n\n    :param body: The body, probably from a `FunctionDef.body`\n    :type body: ```list[AST]```\n\n    :param return_type: The return type of the parent symbol (probably class). Used to fill in `__call__` return.\n    :type return_type: ```Optional[str]```\n\n    :param param_names: Container of AST `id`s to match for rename\n    :type param_names: ```Optional[Iterator[str]]```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :return: Internal function for `__call__`\n    :rtype: ```FunctionDef```\n    \"\"\"\n    body_len: int = len(body)\n    if body_len and isinstance(body, dict):\n        body = list(\n            filter(\n                None,\n                (\n                    (\n                        None\n                        if body.get(\"doc\") in none_types\n                        else Expr(\n                            cdd.shared.ast_utils.set_value(\n                                emit_param_str(\n                                    (\n                                        \"return_type\",\n                                        {\n                                            \"doc\": multiline(\n                                                indent_all_but_first(body[\"doc\"])\n                                            )\n                                        },\n                                    ),\n                                    style=docstring_format,\n                                    word_wrap=word_wrap,\n                                    purpose=\"function\",\n                                )\n                            ),\n                            lineno=None,\n                            col_offset=None,\n                        )\n                    ),\n                    (\n                        RewriteName(param_names).visit(\n                            Return(\n                                cdd.shared.ast_utils.get_value(\n                                    ast.parse(return_type.strip(\"`\")).body[0]\n                                ),\n                                expr=None,\n                            )\n                        )\n                        if code_quoted(body[\"default\"])\n                        else Return(\n                            cdd.shared.ast_utils.set_value(body[\"default\"]), expr=None\n                        )\n                    ),\n                ),\n            )\n        )\n\n    return (\n        ast.fix_missing_locations(\n            FunctionDef(\n                args=arguments(\n                    args=[cdd.shared.ast_utils.set_arg(\"self\")],\n                    defaults=[],\n                    kw_defaults=[],\n                    kwarg=None,\n                    kwonlyargs=[],\n                    posonlyargs=[],\n                    vararg=None,\n                    arg=None,\n                ),\n                body=body,\n                decorator_list=[],\n                type_params=[],\n                name=\"__call__\",\n                returns=None,\n                arguments_args=None,\n                identifier_name=None,\n                stmt=None,\n                lineno=None,\n                **cdd.shared.ast_utils.maybe_type_comment\n            )\n        )\n        if body\n        else None\n    )\n</code></pre>"},{"location":"api/#cddfunctionutilsparse_utils","title":"<code>cdd.function.utils.parse_utils</code>","text":""},{"location":"api/#cdd.function.utils.parse_utils","title":"cdd.function.utils.parse_utils","text":"<p>Utility functions for <code>cdd.parse.function</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddjson_schema","title":"<code>cdd.json_schema</code>","text":""},{"location":"api/#cdd.json_schema","title":"cdd.json_schema","text":"<p>JSON-schema parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddjson_schemaemit","title":"<code>cdd.json_schema.emit</code>","text":""},{"location":"api/#cdd.json_schema.emit","title":"cdd.json_schema.emit","text":"<p>JSON schema emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.json_schema.emit.json_schema","title":"json_schema","text":"<pre><code>json_schema(intermediate_repr, identifier=None, emit_original_whitespace=False, emit_default_doc=False, word_wrap=False)\n</code></pre> <p>Construct a JSON schema dict</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>identifier</code> <code>id</code> <p>The <code>$id</code> of the schema</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit original whitespace (in top-level <code>description</code>) or strip it out</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>JSON Schema dict</p> Source code in <code>cdd/json_schema/emit.py</code> <pre><code>def json_schema(\n    intermediate_repr,\n    identifier=None,\n    emit_original_whitespace=False,\n    emit_default_doc=False,\n    word_wrap=False,\n):\n    \"\"\"\n    Construct a JSON schema dict\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param identifier: The `$id` of the schema\n    :type identifier: ```str```\n\n    :param emit_original_whitespace: Whether to emit original whitespace (in top-level `description`) or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :return: JSON Schema dict\n    :rtype: ```dict```\n    \"\"\"\n    del emit_default_doc, word_wrap\n    assert isinstance(\n        intermediate_repr, dict\n    ), \"Expected `dict` got `{type_name}`\".format(\n        type_name=type(intermediate_repr).__name__\n    )\n    if \"$id\" in intermediate_repr and \"params\" not in intermediate_repr:\n        return intermediate_repr  # Somehow this function got JSON schema as input\n    if identifier is None:\n        identifier: str = intermediate_repr.get(\n            \"$id\",\n            \"https://offscale.io/{}.schema.json\".format(\n                intermediate_repr.get(\"name\", \"INFERRED\")\n            ),\n        )\n    required = []\n    _param2json_schema_property = partial(param2json_schema_property, required=required)\n    properties = dict(\n        map(_param2json_schema_property, intermediate_repr[\"params\"].items())\n    )\n\n    return {\n        \"$id\": identifier,\n        \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n        \"description\": (\n            deindent(\n                add(\n                    *map(\n                        partial(\n                            docstring,\n                            emit_default_doc=True,\n                            emit_original_whitespace=emit_original_whitespace,\n                            emit_types=True,\n                        ),\n                        (\n                            {\n                                \"doc\": intermediate_repr[\"doc\"],\n                                \"params\": OrderedDict(),\n                                \"returns\": None,\n                            },\n                            {\n                                \"doc\": \"\",\n                                \"params\": OrderedDict(),\n                                \"returns\": intermediate_repr[\"returns\"],\n                            },\n                        ),\n                    )\n                )\n            ).lstrip(\"\\n\")\n            or None\n        ),\n        \"type\": \"object\",\n        \"properties\": properties,\n        \"required\": required,\n    }\n</code></pre>"},{"location":"api/#cdd.json_schema.emit.json_schema_file","title":"json_schema_file","text":"<pre><code>json_schema_file(input_mapping, output_filename)\n</code></pre> <p>Emit <code>input_mapping</code>\u2014as JSON schema\u2014into <code>output_filename</code></p> <p>Parameters:</p> Name Type Description Default <code>input_mapping</code> <code>Dict[str, AST]</code> <p>Import location of mapping/2-tuple collection.</p> required <code>output_filename</code> <code>str</code> <p>Output file to write to</p> required Source code in <code>cdd/json_schema/emit.py</code> <pre><code>def json_schema_file(input_mapping, output_filename):\n    \"\"\"\n    Emit `input_mapping`\u2014as JSON schema\u2014into `output_filename`\n\n    :param input_mapping: Import location of mapping/2-tuple collection.\n    :type input_mapping: ```Dict[str, AST]```\n\n    :param output_filename: Output file to write to\n    :type output_filename: ```str```\n    \"\"\"\n    schemas_it = (json_schema(v) for k, v in input_mapping.items())\n    schemas = (\n        {\"schemas\": list(schemas_it)} if len(input_mapping) &gt; 1 else next(schemas_it)\n    )\n    with open(output_filename, \"a\") as f:\n        dump(schemas, f, cls=SetEncoder)\n</code></pre>"},{"location":"api/#cddjson_schemaparse","title":"<code>cdd.json_schema.parse</code>","text":""},{"location":"api/#cdd.json_schema.parse","title":"cdd.json_schema.parse","text":"<p>JSON schema parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.json_schema.parse.json_schema","title":"json_schema","text":"<pre><code>json_schema(json_schema_dict, parse_original_whitespace=False)\n</code></pre> <p>Parse a JSON schema into the IR</p> <p>Parameters:</p> Name Type Description Default <code>json_schema_dict</code> <code>dict</code> <p>A valid JSON schema as a Python dict</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>IR representation of the given JSON schema</p> Source code in <code>cdd/json_schema/parse.py</code> <pre><code>def json_schema(json_schema_dict, parse_original_whitespace=False):\n    \"\"\"\n    Parse a JSON schema into the IR\n\n    :param json_schema_dict: A valid JSON schema as a Python dict\n    :type json_schema_dict: ```dict```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :return: IR representation of the given JSON schema\n    :rtype: ```dict```\n    \"\"\"\n    # I suppose a JSON-schema validation routine could be executed here\n    schema: dict = deepcopy(json_schema_dict)\n\n    required: FrozenSet[str] = (\n        frozenset(schema[\"required\"]) if schema.get(\"required\") else frozenset()\n    )\n    _json_schema_property_to_param = partial(\n        json_schema_property_to_param, required=required\n    )\n\n    ir: IntermediateRepr = docstring(\n        json_schema_dict.get(\"description\", \"\"),\n        emit_default_doc=False,\n        parse_original_whitespace=parse_original_whitespace,\n    )\n    ir.update(\n        {\n            \"params\": (\n                OrderedDict(\n                    map(_json_schema_property_to_param, schema[\"properties\"].items())\n                )\n                if \"properties\" in schema\n                else OrderedDict()\n            ),\n            \"name\": json_schema_dict.get(\n                \"name\",\n                json_schema_dict.get(\"id\", json_schema_dict.get(\"title\", ir[\"name\"])),\n            ),\n        }\n    )\n    return ir\n</code></pre>"},{"location":"api/#cddjson_schemautils","title":"<code>cdd.json_schema.utils</code>","text":""},{"location":"api/#cdd.json_schema.utils","title":"cdd.json_schema.utils","text":"<p>JSON-schema parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddjson_schemautilsemit_utils","title":"<code>cdd.json_schema.utils.emit_utils</code>","text":""},{"location":"api/#cdd.json_schema.utils.emit_utils","title":"cdd.json_schema.utils.emit_utils","text":"<p>Utility functions for <code>cdd.emit.json_schema</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.json_schema.utils.emit_utils.param2json_schema_property","title":"param2json_schema_property","text":"<pre><code>param2json_schema_property(param, required)\n</code></pre> <p>Turn a param into a JSON schema property</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>required</code> <code>list</code> <p>Required parameters. This function may push to the list.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>JSON schema property. Also, may push to <code>required</code>.</p> Source code in <code>cdd/json_schema/utils/emit_utils.py</code> <pre><code>def param2json_schema_property(param, required):\n    \"\"\"\n    Turn a param into a JSON schema property\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :param required: Required parameters. This function may push to the list.\n    :type required: ```list[str]```\n\n    :return: JSON schema property. Also, may push to `required`.\n    :rtype: ```dict```\n    \"\"\"\n    name, _param = param\n    del param\n    if _param.get(\"doc\"):\n        _param[\"description\"] = _param.pop(\"doc\")\n    if _param.get(\"typ\") == \"datetime\":\n        del _param[\"typ\"]\n        _param.update({\"type\": \"string\", \"format\": \"date-time\"})\n        required.append(name)\n    elif _param.get(\"typ\") in typ2json_type:\n        _param[\"type\"] = typ2json_type[_param.pop(\"typ\")]\n        required.append(name)\n    elif _param.get(\"typ\", ast) is not ast:\n        _param[\"type\"] = _param.pop(\"typ\")\n        if _param[\"type\"].startswith(\"Optional[\"):\n            _param[\"type\"] = _param[\"type\"][len(\"Optional[\") : -1]\n            if _param[\"type\"] in typ2json_type:\n                _param[\"type\"] = typ2json_type[_param[\"type\"]]\n            # elif _param.get(\"typ\") in typ2json_type:\n            #    _param[\"type\"] = typ2json_type[_param.pop(\"typ\")]\n        else:\n            required.append(name)\n\n        if _param[\"type\"].startswith(\"Literal[\"):\n            parsed_typ = cdd.shared.ast_utils.get_value(\n                ast.parse(_param[\"type\"]).body[0]\n            )\n            assert (\n                parsed_typ.value.id == \"Literal\"\n            ), \"Only basic Literal support is implemented, not {}\".format(\n                parsed_typ.value.id\n            )\n            enum = sorted(\n                map(\n                    cdd.shared.ast_utils.get_value,\n                    cdd.shared.ast_utils.get_value(parsed_typ.slice).elts,\n                )\n            )\n            _param.update(\n                {\n                    \"pattern\": \"|\".join(enum),\n                    \"type\": typ2json_type[type(enum[0]).__name__],\n                }\n            )\n    if _param.get(\"default\", False) in none_types:\n        del _param[\"default\"]  # Will be inferred as `null` from the type\n    elif isinstance(_param.get(\"default\"), AST):\n        _param[\"default\"] = cdd.shared.ast_utils.ast_type_to_python_type(\n            _param[\"default\"]\n        )\n    if isinstance(_param.get(\"choices\"), Set):\n        _param[\"pattern\"] = \"|\".join(\n            sorted(map(str, cdd.shared.ast_utils.Set_to_set(_param.pop(\"choices\"))))\n        )\n    return name, _param\n</code></pre>"},{"location":"api/#cddjson_schemautilsparse_utils","title":"<code>cdd.json_schema.utils.parse_utils</code>","text":""},{"location":"api/#cdd.json_schema.utils.parse_utils","title":"cdd.json_schema.utils.parse_utils","text":"<p>Utility functions for <code>cdd.parse.json_schema</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.json_schema.utils.parse_utils.json_schema_property_to_param","title":"json_schema_property_to_param","text":"<pre><code>json_schema_property_to_param(param, required)\n</code></pre> <p>Convert a JSON schema property to a param</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>required</code> <code>FrozenSet[str]</code> <p>Names of all required parameters</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> Source code in <code>cdd/json_schema/utils/parse_utils.py</code> <pre><code>def json_schema_property_to_param(param, required):\n    \"\"\"\n    Convert a JSON schema property to a param\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :param required: Names of all required parameters\n    :type required: ```FrozenSet[str]```\n\n    :return: Name, dict with keys: 'typ', 'doc', 'default'\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    name, _param = param\n    del param\n    if name.endswith(\"kwargs\"):\n        _param[\"typ\"] = \"Optional[dict]\"\n    # elif \"enum\" in _param:\n    #     _param[\"typ\"] = \"Literal{}\".format(_param.pop(\"enum\"))\n    #     del _param[\"type\"]\n    if \"description\" in _param:\n        _param[\"doc\"] = _param.pop(\"description\")\n\n    if _param.get(\"type\"):\n        _param[\"typ\"] = json_type2typ[_param.pop(\"type\")]\n\n    if _param.get(\"pattern\"):\n        maybe_enum = _param[\"pattern\"].split(\"|\")\n        if all(filter(str.isalpha, maybe_enum)):\n            _param[\"typ\"] = \"Literal[{}]\".format(\n                \", \".join(map(\"'{}'\".format, maybe_enum))\n            )\n            del _param[\"pattern\"]\n\n    def transform_ref_fk_set(ref, foreign_key):\n        \"\"\"\n        Transform $ref to upper camel case and add to the foreign key\n\n        :param ref: JSON ref\n        :type ref: ```str```\n\n        :param foreign_key: Foreign key structure (pass by reference)\n        :type foreign_key: ```dict```\n\n        :return: $ref without the namespace and in upper camel case\n        :rtype: ```str```\n        \"\"\"\n        entity = namespaced_pascal_to_upper_camelcase(\n            ref.rpartition(\"/\")[2].replace(\".\", \"__\")\n        )\n        foreign_key[\"fk\"] = entity\n        return entity\n\n    fk = {\"fk\": None}\n    if \"anyOf\" in _param:\n        _param[\"typ\"] = list(\n            map(\n                lambda typ: (\n                    (\n                        transform_ref_fk_set(typ[\"$ref\"], fk)\n                        if \"$ref\" in typ\n                        else typ[\"type\"]\n                    )\n                    if isinstance(typ, dict)\n                    else typ\n                ),\n                _param.pop(\"anyOf\"),\n            )\n        )\n\n        if len(_param[\"typ\"]) &gt; 1 and \"string\" in _param[\"typ\"]:\n            del _param[\"typ\"][_param[\"typ\"].index(\"string\")]\n        _param[\"typ\"] = (\n            _param[\"typ\"][0]\n            if len(_param[\"typ\"]) == 1\n            else \"Union[{}]\".format(\",\".join(_param[\"typ\"]))\n        )\n    elif \"$ref\" in _param:\n        _param[\"typ\"] = transform_ref_fk_set(_param.pop(\"$ref\"), fk)\n\n    if fk[\"fk\"] is not None:\n        fk_val = fk.pop(\"fk\")\n        fk_prefix = fk_val if fk_val.startswith(\"[FK(\") else \"[FK({})]\".format(fk_val)\n        _param[\"doc\"] = (\n            \"{} {}\".format(fk_prefix, _param[\"doc\"]) if _param.get(\"doc\") else fk_prefix\n        )\n\n    if (\n        name not in required\n        and _param.get(\"typ\")\n        and \"Optional[\" not in _param[\"typ\"]\n        # Could also parse out a `Union` for `None`\n        or _param.pop(\"nullable\", False)\n    ):\n        _param[\"typ\"] = \"Optional[{}]\".format(_param[\"typ\"])\n    if _param.get(\"default\", False) in none_types:\n        _param[\"default\"] = cdd.shared.ast_utils.NoneStr\n\n    return name, _param\n</code></pre>"},{"location":"api/#cddjson_schemautilsshared_utils","title":"<code>cdd.json_schema.utils.shared_utils</code>","text":""},{"location":"api/#cdd.json_schema.utils.shared_utils","title":"cdd.json_schema.utils.shared_utils","text":"<p>Shared utility functions for JSON schema</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddpydantic","title":"<code>cdd.pydantic</code>","text":""},{"location":"api/#cdd.pydantic","title":"cdd.pydantic","text":"<p>pydantic parser and emitter utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddpydanticemit","title":"<code>cdd.pydantic.emit</code>","text":""},{"location":"api/#cdd.pydantic.emit","title":"cdd.pydantic.emit","text":"<p>Pydantic <code>class</code> emitter</p> <p>https://pydantic-docs.helpmanual.io/usage/schema/</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddpydanticparse","title":"<code>cdd.pydantic.parse</code>","text":""},{"location":"api/#cdd.pydantic.parse","title":"cdd.pydantic.parse","text":"<p>Pydantic <code>class</code> parser</p> <p>https://pydantic-docs.helpmanual.io/usage/schema/</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddroutes","title":"<code>cdd.routes</code>","text":""},{"location":"api/#cdd.routes","title":"cdd.routes","text":"<p>Routes for parsing/emitting. Currently, Bottle, and aimed for OpenAPI.</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddroutesemit","title":"<code>cdd.routes.emit</code>","text":""},{"location":"api/#cdd.routes.emit","title":"cdd.routes.emit","text":"<p>Module of route emitters</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddroutesemitbottle","title":"<code>cdd.routes.emit.bottle</code>","text":""},{"location":"api/#cdd.routes.emit.bottle","title":"cdd.routes.emit.bottle","text":"<p>Emit constant strings with interpolated values for route generation</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.routes.emit.bottle.create","title":"create","text":"<pre><code>create(app, name, route, variant=2)\n</code></pre> <p>Create the <code>create</code> route</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>name</code> <code>str</code> <p>Name of entity</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <code>variant</code> <code>int</code> <p>Number of variant</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Create route variant with interpolated values</p> Source code in <code>cdd/routes/emit/bottle.py</code> <pre><code>def create(app, name, route, variant=2):\n    \"\"\"\n    Create the `create` route\n\n    :param app: Variable name (Bottle App)\n    :type app: ```str```\n\n    :param name: Name of entity\n    :type name: ```str```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :param variant: Number of variant\n    :type variant: ```int```\n\n    :return: Create route variant with interpolated values\n    :rtype: ```str```\n    \"\"\"\n    return create_route_variants[variant].format(app=app, name=name, route=route)\n</code></pre>"},{"location":"api/#cdd.routes.emit.bottle.create_util","title":"create_util","text":"<pre><code>create_util(name, route, variant=1)\n</code></pre> <p>Create utility function that the <code>create</code> emitter above uses</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of entity</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <code>variant</code> <code>int</code> <p>Number of variant</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Create route variant with interpolated values</p> Source code in <code>cdd/routes/emit/bottle.py</code> <pre><code>def create_util(name, route, variant=1):\n    \"\"\"\n    Create utility function that the `create` emitter above uses\n\n    :param name: Name of entity\n    :type name: ```str```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :param variant: Number of variant\n    :type variant: ```int```\n\n    :return: Create route variant with interpolated values\n    :rtype: ```str```\n    \"\"\"\n    return create_helper_variants[variant].format(name=name, route=route)\n</code></pre>"},{"location":"api/#cdd.routes.emit.bottle.destroy","title":"destroy","text":"<pre><code>destroy(app, name, route, primary_key, variant=0)\n</code></pre> <p>Create the <code>destroy</code> route</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>name</code> <code>str</code> <p>Name of entity</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <code>primary_key</code> <code>Any</code> <p>The id</p> required <code>variant</code> <code>int</code> <p>Number of variant</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Create route variant with interpolated values</p> Source code in <code>cdd/routes/emit/bottle.py</code> <pre><code>def destroy(app, name, route, primary_key, variant=0):\n    \"\"\"\n    Create the `destroy` route\n\n    :param app: Variable name (Bottle App)\n    :type app: ```str```\n\n    :param name: Name of entity\n    :type name: ```str```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :param primary_key: The id\n    :type primary_key: ```Any```\n\n    :param variant: Number of variant\n    :type variant: ```int```\n\n    :return: Create route variant with interpolated values\n    :rtype: ```str```\n    \"\"\"\n    return delete_route_variants[variant].format(\n        app=app, name=name, route=route, id=primary_key\n    )\n</code></pre>"},{"location":"api/#cdd.routes.emit.bottle.read","title":"read","text":"<pre><code>read(app, name, route, primary_key, variant=0)\n</code></pre> <p>Create the <code>read</code> route</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>str</code> <p>Variable name (Bottle App)</p> required <code>name</code> <code>str</code> <p>Name of entity</p> required <code>route</code> <code>str</code> <p>The path of the resource</p> required <code>primary_key</code> <code>Any</code> <p>The id</p> required <code>variant</code> <code>int</code> <p>Number of variant</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Create route variant with interpolated values</p> Source code in <code>cdd/routes/emit/bottle.py</code> <pre><code>def read(app, name, route, primary_key, variant=0):\n    \"\"\"\n    Create the `read` route\n\n    :param app: Variable name (Bottle App)\n    :type app: ```str```\n\n    :param name: Name of entity\n    :type name: ```str```\n\n    :param route: The path of the resource\n    :type route: ```str```\n\n    :param primary_key: The id\n    :type primary_key: ```Any```\n\n    :param variant: Number of variant\n    :type variant: ```int```\n\n    :return: Create route variant with interpolated values\n    :rtype: ```str```\n    \"\"\"\n    return read_route_variants[variant].format(\n        app=app, name=name, route=route, id=primary_key\n    )\n</code></pre>"},{"location":"api/#cddroutesemitbottle_constants_utils","title":"<code>cdd.routes.emit.bottle_constants_utils</code>","text":""},{"location":"api/#cdd.routes.emit.bottle_constants_utils","title":"cdd.routes.emit.bottle_constants_utils","text":"<p>Constant strings and tuples of strings which are to be interpolated in <code>emit.py</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddroutesparse","title":"<code>cdd.routes.parse</code>","text":""},{"location":"api/#cdd.routes.parse","title":"cdd.routes.parse","text":"<p>Module of route parsers</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddroutesparsebottle","title":"<code>cdd.routes.parse.bottle</code>","text":""},{"location":"api/#cdd.routes.parse.bottle","title":"cdd.routes.parse.bottle","text":"<p>Parsers for routes</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.routes.parse.bottle.bottle","title":"bottle","text":"<pre><code>bottle(function_def)\n</code></pre> <p>Parse bottle API</p> <p>Parameters:</p> Name Type Description Default <code>function_def</code> <code>Union[FunctionDef, FunctionType]</code> <p>Function definition of a bottle route, like <code>@api.get(\"/api\") def root(): return \"/\"</code></p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>OpenAPI representation of the given route</p> Source code in <code>cdd/routes/parse/bottle.py</code> <pre><code>def bottle(function_def):\n    \"\"\"\n    Parse bottle API\n\n    :param function_def: Function definition of a bottle route, like `@api.get(\"/api\") def root(): return \"/\"`\n    :type function_def: ```Union[FunctionDef, FunctionType]```\n\n    :return: OpenAPI representation of the given route\n    :rtype: ```dict```\n    \"\"\"\n    if isinstance(function_def, FunctionType):\n        # Dynamic function, i.e., this isn't source code; and is in your memory\n        function_def: FunctionDef = cast(\n            FunctionDef, ast.parse(getsource(function_def)).body[0]\n        )\n\n    assert isinstance(\n        function_def, FunctionDef\n    ), \"Expected `FunctionDef` got `{type_name}`\".format(\n        type_name=type(function_def).__name__\n    )\n    app_decorator = next(\n        filter(\n            lambda call: call.func.attr in methods,\n            function_def.decorator_list,\n        )\n    )\n    route: str = get_value(app_decorator.args[0])\n    name: str = app_decorator.func.value.id\n    method: methods_literal_type = app_decorator.func.attr\n\n    route_dict = {\"route\": route, \"name\": name, \"method\": method}\n    doc_str: Optional[str] = ast.get_docstring(function_def, clean=True)\n    if doc_str is not None:\n        ir: IntermediateRepr = parse_docstring(doc_str)\n        yml_start_str, yml_end_str = \"```yml\", \"```\"\n        yml_start: int = ir[\"doc\"].find(yml_start_str)\n        # if yml_start &lt; 0:\n        #    return route_dict\n        openapi_str: str = ir[\"doc\"][\n            yml_start\n            + len(yml_start_str) : ir[\"doc\"].rfind(yml_end_str)\n            - len(yml_end_str)\n            + 2\n        ]\n        return cdd.compound.openapi.parse.openapi(\n            openapi_str, route_dict, ir[\"doc\"][:yml_start].rstrip()\n        )\n</code></pre>"},{"location":"api/#cddroutesparsebottle_utils","title":"<code>cdd.routes.parse.bottle_utils</code>","text":""},{"location":"api/#cdd.routes.parse.bottle_utils","title":"cdd.routes.parse.bottle_utils","text":"<p>Parser utils for routes</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.routes.parse.bottle_utils.get_route_meta","title":"get_route_meta","text":"<pre><code>get_route_meta(mod)\n</code></pre> <p>Get the (func_name, app_name, route_path, http_method)s</p> <p>Parameters:</p> Name Type Description Default <code>mod</code> <code>Module</code> <p>Parsed AST containing routes</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterator[tuple[str, str, str, str]]</code> <p>Iterator of tuples of (func_name, app_name, route_path, http_method)</p> Source code in <code>cdd/routes/parse/bottle_utils.py</code> <pre><code>def get_route_meta(mod):\n    \"\"\"\n    Get the (func_name, app_name, route_path, http_method)s\n\n    :param mod: Parsed AST containing routes\n    :type mod: ```Module```\n\n    :return: Iterator of tuples of (func_name, app_name, route_path, http_method)\n    :rtype: ```Iterator[tuple[str, str, str, str]]```\n    \"\"\"\n    return map(\n        lambda func: (\n            func.name,\n            *next(\n                map(\n                    lambda call: (\n                        call.func.value.id,\n                        get_value(call.args[0]),\n                        call.func.attr,\n                    ),\n                    filter(\n                        lambda call: call.args and call.func.attr in methods,\n                        filter(rpartial(isinstance, Call), func.decorator_list),\n                    ),\n                )\n            ),\n        ),\n        filter(rpartial(isinstance, FunctionDef), mod.body),\n    )\n</code></pre>"},{"location":"api/#cddroutesparsefastapi","title":"<code>cdd.routes.parse.fastapi</code>","text":""},{"location":"api/#cdd.routes.parse.fastapi","title":"cdd.routes.parse.fastapi","text":"<p>FastAPI route parser</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.routes.parse.fastapi.fastapi","title":"fastapi","text":"<pre><code>fastapi(fastapi_route)\n</code></pre> <p>Parse a single FastAPI route</p> <p>Parameters:</p> Name Type Description Default <code>fastapi_route</code> <code>AsyncFunctionDef</code> <p>A single FastAPI route</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Pair of (str, dict) consisting of API path to a dictionary of form     {  Literal[\"post\",\"get\",\"put\",\"patch\"]: {          \"requestBody\": { \"$ref\": str, \"required\": boolean },          \"responses\": { number: { \"content\": {string: {\"schema\": {\"$ref\": string},                                   \"description\": string} } } },          \"summary\": string        }     }</p> Source code in <code>cdd/routes/parse/fastapi.py</code> <pre><code>def fastapi(fastapi_route):\n    \"\"\"\n    Parse a single FastAPI route\n\n    :param fastapi_route: A single FastAPI route\n    :type fastapi_route: ```AsyncFunctionDef```\n\n    :return: Pair of (str, dict) consisting of API path to a dictionary of form\n        {  Literal[\"post\",\"get\",\"put\",\"patch\"]: {\n             \"requestBody\": { \"$ref\": str, \"required\": boolean },\n             \"responses\": { number: { \"content\": {string: {\"schema\": {\"$ref\": string},\n                                      \"description\": string} } } },\n             \"summary\": string\n           }\n        }\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    method: str = fastapi_route.decorator_list[0].func.attr\n    route = get_value(fastapi_route.decorator_list[0].args[0])\n    return route, {\n        method: {\n            \"responses\": parse_fastapi_responses(\n                next(\n                    filter(\n                        lambda keyword: keyword.arg == \"responses\",\n                        fastapi_route.decorator_list[0].keywords,\n                    )\n                )\n            )\n        }\n    }\n</code></pre>"},{"location":"api/#cddroutesparsefastapi_utils","title":"<code>cdd.routes.parse.fastapi_utils</code>","text":""},{"location":"api/#cdd.routes.parse.fastapi_utils","title":"cdd.routes.parse.fastapi_utils","text":"<p>FastAPI utils</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.routes.parse.fastapi_utils.model_handler","title":"model_handler","text":"<pre><code>model_handler(key, model_name, location, mime_type)\n</code></pre> <p>Create fully-qualified model name from unqualified name</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key name</p> required <code>model_name</code> <code>Union[Literal[\"ref\"], str]</code> <p>Not fully-qualified model name or a <code>{\"$ref\": string}</code> dict</p> required <code>location</code> <code>str</code> <p>Full-qualified parent path</p> required <code>mime_type</code> <code>str</code> <p>MIME type</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[Union[str,\"content\"], dict]</code> <p>Tuple[\"content\", JSON ref to model name, of form <code>{\"$ref\": string}</code>]</p> Source code in <code>cdd/routes/parse/fastapi_utils.py</code> <pre><code>def model_handler(key, model_name, location, mime_type):\n    \"\"\"\n    Create fully-qualified model name from unqualified name\n\n    :param key: Key name\n    :type key: ```str```\n\n    :param model_name: Not fully-qualified model name or a `{\"$ref\": string}` dict\n    :type model_name: ```str|dict```\n\n    :param location: Full-qualified parent path\n    :type location: ```str```\n\n    :param mime_type: MIME type\n    :type mime_type: ```str```\n\n    :return: Tuple[\"content\", JSON ref to model name, of form `{\"$ref\": string}`]\n    :rtype: ```tuple[Union[str,\"content\"], dict]```\n    \"\"\"\n    return (\n        (key, model_name)\n        if isinstance(model_name, dict)\n        else (\n            \"content\",\n            {mime_type: {\"schema\": {\"$ref\": \"{}{}\".format(location, model_name)}}},\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.routes.parse.fastapi_utils.parse_fastapi_responses","title":"parse_fastapi_responses","text":"<pre><code>parse_fastapi_responses(responses)\n</code></pre> <p>Parse FastAPI \"responses\" key</p> <p>Parameters:</p> Name Type Description Default <code>responses</code> <code>Dict</code> <p><code>responses</code> keyword value from FastAPI decorator on route</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Transformed FastAPI \"responses\"</p> Source code in <code>cdd/routes/parse/fastapi_utils.py</code> <pre><code>def parse_fastapi_responses(responses):\n    \"\"\"\n    Parse FastAPI \"responses\" key\n\n    :param responses: `responses` keyword value from FastAPI decorator on route\n    :type responses: ```Dict```\n\n    :return: Transformed FastAPI \"responses\"\n    :rtype: ```dict```\n    \"\"\"\n\n    return {\n        key: dict(\n            (\n                (\n                    lambda _v: (\n                        (parse_handlers[k](k, _v)) if k in parse_handlers else (k, _v)\n                    )\n                )(get_value(v))\n            )\n            for k, v in Dict_to_dict(val).items()\n        )\n        for key, val in Dict_to_dict(responses.value).items()\n    }\n</code></pre>"},{"location":"api/#cddshared","title":"<code>cdd.shared</code>","text":""},{"location":"api/#cdd.shared","title":"cdd.shared","text":"<p>cdd-wide shared utilities module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsharedast_cst_utils","title":"<code>cdd.shared.ast_cst_utils</code>","text":""},{"location":"api/#cdd.shared.ast_cst_utils","title":"cdd.shared.ast_cst_utils","text":"<p>Utils for working with AST (builtin) and cdd's CST</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.ast_cst_utils.Delta","title":"Delta","text":"<p>               Bases: <code>Enum</code></p> <p>Maybe Enum for what every <code>maybe_</code> function in <code>ast_cst_utils</code> can return</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.ast_cst_utils.debug_doctrans","title":"debug_doctrans","text":"<pre><code>debug_doctrans(changed, affector, name, typ)\n</code></pre> <p>Print debug statement if changed is not nop</p> <p>Parameters:</p> Name Type Description Default <code>changed</code> <code>Delta</code> <p>Delta value indicating what changed (if anything)</p> required <code>affector</code> <code>str</code> <p>What is being changed</p> required <code>name</code> <code>str</code> <p>Name of what is being changed</p> required <code>typ</code> <code>str</code> <p>AST type name of what is being changed</p> required Source code in <code>cdd/shared/ast_cst_utils.py</code> <pre><code>def debug_doctrans(changed, affector, name, typ):\n    \"\"\"\n    Print debug statement if changed is not nop\n\n    :param changed: Delta value indicating what changed (if anything)\n    :type changed: ```Delta```\n\n    :param affector: What is being changed\n    :type affector: ```str```\n\n    :param name: Name of what is being changed\n    :type name: ```str```\n\n    :param typ: AST type name of what is being changed\n    :type typ: ```str```\n    \"\"\"\n    if changed is not Delta.nop:\n        print(\n            \"{changed!s}\".format(changed=changed).ljust(20),\n            \"{affector}\\t{typ}\\t`{name}`\".format(affector=affector, typ=typ, name=name),\n            sep=\"\",\n        )\n</code></pre>"},{"location":"api/#cdd.shared.ast_cst_utils.find_cst_at_ast","title":"find_cst_at_ast","text":"<pre><code>find_cst_at_ast(cst_list, node)\n</code></pre> <p>Find (first) CST node matching AST node</p> <p>(uses <code>_location</code> from <code>annotate_ancestry</code>)</p> <p>Parameters:</p> Name Type Description Default <code>cst_list</code> <code>list[NamedTuple]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> required <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[Optional[int], Optional[NamedTuple]]`</code> <p>Matching idx and element from cst_list if found else (None, None)</p> Source code in <code>cdd/shared/ast_cst_utils.py</code> <pre><code>def find_cst_at_ast(cst_list, node):\n    \"\"\"\n    Find (first) CST node matching AST node\n\n    (uses `_location` from `annotate_ancestry`)\n\n    :param cst_list: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :type cst_list: ```list[NamedTuple]```\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Matching idx and element from cst_list if found else (None, None)\n    :rtype: ```tuple[Optional[int], Optional[NamedTuple]]````\n    \"\"\"\n    cst_node_found, cst_node_no = None, None\n    node_type = type(node).__name__\n    cst_type = ast2cst.get(node_type, type(None)).__name__\n    if cst_type == \"NoneType\":\n        print(\"`{node_type}` not implemented\".format(node_type=node_type), file=stderr)\n        return None, None\n    for cst_node_no, cst_node in enumerate(cst_list):\n        if (\n            cst_node.line_no_start &lt;= node.lineno &lt;= cst_node.line_no_end\n            # Extra precautions to ensure the wrong new_node is never replaced:\n            and type(cst_node).__name__ == cst_type  # `isinstance` doesn't work\n            and getattr(cst_node, \"name\", None) == getattr(node, \"name\", None)\n        ):\n            cst_node_found = cst_node\n            break\n    return cst_node_no, cst_node_found\n</code></pre>"},{"location":"api/#cdd.shared.ast_cst_utils.maybe_replace_doc_str_in_function_or_class","title":"maybe_replace_doc_str_in_function_or_class","text":"<pre><code>maybe_replace_doc_str_in_function_or_class(node, cst_idx, cst_list)\n</code></pre> <p>Maybe replace the doc_str of a function or class</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[ClassDef, AsyncFunctionDef, FunctionDef]</code> <p>AST node</p> required <code>cst_idx</code> <code>int</code> <p>Index of start of function/class in cst_list</p> required <code>cst_list</code> <code>list[NamedTuple]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Delta</code> <p>Delta value indicating what changed (if anything)</p> Source code in <code>cdd/shared/ast_cst_utils.py</code> <pre><code>def maybe_replace_doc_str_in_function_or_class(node, cst_idx, cst_list):\n    \"\"\"\n    Maybe replace the doc_str of a function or class\n\n    :param node: AST node\n    :type node: ```Union[ClassDef, AsyncFunctionDef, FunctionDef]```\n\n    :param cst_idx: Index of start of function/class in cst_list\n    :type cst_idx: ```int```\n\n    :param cst_list: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :type cst_list: ```list[NamedTuple]```\n\n    :return: Delta value indicating what changed (if anything)\n    :rtype: ```Delta```\n    \"\"\"\n    new_doc_str: str = get_doc_str(node) or \"\"\n    cur_node_after_func = (\n        cst_list[cst_idx + 1]\n        if cst_idx + 1 &lt; len(cst_list)\n        else UnchangingLine(0, 0, \"\")\n    )\n    existing_doc_str: bool = (\n        isinstance(cur_node_after_func, TripleQuoted) and cur_node_after_func.is_docstr\n    )\n    changed: Delta = Delta.nop\n\n    def formatted_doc_str(doc_str, is_double_q=True):\n        \"\"\"\n        Correctly indent, pre- and post-space the doc_str\n\n        :param doc_str: Input doc string\n        :type doc_str: ```str```\n\n        :param is_double_q: Whether the doc_str should be double-quoted\n        :type is_double_q: ```bool```\n\n        :return: Correctly formatted `doc_str`\n        :rtype: ```str```\n        \"\"\"\n        str_after_func_no_nl = cur_node_after_func.value.lstrip(\"\\n\")\n        indent_after_func_no_nl: int = count_iter_items(\n            takewhile(str.isspace, str_after_func_no_nl)\n        )\n        space: str = str_after_func_no_nl[:indent_after_func_no_nl]\n        return TripleQuoted(\n            is_double_q=is_double_q,\n            is_docstr=True,\n            value='\\n{space}\"\"\"{replacement_doc_str}\\n{space}\"\"\"'.format(\n                space=space,\n                replacement_doc_str=\"\\n\".join(\n                    map(\n                        lambda line: \"{space}{line}\".format(\n                            space=str_after_func_no_nl[\n                                : indent_after_func_no_nl - len(tab)\n                            ],\n                            line=line,\n                        ),\n                        doc_str.split(\"\\n\"),\n                    )\n                ).rstrip(),\n            ),\n            line_no_start=cur_node_after_func.line_no_start,\n            line_no_end=cur_node_after_func.line_no_end,\n        )\n\n    if new_doc_str and not existing_doc_str:\n        cst_list.insert(\n            cst_idx + 1,\n            formatted_doc_str(new_doc_str),\n        )\n        changed = Delta.added\n    elif not new_doc_str and existing_doc_str:\n        del cst_list[cst_idx + 1]\n        changed = Delta.removed\n    # elif not new_doc_str and not existing_doc_str: changed = Delta.nop\n    elif new_doc_str and existing_doc_str:\n        cur_doc_str_only = cur_node_after_func.value.strip()[3:-3]\n        if ne(*map(omit_whitespace, (cur_doc_str_only, new_doc_str))):\n            pre, _, post = cur_node_after_func.value.partition(cur_doc_str_only)\n            cst_list[cst_idx + 1] = formatted_doc_str(\n                new_doc_str, is_double_q=cst_list[cst_idx + 1].is_double_q\n            )\n            changed = Delta.replaced\n    if changed is not Delta.nop:\n        debug_doctrans(changed, \"docstr\", node.name, type(node).__name__)\n        # Subsequent `line_no` `start,end` lines are invalidated. It's necessary to link the CST and AST together.\n\n    return changed\n</code></pre>"},{"location":"api/#cdd.shared.ast_cst_utils.maybe_replace_function_args","title":"maybe_replace_function_args","text":"<pre><code>maybe_replace_function_args(new_node, cur_ast_node, cst_idx, cst_list)\n</code></pre> <p>Maybe replace the doc_str of a function or class</p> <p>Parameters:</p> Name Type Description Default <code>new_node</code> <code>Union[AsyncFunctionDef, FunctionDef]</code> <p>AST function node</p> required <code>cur_ast_node</code> <code>AST</code> <p>AST function node of CST (with fake body)</p> required <code>cst_idx</code> <code>int</code> <p>Index of start of function/class in cst_list</p> required <code>cst_list</code> <code>list[NamedTuple]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Delta</code> <p>Delta value indicating what changed (if anything)</p> Source code in <code>cdd/shared/ast_cst_utils.py</code> <pre><code>def maybe_replace_function_args(new_node, cur_ast_node, cst_idx, cst_list):\n    \"\"\"\n    Maybe replace the doc_str of a function or class\n\n    :param new_node: AST function node\n    :type new_node: ```Union[AsyncFunctionDef, FunctionDef]```\n\n    :param cur_ast_node: AST function node of CST (with fake body)\n    :type cur_ast_node: ```AST```\n\n    :param cst_idx: Index of start of function/class in cst_list\n    :type cst_idx: ```int```\n\n    :param cst_list: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :type cst_list: ```list[NamedTuple]```\n\n    :return: Delta value indicating what changed (if anything)\n    :rtype: ```Delta```\n    \"\"\"\n    new_node = deepcopy(new_node)\n    new_node.body = cur_ast_node.body\n    changed: Delta = Delta.nop\n    if not cmp_ast(cur_ast_node.args, new_node.args):\n        new_args, cur_args = map(attrgetter(\"args.args\"), (new_node, cur_ast_node))\n\n        for i in range(len(cur_args)):\n            if cur_args[i].annotation != new_args[i].annotation:\n                # Approximation, obviously you could have intermixed annotation and to-be (un)annotated\n                if cur_args[i].annotation is None:\n                    changed: Delta = Delta.added\n                elif new_args[i].annotation is None:\n                    changed: Delta = Delta.removed\n                else:\n                    changed: Delta = Delta.replaced\n                break\n\n        def_len: int = len(\"def \")\n        function_name_starts_at: int = (\n            def_len\n            if cst_list[cst_idx].value.startswith(\"def \")\n            else (lambda i: cst_list[cst_idx].value.find(\")def \") if i == -1 else i)(\n                cst_list[cst_idx].value.find(\" def \")\n            )\n            + def_len\n            + 1\n        )\n        arg_start_idx: int = cst_list[cst_idx].value.find(\"(\", function_name_starts_at)\n        func_end: int = cst_list[cst_idx].value.rfind(\":\")\n        return_type: Optional[int] = cst_list[cst_idx].value.rfind(\"-&gt;\", None, func_end)\n        if return_type &gt; -1:\n            last_col = func_end\n            func_end = return_type\n            return_type = cst_list[cst_idx].value[return_type + len(\"-&gt;\") : last_col]\n        else:\n            return_type = None\n        func_end = cst_list[cst_idx].value.rfind(\")\", None, func_end) + 1\n\n        # returns=\"\" if return_type is None else return_type\n\n        cst_list[cst_idx] = FunctionDefinitionStart(\n            line_no_start=cst_list[cst_idx].line_no_start,\n            line_no_end=cst_list[cst_idx].line_no_end,\n            name=cst_list[cst_idx].name,\n            # TODO: Handle comments in the middle of args, and match whitespace, and maybe even limit line length\n            value=\"{start}{args}{end}\".format(\n                start=cst_list[cst_idx].value[: arg_start_idx + 1],\n                end=cst_list[cst_idx].value[func_end - 1 :],\n                args=\", \".join(\n                    \"{arg_name}{annotation}\".format(\n                        annotation=(\n                            \"\"\n                            if arg.annotation is None\n                            else \": {annotation_unparsed}\".format(\n                                annotation_unparsed=to_code(arg.annotation).rstrip(\"\\n\")\n                            )\n                        ),\n                        arg_name=arg.arg,\n                    )\n                    for arg in new_args\n                ),\n            ),\n        )\n\n    if changed is not Delta.nop:\n        debug_doctrans(changed, \"args\", new_node.name, type(new_node).__name__)\n\n    return changed\n</code></pre>"},{"location":"api/#cdd.shared.ast_cst_utils.maybe_replace_function_return_type","title":"maybe_replace_function_return_type","text":"<pre><code>maybe_replace_function_return_type(new_node, cur_ast_node, cst_idx, cst_list)\n</code></pre> <p>Maybe replace the function's return type</p> <p>Parameters:</p> Name Type Description Default <code>new_node</code> <code>Union[AsyncFunctionDef, FunctionDef]</code> <p>AST function node</p> required <code>cur_ast_node</code> <code>AST</code> <p>AST function node of CST (with fake body)</p> required <code>cst_idx</code> <code>int</code> <p>Index of start of function/class in cst_list</p> required <code>cst_list</code> <code>list[NamedTuple]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Delta</code> <p>Delta value indicating what changed (if anything)</p> Source code in <code>cdd/shared/ast_cst_utils.py</code> <pre><code>def maybe_replace_function_return_type(new_node, cur_ast_node, cst_idx, cst_list):\n    \"\"\"\n    Maybe replace the function's return type\n\n    :param new_node: AST function node\n    :type new_node: ```Union[AsyncFunctionDef, FunctionDef]```\n\n    :param cur_ast_node: AST function node of CST (with fake body)\n    :type cur_ast_node: ```AST```\n\n    :param cst_idx: Index of start of function/class in cst_list\n    :type cst_idx: ```int```\n\n    :param cst_list: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :type cst_list: ```list[NamedTuple]```\n\n    :return: Delta value indicating what changed (if anything)\n    :rtype: ```Delta```\n    \"\"\"\n    new_node = deepcopy(new_node)\n    new_node.body = cur_ast_node.body\n    value: Optional[str] = None\n\n    def remove_return_typ(statement):\n        \"\"\"\n        Remove the return typ\n\n        :param statement: The statement verbatim\n        :type statement: ```str```\n\n        :return: The new function prototype\n        :rtype: ```str```\n        \"\"\"\n        return \"{type_less}:\".format(\n            type_less=statement[: statement.rfind(\"-&gt;\")].rstrip()\n        )\n\n    def add_return_typ(statement):\n        \"\"\"\n        Add the return typ\n\n        :param statement: The statement verbatim\n        :type statement: ```str```\n\n        :return: The new function prototype\n        :rtype: ```str```\n        \"\"\"\n        pre, col, post = statement.rpartition(\":\")\n        return \"{pre} -&gt; {return_typ}{col}{post}\".format(\n            pre=pre,\n            return_typ=to_code(new_node.returns).rstrip(\"\\n\"),\n            col=col,\n            post=post,\n        )\n\n    if cmp_ast(cur_ast_node.returns, new_node.returns):\n        changed: Delta = Delta.nop\n    elif cur_ast_node.returns and new_node.returns:\n        changed: Delta = Delta.replaced\n        value = add_return_typ(remove_return_typ(cst_list[cst_idx].value))\n    elif cur_ast_node.returns and not new_node.returns:\n        changed: Delta = Delta.removed\n        value = remove_return_typ(cst_list[cst_idx].value)\n    else:  # not cur_ast_node.returns and new_node.returns:\n        changed: Delta = Delta.added\n        value = add_return_typ(cst_list[cst_idx].value)\n    if value is not None:\n        cst_list[cst_idx] = FunctionDefinitionStart(\n            line_no_start=cst_list[cst_idx].line_no_start,\n            line_no_end=cst_list[cst_idx].line_no_end,\n            name=cst_list[cst_idx].name,\n            value=value,\n        )\n\n    if changed is not Delta.nop:\n        debug_doctrans(changed, \"return_type\", new_node.name, type(new_node).__name__)\n\n    return changed\n</code></pre>"},{"location":"api/#cddsharedast_utils","title":"<code>cdd.shared.ast_utils</code>","text":""},{"location":"api/#cdd.shared.ast_utils","title":"cdd.shared.ast_utils","text":"<p>ast_utils, a bunch of helpers for converting input into ast.* input_str</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.ast_utils.RewriteAtQuery","title":"RewriteAtQuery","text":"<pre><code>RewriteAtQuery(search, replacement_node)\n</code></pre> <p>               Bases: <code>NodeTransformer</code></p> <p>Replace the node at query with given node</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <p>Search query, e.g., ['node_name', 'function_name', 'arg_name']</p> required <code>replacement_node</code> <p>Node to replace this search</p> required <code>replaced</code> <p>Whether a node has been replaced (only replaces first occurrence)</p> required <p>Parameters:</p> Name Type Description Default <code>search</code> <code>list[str]</code> <p>Search query, e.g., ['node_name', 'function_name', 'arg_name']</p> required <code>replacement_node</code> <code>AST</code> <p>Node to replace this search</p> required Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def __init__(self, search, replacement_node):\n    \"\"\"\n    :param search: Search query, e.g., ['node_name', 'function_name', 'arg_name']\n    :type search: ```list[str]```\n\n    :param replacement_node: Node to replace this search\n    :type replacement_node: ```AST```\n    \"\"\"\n    self.search = search\n    self.replacement_node = replacement_node\n    self.replaced = False\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.RewriteAtQuery.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node)\n</code></pre> <p>visits the <code>AST</code>, if it's the right one, replace it</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>The AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>Potentially changed AST node</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def generic_visit(self, node):\n    \"\"\"\n    visits the `AST`, if it's the right one, replace it\n\n    :param node: The AST node\n    :type node: ```AST```\n\n    :return: Potentially changed AST node\n    :rtype: ```AST```\n    \"\"\"\n    if (\n        not self.replaced\n        and hasattr(node, \"_location\")\n        and node._location == self.search\n    ):\n        self.replaced = True\n        return self.replacement_node\n    else:\n        return NodeTransformer.generic_visit(self, node)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.RewriteAtQuery.visit_FunctionDef","title":"visit_FunctionDef","text":"<pre><code>visit_FunctionDef(node)\n</code></pre> <p>visits the <code>FunctionDef</code>, if it's the right one, replace it</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>FunctionDef</code> <p>FunctionDef</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p>Potentially changed FunctionDef</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def visit_FunctionDef(self, node):\n    \"\"\"\n    visits the `FunctionDef`, if it's the right one, replace it\n\n    :param node: FunctionDef\n    :type node: ```FunctionDef```\n\n    :return: Potentially changed FunctionDef\n    :rtype: ```FunctionDef```\n    \"\"\"\n\n    if (\n        not self.replaced\n        and hasattr(node, \"_location\")\n        and node._location == self.search[:-1]\n    ):\n        if isinstance(self.replacement_node, (AnnAssign, Assign)):\n            # Set default\n            if isinstance(self.replacement_node, AnnAssign):\n                idx = next(\n                    (\n                        _arg._idx\n                        for _arg in node.args.args\n                        if _arg.arg == self.replacement_node.target.id\n                        and hasattr(_arg, \"_idx\")\n                    ),\n                    None,\n                )\n            else:\n                idx = next(\n                    filter(\n                        None,\n                        (\n                            _arg._idx if _arg.arg == target.id else None\n                            for target in self.replacement_node.targets\n                            for _arg in node.args.args\n                            if hasattr(_arg, \"_idx\")\n                        ),\n                    ),\n                    None,\n                )\n                self.replacement_node = set_arg(\n                    arg=self.replacement_node.targets[0].id,\n                    annotation=self.replacement_node.value,\n                )\n\n            if idx is not None and len(node.args.defaults) &gt; idx:\n                new_default = get_value(self.replacement_node)\n                if new_default not in none_types:\n                    node.args.defaults[idx] = new_default\n\n            self.replacement_node = emit_arg(self.replacement_node)\n        assert isinstance(\n            self.replacement_node, ast.arg\n        ), \"Expected `ast.arg` got `{type_name}`\".format(\n            type_name=type(self.replacement_node).__name__\n        )\n\n        for arg_attr in \"args\", \"kwonlyargs\":\n            arg_l = getattr(node.args, arg_attr)\n            for idx in range(len(arg_l)):\n                if (\n                    hasattr(arg_l[idx], \"_location\")\n                    and arg_l[idx]._location == self.search\n                ):\n                    arg_l[idx] = emit_arg(self.replacement_node)\n                    self.replaced = True\n                    break\n\n    return node\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.Undefined","title":"Undefined","text":"<p>Null class</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.ast_utils.Dict_to_dict","title":"Dict_to_dict","text":"<pre><code>Dict_to_dict(d)\n</code></pre> <p>Create a <code>dict</code> from a <code>Dict</code></p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict</code> <p>ast.Dict</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Python dictionary</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def Dict_to_dict(d):\n    \"\"\"\n    Create a `dict` from a `Dict`\n\n    :param d: ast.Dict\n    :type d: ```Dict```\n\n    :return: Python dictionary\n    :rtype: ```dict```\n    \"\"\"\n    return dict(zip(map(get_value, d.keys), map(get_value, d.values)))\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.annotate_ancestry","title":"annotate_ancestry","text":"<pre><code>annotate_ancestry(node, filename=None)\n</code></pre> <p>Look to your roots. Find the child; find the parent. Sets _location and file attributes to every child node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node. Will be annotated in-place.</p> required <code>filename</code> <code>Optional[str]</code> <p>Where the node was originally defined. Sets the <code>__file__</code> attribute to this.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>Annotated AST node; also <code>node</code> arg will be annotated in-place.</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def annotate_ancestry(node, filename=None):\n    \"\"\"\n    Look to your roots. Find the child; find the parent.\n    Sets _location and __file__ attributes to every child node.\n\n    :param node: AST node. Will be annotated in-place.\n    :type node: ```AST```\n\n    :param filename: Where the node was originally defined. Sets the `__file__` attribute to this.\n    :type filename: ```Optional[str]```\n\n    :return: Annotated AST node; also `node` arg will be annotated in-place.\n    :rtype: ```AST```\n    \"\"\"\n    # print(\"annotating\", getattr(node, \"name\", None))\n    node._location = [node.name] if hasattr(node, \"name\") else []\n    if filename not in (None, \"&lt;unknown&gt;\") and isinstance(\n        node, (AnnAssign, Assign, AsyncFunctionDef, ClassDef, FunctionDef, Module)\n    ):\n        setattr(node, \"__file__\", filename)\n    parent_location = []\n    for _node in walk(node):\n        name = [_node.name] if hasattr(_node, \"name\") else []\n        if filename not in (None, \"&lt;unknown&gt;\") and isinstance(\n            _node, (AnnAssign, Assign, AsyncFunctionDef, ClassDef, FunctionDef, Module)\n        ):\n            setattr(_node, \"__file__\", filename)\n        for child_node in iter_child_nodes(_node):\n            if hasattr(child_node, \"name\") and not isinstance(child_node, alias):\n                child_node._location = name + [child_node.name]\n                parent_location = child_node._location\n            elif isinstance(child_node, (Constant, Str)):\n                child_node._location = parent_location + [get_value(child_node)]\n            elif isinstance(child_node, Assign) and all(\n                map(\n                    rpartial(isinstance, Name),\n                    child_node.targets,\n                )\n            ):\n                for target in child_node.targets:\n                    child_node._location = name + [target.id]\n            elif isinstance(child_node, AnnAssign) and isinstance(\n                child_node.target, Name\n            ):\n                child_node._location = name + [child_node.target.id]\n\n            if isinstance(child_node, (AsyncFunctionDef, FunctionDef)):\n\n                def set_index_and_location(idx_arg):\n                    \"\"\"\n                    :param idx_arg: Index and Any; probably out of `enumerate`\n                    :type idx_arg: ```tuple[int, Any]```\n\n                    :return: Second element, with _idx set with value of first\n                    :rtype: ```Any```\n                    \"\"\"\n                    idx_arg[1]._idx = idx_arg[0]\n                    idx_arg[1]._location = child_node._location + [idx_arg[1].arg]\n                    return idx_arg[1]\n\n                child_node.args.args = list(\n                    map(\n                        set_index_and_location,\n                        enumerate(\n                            child_node.args.args,\n                            (\n                                -1\n                                if len(child_node.args.args) &gt; 0\n                                and child_node.args.args[0].arg\n                                in frozenset((\"self\", \"cls\"))\n                                else 0\n                            ),\n                        ),\n                    )\n                )\n\n                child_node.args.kwonlyargs = list(\n                    map(\n                        set_index_and_location,\n                        enumerate(\n                            child_node.args.kwonlyargs,\n                            0,\n                        ),\n                    )\n                )\n    return node\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.ast_elts_to_container","title":"ast_elts_to_container","text":"<pre><code>ast_elts_to_container(node, container)\n</code></pre> <p>Convert AST container to Python container</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node with elts attribute</p> required <code>container</code> <code>type</code> <p>Python container</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>instanceof container</code> <p>Python container</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def ast_elts_to_container(node, container):\n    \"\"\"\n    Convert AST container to Python container\n\n    :param node: AST node with elts attribute\n    :type node: ```AST```\n\n    :param container: Python container\n    :type container: ```type```\n\n    :return: Python container\n    :rtype: ```instanceof container```\n    \"\"\"\n    assert hasattr(node, \"elts\")\n    return container(map(get_value, node.elts))\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.ast_type_to_python_type","title":"ast_type_to_python_type","text":"<pre><code>ast_type_to_python_type(node)\n</code></pre> <p>Unparse AST type as Python type</p> <p>Implementation notes:   - this focuses on 'evaluated scalars' that can be represented as JSON   - think of this as a <code>get_value</code> alternative</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Num,Bytes,Str,Constant,Dict,Set,Tuple,List]</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[dict,str,int,float,complex,bytes,list,tuple,set]</code> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def ast_type_to_python_type(node):\n    \"\"\"\n    Unparse AST type as Python type\n\n    Implementation notes:\n      - this focuses on 'evaluated scalars' that can be represented as JSON\n      - think of this as a `get_value` alternative\n\n    :param node: AST node\n    :type node: ```Union[Num,Bytes,Str,Constant,Dict,Set,Tuple,List]```\n\n    :rtype: Union[dict,str,int,float,complex,bytes,list,tuple,set]\n    \"\"\"\n    assert isinstance(node, AST), \"Expected `AST` got `{type_name}`\".format(\n        type_name=type(node).__name__\n    )\n    if isinstance(node, Num):\n        return node.n\n    elif isinstance(node, (Bytes, Str)):\n        return node.s\n    elif isinstance(node, Constant):\n        return node.value\n    elif isinstance(node, Dict):\n        return Dict_to_dict(node)\n    elif isinstance(node, Set):\n        return Set_to_set(node)\n    elif isinstance(node, Tuple):\n        return Tuple_to_tuple(node)\n    elif isinstance(node, List):\n        return List_to_list(node)\n    else:\n        raise NotImplementedError(node)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.cmp_ast","title":"cmp_ast","text":"<pre><code>cmp_ast(node0, node1)\n</code></pre> <p>Compare if two nodes are equal. Verbatim stolen from <code>meta.asttools</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node0</code> <code>Union[AST, List[AST], Tuple[AST]]</code> <p>First node</p> required <code>node1</code> <code>Union[AST, List[AST], Tuple[AST]]</code> <p>Second node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether they are equal (recursive)</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def cmp_ast(node0, node1):\n    \"\"\"\n    Compare if two nodes are equal. Verbatim stolen from `meta.asttools`.\n\n    :param node0: First node\n    :type node0: ```Union[AST, List[AST], Tuple[AST]]```\n\n    :param node1: Second node\n    :type node1: ```Union[AST, List[AST], Tuple[AST]]```\n\n    :return: Whether they are equal (recursive)\n    :rtype: ```bool```\n    \"\"\"\n\n    if type(node0) is not type(node1):\n        return False\n\n    if isinstance(node0, (list, tuple)):\n        if len(node0) != len(node1):\n            return False\n\n        for left, right in zip(node0, node1):\n            if not cmp_ast(left, right):\n                return False\n\n    elif isinstance(node0, AST):\n        for field in node0._fields:\n            left = getattr(node0, field, Undefined)\n            right = getattr(node1, field, Undefined)\n\n            if not cmp_ast(left, right):\n                return False\n    else:\n        return node0 == node1\n\n    return True\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.code_quoted","title":"code_quoted","text":"<pre><code>code_quoted(s)\n</code></pre> <p>Internally user-provided <code>None</code> and non <code>literal_eval</code>able input is quoted with ```</p> <p>This function checks if the input is quoted such</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>Any</code> <p>The input</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the input is code quoted</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def code_quoted(s):\n    \"\"\"\n    Internally user-provided `None` and non `literal_eval`able input is quoted with ```\n\n    This function checks if the input is quoted such\n\n    :param s: The input\n    :type s: ```Any```\n\n    :return: Whether the input is code quoted\n    :rtype: ```bool```\n    \"\"\"\n    return (\n        isinstance(s, str) and len(s) &gt; 6 and s.startswith(\"```\") and s.endswith(\"```\")\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.construct_module_with_symbols","title":"construct_module_with_symbols","text":"<pre><code>construct_module_with_symbols(module, symbols)\n</code></pre> <p>Create a module out of the input module that only contains nodes with a name contained in <code>symbols</code></p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Module</code> <p>Input module</p> required <code>symbols</code> <code>FrozenSet[str]</code> <p>Symbols</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Module with only members whose <code>.name</code> is in <code>symbols</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def construct_module_with_symbols(module, symbols):\n    \"\"\"\n    Create a module out of the input module that only contains nodes\n    with a name contained in `symbols`\n\n    :param module: Input module\n    :type module: ```Module```\n\n    :param symbols: Symbols\n    :type symbols: ```FrozenSet[str]```\n\n    :return: Module with only members whose `.name` is in `symbols`\n    :rtype: ```Module```\n    \"\"\"\n    return Module(\n        body=list(\n            filter(lambda node: getattr(node, \"name\", \"\") in symbols, module.body)\n        ),\n        type_ignores=[],\n        stmt=None,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.deduplicate","title":"deduplicate","text":"<pre><code>deduplicate(it)\n</code></pre> <p>Deduplicate an iterable</p> <p>Parameters:</p> Name Type Description Default <code>it</code> <code>Union[Iterable, Generator, List, Tuple, Set, FrozenSet]</code> <p>An iterable|collection with hashable elements</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterable</code> <p>Deduplicated iterable of the input</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def deduplicate(it):\n    \"\"\"\n    Deduplicate an iterable\n\n    :param it: An iterable|collection with hashable elements\n    :type it: ```Union[Iterable, Generator, List, Tuple, Set, FrozenSet]```\n\n    :return: Deduplicated iterable of the input\n    :rtype: ```Iterable```\n    \"\"\"\n    seen = set()\n    return (seen.add(e) or e for e in it if e not in seen)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.deduplicate_sorted_imports","title":"deduplicate_sorted_imports","text":"<pre><code>deduplicate_sorted_imports(module)\n</code></pre> <p>Deduplicate sorted imports. NOTE: for a more extensive solution use isort or ruff.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Module</code> <p>Module</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Module but with duplicate import entries in first import block removed</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def deduplicate_sorted_imports(module):\n    \"\"\"\n    Deduplicate sorted imports. NOTE: for a more extensive solution use isort or ruff.\n\n    :param module: Module\n    :type module: ```Module```\n\n    :return: Module but with duplicate import entries in first import block removed\n    :rtype: ```Module```\n    \"\"\"\n    assert isinstance(module, Module), \"Expected `Module` got `{}`\".format(\n        type(module).__name__\n    )\n    fst_import_idx: Optional[int] = next(\n        map(\n            itemgetter(0),\n            filter(\n                lambda idx_node: isinstance(idx_node[1], (ImportFrom, Import)),\n                enumerate(module.body),\n            ),\n        ),\n        None,\n    )\n    if fst_import_idx is None:\n        return module\n    lst_import_idx: Optional[int] = next(\n        iter(\n            deque(\n                map(\n                    itemgetter(0),\n                    filter(\n                        lambda idx_node: isinstance(idx_node[1], (ImportFrom, Import)),\n                        enumerate(module.body, fst_import_idx),\n                    ),\n                ),\n                maxlen=1,\n            )\n        ),\n        None,\n    )\n    name_seen: MutableSet[str] = set()\n\n    module.body = (\n        module.body[:fst_import_idx]\n        + list(\n            filter(\n                attrgetter(\"names\"),\n                (\n                    # TODO: Infer `level`\n                    ImportFrom(\n                        module=name,\n                        names=list(\n                            filter(\n                                lambda _alias: (\n                                    lambda key: (\n                                        False\n                                        if key in name_seen\n                                        else (name_seen.add(key) or True)\n                                    )\n                                )(\n                                    \"&lt;name={!r}, alias.name={!r}, alias.asname={!r}&gt;\".format(\n                                        name, _alias.name, _alias.asname\n                                    )\n                                ),\n                                sorted(\n                                    chain.from_iterable(\n                                        map(attrgetter(\"names\"), import_from_nodes)\n                                    ),\n                                    key=attrgetter(\"name\"),\n                                ),\n                            )\n                        ),\n                        level=0,  # import_from_nodes[0].level\n                        identifier=None,\n                    )\n                    for name, import_from_nodes in groupby(\n                        module.body[fst_import_idx:lst_import_idx],\n                        key=attrgetter(\"module\"),\n                    )\n                ),\n            )\n        )\n        + module.body[lst_import_idx:]\n    )\n    name_seen.clear()\n    return module\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.del_ass_where_name","title":"del_ass_where_name","text":"<pre><code>del_ass_where_name(node, name)\n</code></pre> <p>Delete all <code>Assign</code>/<code>AnnAssign</code> in node body where id matches name</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,                      ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]</code> <p>AST node with a '.body'</p> required <code>name</code> <code>id</code> <p>Name to match (matches against <code>id</code> field of <code>Name</code>)</p> required Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def del_ass_where_name(node, name):\n    \"\"\"\n    Delete all `Assign`/`AnnAssign` in node body where id matches name\n\n    :param node: AST node with a '.body'\n    :type node: ```Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,\n                         ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]```\n\n    :param name: Name to match (matches against `id` field of `Name`)\n    :type name: ```str```\n    \"\"\"\n    node.body = list(\n        filter(\n            None,\n            (\n                (\n                    None\n                    if isinstance(_node, Assign)\n                    and name\n                    in frozenset(\n                        map(\n                            attrgetter(\"id\"),\n                            filter(rpartial(isinstance, Name), _node.targets),\n                        )\n                    )\n                    or isinstance(_node, AnnAssign)\n                    and _node.target == name\n                    else _node\n                )\n                for _node in node.body\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.emit_ann_assign","title":"emit_ann_assign","text":"<pre><code>emit_ann_assign(node)\n</code></pre> <p>Produce an <code>AnnAssign</code> from the input</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AnnAssign</code> <p>Something which parses to the form of <code>a=5</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def emit_ann_assign(node):\n    \"\"\"\n    Produce an `AnnAssign` from the input\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Something which parses to the form of `a=5`\n    :rtype: ```AnnAssign```\n    \"\"\"\n    if isinstance(node, AnnAssign):\n        return node\n    elif isinstance(node, ast.arg):\n        return AnnAssign(\n            annotation=node.annotation,\n            simple=1,\n            target=Name(node.arg, Store(), lineno=None, col_offset=None),\n            col_offset=getattr(node, \"col_offset\", None),\n            end_lineno=getattr(node, \"end_lineno\", None),\n            end_col_offset=getattr(node, \"end_col_offset\", None),\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            lineno=None,\n            value=node.default if getattr(node, \"default\", None) is not None else None,\n        )\n    else:\n        raise NotImplementedError(type(node).__name__)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.emit_arg","title":"emit_arg","text":"<pre><code>emit_arg(node)\n</code></pre> <p>Produce an <code>arg</code> from the input</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ast.arg</code> <p>Something which parses to the form of <code>a=5</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def emit_arg(node):\n    \"\"\"\n    Produce an `arg` from the input\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Something which parses to the form of `a=5`\n    :rtype: ```ast.arg```\n    \"\"\"\n    if isinstance(node, ast.arg):\n        return node\n    elif isinstance(node, AnnAssign) and isinstance(node.target, Name):\n        return set_arg(\n            annotation=node.annotation,\n            arg=node.target.id,\n        )\n    elif (\n        isinstance(node, Assign)\n        and len(node.targets) == 1\n        and isinstance(node.targets[0], Name)\n    ):\n        return set_arg(node.targets[0].id)\n    else:\n        raise NotImplementedError(type(node).__name__)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.find_ast_type","title":"find_ast_type","text":"<pre><code>find_ast_type(node, node_name=None, of_type=ClassDef)\n</code></pre> <p>Finds first AST node of the given type and possibly name</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>Any AST node</p> required <code>node_name</code> <code>Optional[str]</code> <p>Name of AST node. If None, gives first found.</p> required <code>of_type</code> <code>AST</code> <p>Of which type to find</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>Found AST node</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def find_ast_type(node, node_name=None, of_type=ClassDef):\n    \"\"\"\n    Finds first AST node of the given type and possibly name\n\n    :param node: Any AST node\n    :type node: ```AST```\n\n    :param node_name: Name of AST node. If None, gives first found.\n    :type node_name: ```Optional[str]```\n\n    :param of_type: Of which type to find\n    :type of_type: ```AST```\n\n    :return: Found AST node\n    :rtype: ```AST```\n    \"\"\"\n    if isinstance(node, Module):\n        it: Optional[Generator[of_type]] = filter(\n            rpartial(isinstance, of_type), node.body\n        )\n        if node_name is not None:\n            return next(\n                filter(\n                    lambda e: hasattr(e, \"name\") and e.name == node_name,\n                    it,\n                )\n            )\n        matching_nodes = tuple(it)  # type: tuple[of_type, ...]\n        if len(matching_nodes) &gt; 1:  # We could convert every one I guess?\n            raise NotImplementedError()\n        elif matching_nodes:\n            return matching_nodes[0]\n        else:\n            raise TypeError(\n                \"No {type_name!r} in AST\".format(type_name=type(of_type).__name__)\n            )\n    elif isinstance(node, AST):\n        assert node_name is None or not hasattr(node, \"name\") or node.name == node_name\n        return node\n    else:\n        raise NotImplementedError(type(node).__name__)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.find_in_ast","title":"find_in_ast","text":"<pre><code>find_in_ast(search, node)\n</code></pre> <p>Find and return the param from within the value</p> <p>Parameters:</p> Name Type Description Default <code>search</code> <code>list[str]</code> <p>Location within AST of property. Can be top level like <code>['a']</code> for <code>a=5</code> or E.g., <code>['A', 'F']</code> for <code>class A: F</code>, <code>['f', 'g']</code> for <code>def f(g): ...</code></p> required <code>node</code> <code>AST</code> <p>AST node (must have a <code>body</code>)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[AST]</code> <p>AST node that was found, or None if nothing was found</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def find_in_ast(search, node):\n    \"\"\"\n    Find and return the param from within the value\n\n    :param search: Location within AST of property.\n       Can be top level like `['a']` for `a=5` or E.g., `['A', 'F']` for `class A: F`, `['f', 'g']` for `def f(g): ...`\n    :type search: ```list[str]```\n\n    :param node: AST node (must have a `body`)\n    :type node: ```AST```\n\n    :return: AST node that was found, or None if nothing was found\n    :rtype: ```Optional[AST]```\n    \"\"\"\n    if not search or hasattr(node, \"_location\") and node._location == search:\n        return node\n\n    child_node, cursor, current_search = node, node.body, deepcopy(search)\n    while len(current_search):\n        query = current_search.pop(0)\n        if (\n            len(current_search) == 0\n            and hasattr(child_node, \"name\")\n            and child_node.name == query\n        ):\n            return child_node\n\n        for child_node in cursor:\n            if hasattr(child_node, \"_location\") and child_node._location == search:\n                return child_node\n\n            elif isinstance(child_node, FunctionDef):\n                if len(current_search):\n                    query = current_search.pop(0)\n                _cursor = next(\n                    filter(\n                        lambda idx_arg: idx_arg[1].arg == query,\n                        enumerate(child_node.args.args),\n                    ),\n                    None,\n                )\n                if _cursor is not None:\n                    if len(child_node.args.defaults) &gt; _cursor[0]:\n                        setattr(\n                            _cursor[1], \"default\", child_node.args.defaults[_cursor[0]]\n                        )\n                    cursor = _cursor[1]\n                    if len(current_search) == 0:\n                        return cursor\n            elif (\n                isinstance(child_node, AnnAssign)\n                and isinstance(child_node.target, Name)\n                and child_node.target.id == query\n            ):\n                return child_node\n            elif hasattr(child_node, \"name\") and child_node.name == query:\n                cursor = child_node.body\n                break\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.func_arg2param","title":"func_arg2param","text":"<pre><code>func_arg2param(func_arg, default=None)\n</code></pre> <p>Converts a function argument to a param tuple</p> <p>Parameters:</p> Name Type Description Default <code>func_arg</code> <code>ast.arg</code> <p>Function argument</p> required <code>default</code> <code>dict</code> <p>The default value, if None isn't added to returned dict</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def func_arg2param(func_arg, default=None):\n    \"\"\"\n    Converts a function argument to a param tuple\n\n    :param func_arg: Function argument\n    :type func_arg: ```ast.arg```\n\n    :param default: The default value, if None isn't added to returned dict\n    :type default: ```Optional[Any]```\n\n    :return: Name, dict with keys: 'typ', 'doc', 'default'\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    return func_arg.arg, dict(\n        doc=getattr(func_arg, \"type_comment\", None),\n        **dict(\n            typ=(\n                None\n                if func_arg.annotation is None\n                else _to_code(func_arg.annotation).rstrip(\"\\n\")\n            ),\n            **({} if default is None else {\"default\": default}),\n        ),\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_ass_where_name","title":"get_ass_where_name","text":"<pre><code>get_ass_where_name(node, name)\n</code></pre> <p>Find all <code>Assign</code>/<code>AnnAssign</code> in node body where id matches name</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,                      ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]</code> <p>AST node with a '.body'</p> required <code>name</code> <code>id</code> <p>Name to match (matches against <code>id</code> field of <code>Name</code>)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Generator[Union[Assign, AnnAssign]]</code> <p>Generator of all matches names (.value)</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_ass_where_name(node, name):\n    \"\"\"\n    Find all `Assign`/`AnnAssign` in node body where id matches name\n\n    :param node: AST node with a '.body'\n    :type node: ```Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,\n                         ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]```\n\n    :param name: Name to match (matches against `id` field of `Name`)\n    :type name: ```str```\n\n    :return: Generator of all matches names (.value)\n    :rtype: ```Generator[Union[Assign, AnnAssign]]```\n    \"\"\"\n    return (\n        get_value(_node)\n        for _node in node.body\n        if isinstance(_node, Assign)\n        and name\n        in frozenset(\n            map(attrgetter(\"id\"), filter(rpartial(isinstance, Name), _node.targets))\n        )\n        or isinstance(_node, AnnAssign)\n        and get_value(_node.target) == name\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_at_root","title":"get_at_root","text":"<pre><code>get_at_root(node, types)\n</code></pre> <p>Get the imports from a node</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node with .body, probably an <code>ast.Module</code></p> required <code>types</code> <code>tuple[str,...]`</code> <p>The types to search for (uses in an <code>isinstance</code> check)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[Union[]]</code> <p>List of imports. Doesn't handle those within a try/except, condition, or not in root scope</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_at_root(node, types):\n    \"\"\"\n    Get the imports from a node\n\n    :param node: AST node with .body, probably an `ast.Module`\n    :type node: ```AST```\n\n    :param types: The types to search for (uses in an `isinstance` check)\n    :type types: ```tuple[str,...]````\n\n    :return: List of imports. Doesn't handle those within a try/except, condition, or not in root scope\n    :rtype: ```list[Union[]]```\n    \"\"\"\n    assert hasattr(node, \"body\") and isinstance(node.body, (list, tuple))\n    return list(filter(rpartial(isinstance, types), node.body))\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_doc_str","title":"get_doc_str","text":"<pre><code>get_doc_str(node)\n</code></pre> <p>Similar to <code>ast.get_docstring</code> except never <code>clean</code>s and returns <code>None</code> on failure rather than raising</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[str]</code> <p>Docstring if found else None</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_doc_str(node):\n    \"\"\"\n    Similar to `ast.get_docstring` except never `clean`s and returns `None` on failure rather than raising\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Docstring if found else None\n    :rtype: ```Optional[str]```\n    \"\"\"\n    if isinstance(node, (ClassDef, FunctionDef)) and isinstance(node.body[0], Expr):\n        val = get_value(node.body[0])\n        if isinstance(val, (Constant, Str)):\n            return get_value(val)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_function_type","title":"get_function_type","text":"<pre><code>get_function_type(function_def)\n</code></pre> <p>Get the type of the function</p> <p>Parameters:</p> Name Type Description Default <code>function_def</code> <code>FunctionDef</code> <p>AST node for function definition</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Literal['self', 'cls', 'static']</code> <p>Type of target, static is static or global method, others just become first arg</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_function_type(function_def):\n    \"\"\"\n    Get the type of the function\n\n    :param function_def: AST node for function definition\n    :type function_def: ```FunctionDef```\n\n    :return: Type of target, static is static or global method, others just become first arg\n    :rtype: ```Literal['self', 'cls', 'static']```\n    \"\"\"\n    assert isinstance(\n        function_def, FunctionDef\n    ), \"Expected `FunctionDef` got `{type_name}`\".format(\n        type_name=type(function_def).__name__\n    )\n    if (\n        not hasattr(function_def, \"args\")\n        or function_def.args is None\n        or not function_def.args.args\n    ):\n        return \"static\"\n    elif function_def.args.args[0].arg in frozenset((\"self\", \"cls\")):\n        return function_def.args.args[0].arg\n    return \"static\"\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_names","title":"get_names","text":"<pre><code>get_names(node)\n</code></pre> <p>Get name(s) from: - Assign targets - AnnAssign target - Function, AsyncFunction, ClassDef</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Assign, AnnAssign, Function, AsyncFunctionDef, ClassDef]</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Generator[str]</code> <p>All top-level symbols (except those within try/except and if/elif/else blocks)</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_names(node):\n    \"\"\"\n    Get name(s) from:\n    - Assign targets\n    - AnnAssign target\n    - Function, AsyncFunction, ClassDef\n\n    :param node: AST node\n    :type node: ```Union[Assign, AnnAssign, Function, AsyncFunctionDef, ClassDef]```\n\n    :return: All top-level symbols (except those within try/except and if/elif/else blocks)\n    :rtype: ```Generator[str]```\n    \"\"\"\n    if isinstance(node, Assign) and all(map(rpartial(isinstance, Name), node.targets)):\n        return map(attrgetter(\"id\"), node.targets)\n    elif isinstance(node, AnnAssign) and isinstance(node.target, Name):\n        return iter((node.target.id,))\n    elif isinstance(node, (AsyncFunctionDef, FunctionDef, ClassDef)):\n        return iter((node.name,))\n    return iter(())\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_types","title":"get_types","text":"<pre><code>get_types(node)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST|str</code> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Generator[str]</code> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_types(node):\n    \"\"\"\n    :param node:\n    :type node: ```AST|str```\n\n    :rtype: ```Generator[str]```\n    \"\"\"\n    if node is None:\n        return iter(())\n    elif isinstance(node, str):\n        return iter((node,))\n    elif isinstance(node, Name):\n        return iter((node.id,))\n    elif isinstance(node, Subscript):\n        assert isinstance(node.value, Name), type(node.value)\n        if isinstance(node.slice, Name):\n            return iter((node.value.id, node.slice.id))\n        elif isinstance(node.slice, Tuple):\n            return chain.from_iterable(\n                (\n                    (node.value.id,),\n                    (\n                        iter(())\n                        if node.value.id == \"Literal\"\n                        else map(get_value, map(get_value, node.slice.elts))\n                    ),\n                )\n            )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.get_value","title":"get_value","text":"<pre><code>get_value(node)\n</code></pre> <p>Get the value from a Constant or a Str\u2026 or anything with a <code>.value</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Bytes, Constant, Name, Str, UnaryOp]</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Union[str, int, float, bool]]</code> <p>Probably a string, but could be any constant value</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def get_value(node):\n    \"\"\"\n    Get the value from a Constant or a Str\u2026 or anything with a `.value`\n\n    :param node: AST node\n    :type node: ```Union[Bytes, Constant, Name, Str, UnaryOp]```\n\n    :return: Probably a string, but could be any constant value\n    :rtype: ```Optional[Union[str, int, float, bool]]```\n    \"\"\"\n    if isinstance(node, (Bytes, Str)):\n        return node.s\n    elif isinstance(node, Num):\n        return node.n\n    elif isinstance(node, Constant) or hasattr(node, \"value\"):\n        value = node.value\n        return NoneStr if value is None else value\n    # elif isinstance(node, (Tuple, Name)):  # It used to be Index in Python &lt; 3.9\n    elif isinstance(node, UnaryOp) and isinstance(\n        node.operand, (Str, Bytes, Num, Constant, NameConstant)\n    ):\n        return {\"USub\": neg, \"UAdd\": pos, \"not_\": not_, \"Invert\": inv}[\n            type(node.op).__name__\n        ](get_value(node.operand))\n    elif isinstance(node, Name):\n        return node.id\n    else:\n        return node\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.infer_imports","title":"infer_imports","text":"<pre><code>infer_imports(module, modules_to_all=DEFAULT_MODULES_TO_ALL)\n</code></pre> <p>Infer imports from AST nodes (Name|.annotation|.type_comment); in order; these:   - typing   - typing_extensions   - collections.abc   - sqlalchemy   - pydantic</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Union[Module, ClassDef, FunctionDef, AsyncFunctionDef, Assign, AnnAssign]</code> <p>Module, ClassDef, FunctionDef, AsyncFunctionDef, Assign, AnnAssign</p> required <code>modules_to_all</code> <code>tuple[tuple[str, frozenset], ...]</code> <p>Tuple of module_name to all of module; (str) to FrozenSet[str]</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Tuple[Union[Import, ImportFrom], ...]]</code> <p>List of imports</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def infer_imports(module, modules_to_all=DEFAULT_MODULES_TO_ALL):\n    \"\"\"\n    Infer imports from AST nodes (Name|.annotation|.type_comment); in order; these:\n      - typing\n      - typing_extensions\n      - collections.abc\n      - sqlalchemy\n      - pydantic\n\n    :param module: Module, ClassDef, FunctionDef, AsyncFunctionDef, Assign, AnnAssign\n    :type module: ```Union[Module, ClassDef, FunctionDef, AsyncFunctionDef, Assign, AnnAssign]```\n\n    :param modules_to_all: Tuple of module_name to __all__ of module; (str) to FrozenSet[str]\n    :type modules_to_all: ```tuple[tuple[str, frozenset], ...]```\n\n    :return: List of imports\n    :rtype: ```Optional[Tuple[Union[Import, ImportFrom], ...]]```\n    \"\"\"\n    if isinstance(module, (ClassDef, FunctionDef, AsyncFunctionDef, Assign, AnnAssign)):\n        module: Module = Module(body=[module], type_ignores=[], stmt=None)\n    assert isinstance(module, Module), \"Expected `Module` got `{type_name}`\".format(\n        type_name=type(module).__name__\n    )\n\n    def node_to_importable_name(node):\n        \"\"\"\n        :param node: AST node\n        :type node: ```AST```\n\n        :return: importable typename or None\n        :rtype: ```Optional[str]```\n        \"\"\"\n        if getattr(node, \"type_comment\", None) is not None:\n            return (\n                node.type_comment\n                if node.type_comment in simple_types\n                else get_value(\n                    get_value(get_value(ast.parse(node.type_comment).body[0]))\n                )\n            )\n        elif getattr(node, \"annotation\", None) is not None:\n            node = node  # type: Union[AnnAssign, arg]\n            return node.annotation  # cast(node, Union[AnnAssign, arg])\n        elif isinstance(node, Name):\n            return node.id\n        else:\n            return None\n\n    _symbol_to_import: Callable[[str], Optional[TTuple[str, str]]] = partial(\n        symbol_to_import, modules_to_all=modules_to_all\n    )\n\n    # Lots of room for optimisation here; but its probably NP-hard:\n    imports = tuple(\n        map(\n            lambda mod_names: ImportFrom(\n                module=mod_names[0],\n                names=list(\n                    map(\n                        lambda name: alias(\n                            name,\n                            None,\n                            identifier=None,\n                            identifier_name=None,\n                        ),\n                        sorted(frozenset(map(itemgetter(0), mod_names[1]))),\n                    ),\n                ),\n                level=0,\n                identifier=None,\n            ),\n            groupby(\n                sorted(\n                    filter(\n                        None,\n                        map(\n                            # Because there are duplicate names, centralise all import resolution here and order them\n                            _symbol_to_import,\n                            sorted(\n                                frozenset(\n                                    chain.from_iterable(\n                                        filter(\n                                            None,\n                                            map(\n                                                get_types,\n                                                filter(\n                                                    None,\n                                                    map(\n                                                        node_to_importable_name,\n                                                        ast.walk(module),\n                                                    ),\n                                                ),\n                                            ),\n                                        ),\n                                    )\n                                )\n                            ),\n                        ),\n                    ),\n                    key=itemgetter(1),\n                ),\n                key=itemgetter(1),\n            ),\n        )\n    )  # type: tuple[ImportFrom, ...]\n\n    # cdd.sqlalchemy.utils.parse_utils.imports_from(sqlalchemy_class_or_assigns)\n    return imports if imports else None\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.infer_type_and_default","title":"infer_type_and_default","text":"<pre><code>infer_type_and_default(action, default, typ, required)\n</code></pre> <p>Infer the type string from the default and typ</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>Optional[str]</code> <p>Name of the action</p> required <code>default</code> <code>Any</code> <p>Initial default value</p> required <code>typ</code> <code>Optional[str]</code> <p>The type of the argument</p> required <code>required</code> <code>bool</code> <p>Whether to require the argument</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, Any, bool, str]</code> <p>action (e.g., for <code>argparse.Action</code>), default, whether its required, inferred type str</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def infer_type_and_default(action, default, typ, required):\n    \"\"\"\n    Infer the type string from the default and typ\n\n    :param action: Name of the action\n    :type action: ```Optional[str]```\n\n    :param default: Initial default value\n    :type default: ```Any```\n\n    :param typ: The type of the argument\n    :type typ: ```Optional[str]```\n\n    :param required: Whether to require the argument\n    :type required: ```bool```\n\n    :return: action (e.g., for `argparse.Action`), default, whether its required, inferred type str\n    :rtype: ```tuple[str, Any, bool, str]```\n    \"\"\"\n    if code_quoted(default):\n        return _infer_type_and_default_from_quoted(action, default, required, typ)\n    elif type(default).__name__ in simple_types:\n        typ = type(default).__name__\n    elif isinstance(default, AST):\n        action, default, required, typ = _parse_default_from_ast(\n            action, default, required, typ\n        )\n    elif hasattr(default, \"__str__\") and str(default) == \"&lt;required parameter&gt;\":\n        # Special type that PyTorch uses &amp; defines\n        action, default, required, typ = None, None, True, default.__class__.__name__\n    elif isinstance(default, (list, tuple, set)):\n        # `set` actually won't marshall back properly as JSON/YAML doesn't support this type :(\n        action, default, required, typ = _infer_type_and_default_for_list_or_tuple(\n            action, tuple(default) if isinstance(default, set) else default, required\n        )\n    elif isinstance(default, dict):\n        typ = \"loads\"\n        try:\n            default = dumps(default)\n        except TypeError:\n            # YAML is more permissive though less concise, but `loads` from yaml is used so this works\n            default = (\n                dumps(default, ensure_ascii=False)\n                if safe_dump_all is None\n                else safe_dump_all(default)\n            )\n    elif default is None:\n        if \"Optional\" not in (typ or iter(())) and typ not in frozenset(\n            (\"Any\", \"pickle.loads\", \"loads\")\n        ):\n            typ = None\n    elif any(\n        (\n            isinstance(default, type),\n            isfunction(default),\n            isclass(default),\n            contains(\n                frozenset(\n                    map(\n                        \"tf.{}\".format,\n                        (\n                            \"qint16\",\n                            \"qint16_ref\",\n                            \"qint32\",\n                            \"qint32_ref\",\n                            \"qint8\",\n                            \"qint8_ref\",\n                            \"quint16\",\n                            \"quint16_ref\",\n                            \"quint8\",\n                            \"quint8_ref\",\n                            \"bfloat16\",\n                            \"bool\",\n                            \"complex128\",\n                            \"complex64\",\n                            \"double\",\n                            \"float16\",\n                            \"float32\",\n                            \"float64\",\n                            \"half\",\n                            \"int16\",\n                            \"int32\",\n                            \"int64\",\n                            \"int8\",\n                            \"qint16\",\n                            \"qint32\",\n                            \"qint8\",\n                            \"quint16\",\n                            \"quint8\",\n                            \"resource\",\n                            \"string\",\n                            \"uint16\",\n                            \"uint32\",\n                            \"uint64\",\n                            \"uint8\",\n                            \"variant\",\n                        ),\n                    )\n                ),\n                repr(default),\n            ),\n        )\n    ):\n        typ, default, required = \"pickle.loads\", pickle.dumps(default), False\n    else:\n        raise NotImplementedError(\n            \"Parsing type {default_type!s}, which contains {default!r}\".format(\n                default_type=type(default), default=default\n            )\n        )\n\n    return action, default, required, typ\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.is_argparse_add_argument","title":"is_argparse_add_argument","text":"<pre><code>is_argparse_add_argument(node)\n</code></pre> <p>Checks if AST node is a call to <code>argument_parser.add_argument</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the input is the call to <code>argument_parser.add_argument</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def is_argparse_add_argument(node):\n    \"\"\"\n    Checks if AST node is a call to `argument_parser.add_argument`\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Whether the input is the call to `argument_parser.add_argument`\n    :rtype: ```bool```\n    \"\"\"\n    return (\n        isinstance(node, Expr)\n        and isinstance(node.value, Call)\n        and isinstance(node.value.func, Attribute)\n        and node.value.func.attr == \"add_argument\"\n        and isinstance(node.value.func.value, Name)\n        and node.value.func.value.id == \"argument_parser\"\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.is_argparse_description","title":"is_argparse_description","text":"<pre><code>is_argparse_description(node)\n</code></pre> <p>Checks if AST node is <code>argument_parser.description</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the input is the call to <code>argument_parser.description</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def is_argparse_description(node):\n    \"\"\"\n    Checks if AST node is `argument_parser.description`\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Whether the input is the call to `argument_parser.description`\n    :rtype: ```bool```\n    \"\"\"\n    return (\n        isinstance(node, Assign)\n        and len(node.targets) == 1\n        and isinstance(node.targets[0], Attribute)\n        and node.targets[0].attr == \"description\"\n        and isinstance(node.targets[0].value, Name)\n        and node.targets[0].value.id == \"argument_parser\"\n        and isinstance(node.value, (Constant, Str))\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.it2literal","title":"it2literal","text":"<pre><code>it2literal(it)\n</code></pre> <p>Convert a collection of constants into a type annotation</p> <p>Parameters:</p> Name Type Description Default <code>it</code> <code>Union[tuple[Union[str, int, float], ...], list[Union[str, int, float], ...]]</code> <p>collection of constants</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Subscript</code> <p>Subscript Literal for annotation</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def it2literal(it):\n    \"\"\"\n    Convert a collection of constants into a type annotation\n\n    :param it: collection of constants\n    :type it: ```Union[tuple[Union[str, int, float], ...], list[Union[str, int, float], ...]]```\n\n    :return: Subscript Literal for annotation\n    :rtype: ```Subscript```\n    \"\"\"\n    return Subscript(\n        Name(\"Literal\", Load(), lineno=None, col_offset=None),\n        Index(\n            value=(\n                Tuple(\n                    ctx=Load(),\n                    elts=list(map(set_value, it)),\n                    expr=None,\n                    lineno=None,\n                    col_offset=None,\n                )\n                if len(it) &gt; 1\n                else set_value(it[0])\n            )\n        ),\n        Load(),\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.merge_assignment_lists","title":"merge_assignment_lists","text":"<pre><code>merge_assignment_lists(node, name, unique_sort=True)\n</code></pre> <p>Merge multiple same-name lists within the body of a node into one, e.g., if you have multiple <code>__all__</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,                      ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]</code> <p>AST node with a '.body'</p> required <code>name</code> <code>id</code> <p>Name to match (matches against <code>id</code> field of <code>Name</code>)</p> required <code>unique_sort</code> <code>bool</code> <p>Whether to ensure its unique + sorted</p> required Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def merge_assignment_lists(node, name, unique_sort=True):\n    \"\"\"\n    Merge multiple same-name lists within the body of a node into one, e.g., if you have multiple ```__all__```\n\n    :param node: AST node with a '.body'\n    :type node: ```Union[Module, ClassDef, FunctionDef, If, Try, While, With, AsyncFor, AsyncFunctionDef, AsyncWith,\n                         ExceptHandler, Expression, For, IfExp, Interactive, Lambda ]```\n\n    :param name: Name to match (matches against `id` field of `Name`)\n    :type name: ```str```\n\n    :param unique_sort: Whether to ensure its unique + sorted\n    :type unique_sort: ```bool```\n    \"\"\"\n    asses = tuple(get_ass_where_name(node, name))\n\n    # if len(asses) &lt; 2: return\n\n    # Could extract the `AnnAssign` stuff I suppose\u2026\n\n    del_ass_where_name(node, name)\n    elts = map(\n        get_value,\n        chain.from_iterable(\n            map(\n                attrgetter(\"elts\"),\n                asses,\n            )\n        ),\n    )\n    node.body.append(\n        Assign(\n            targets=[Name(\"__all__\", Store(), lineno=None, col_offset=None)],\n            value=List(\n                ctx=Load(),\n                elts=list(\n                    map(set_value, (sorted(frozenset(elts)) if unique_sort else elts))\n                ),\n                expr=None,\n            ),\n            expr=None,\n            lineno=None,\n            **maybe_type_comment,\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.merge_modules","title":"merge_modules","text":"<pre><code>merge_modules(mod0, mod1, remove_imports_from_second=True, deduplicate_names=False)\n</code></pre> <p>Merge modules (removing module docstring from mod1)</p> <p>Parameters:</p> Name Type Description Default <code>mod0</code> <code>Module</code> <p>Module</p> required <code>mod1</code> <code>Module</code> <p>Module</p> required <code>remove_imports_from_second</code> <code>bool</code> <p>Whether to remove global imports from second module</p> required <code>deduplicate_names</code> <code>bool</code> <p>Whether to deduplicate names; names can be function|class|AnnAssign|Assign name</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Merged module (copy)</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def merge_modules(mod0, mod1, remove_imports_from_second=True, deduplicate_names=False):\n    \"\"\"\n    Merge modules (removing module docstring from mod1)\n\n    :param mod0: Module\n    :type mod0: ```Module```\n\n    :param mod1: Module\n    :type mod1: ```Module```\n\n    :param remove_imports_from_second: Whether to remove global imports from second module\n    :type remove_imports_from_second: ```bool```\n\n    :param deduplicate_names: Whether to deduplicate names; names can be function|class|AnnAssign|Assign name\n    :type deduplicate_names: ```bool```\n\n    :return: Merged module (copy)\n    :rtype: ```Module```\n    \"\"\"\n    mod1_body = (\n        mod1.body[1:]\n        if mod1.body and isinstance(get_value(mod1.body[0]), (Str, Constant))\n        else mod1.body\n    )\n\n    new_mod = deepcopy(mod0)\n\n    new_mod.body += (\n        list(\n            filterfalse(\n                rpartial(isinstance, (ImportFrom, Import)),\n                mod1_body,\n            )\n        )\n        if remove_imports_from_second\n        else deepcopy(mod1_body)\n    )\n    # if deduplicate_names:\n    #\n    #     def unique_nodes(node):\n    #         \"\"\"\n    #         :param node: AST node\n    #         :type node: ```AST```\n    #\n    #         :return: node if name is in `seen` set else None; with side-effect of adding to `seen`\n    #         :rtype: ```bool```\n    #         \"\"\"\n    #\n    #         def side_effect_ret(name):\n    #             \"\"\"\n    #             :param name: Name\n    #             :type name: ```str```\n    #\n    #             :return: node if name is in `seen` set else None; with side-effect of adding to `seen`\n    #             :rtype: ```bool```\n    #             \"\"\"\n    #             if name in seen:\n    #                 return None\n    #             else:\n    #                 seen.add(node.name)\n    #                 return node\n    #\n    #         if isinstance(node, (FunctionDef, AsyncFunctionDef, ClassDef)):\n    #             return side_effect_ret(node.name)\n    #         elif isinstance(node, AnnAssign):\n    #             return side_effect_ret(get_value(node.target))\n    #         elif isinstance(node, Assign):\n    #             return any(\n    #                 filter(\n    #                     lambda target: side_effect_ret(get_value(target)), node.targets\n    #                 )\n    #             )\n    #         else:\n    #             return node\n    #\n    #     seen = set()\n    #     new_mod.body = list(filter(None, map(unique_nodes, new_mod.body)))\n\n    return new_mod\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.module_to_all","title":"module_to_all","text":"<pre><code>module_to_all(module_or_filepath)\n</code></pre> <p>From input, create ((\"module_name\", {\"symbol0\", \"symbol1\"}),)</p> <p>Parameters:</p> Name Type Description Default <code>module_or_filepath</code> <code>Union[str, Module]</code> <p>Module or filepath</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>List[str]</code> <p><code>__all__</code> from module (if present) else all symbols in module</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def module_to_all(module_or_filepath):\n    \"\"\"\n    From input, create ((\"module_name\", {\"symbol0\", \"symbol1\"}),)\n\n    :param module_or_filepath: Module or filepath\n    :type module_or_filepath: ```Union[str, Module]```\n\n    :return: `__all__` from module (if present) else all symbols in module\n    :rtype: ```List[str]```\n    \"\"\"\n    assert isinstance(module_or_filepath, (str, Module))\n    if not path.exists(module_or_filepath):\n        module_or_filepath = find_module_filepath(module_or_filepath)\n\n    with open(module_or_filepath, \"rt\") as f:\n        module_or_filepath: Module = cdd.shared.source_transformer.ast_parse(\n            f.read(), filename=module_or_filepath\n        )\n\n    module_or_filepath: Module = module_or_filepath\n\n    # If exists, construct `list[str]` version of `__all__`\n    all_ = list(\n        map(\n            get_value,\n            chain.from_iterable(\n                map(\n                    attrgetter(\"elts\"),\n                    map(get_value, get_ass_where_name(module_or_filepath, \"__all__\")),\n                )\n            ),\n        )\n    )\n\n    return (\n        all_\n        if all_\n        else list(chain.from_iterable(map(get_names, module_or_filepath.body)))\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.node_to_dict","title":"node_to_dict","text":"<pre><code>node_to_dict(node)\n</code></pre> <p>Convert AST node to a dict</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Dict representation</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def node_to_dict(node):\n    \"\"\"\n    Convert AST node to a dict\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Dict representation\n    :rtype: ```dict```\n    \"\"\"\n    return {\n        attr: (\n            lambda val: (\n                type(val)(map(get_value, val))\n                if isinstance(val, (tuple, list))\n                else get_value(val)\n            )\n        )(getattr(node, attr))\n        for attr in dir(node)\n        if not attr.startswith(\"_\") and not attr.endswith((\"lineno\", \"offset\"))\n    }\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.optimise_imports","title":"optimise_imports","text":"<pre><code>optimise_imports(imports)\n</code></pre> <p>Optimise imports involves: - Deduplication of module names - Deduplication of symbols import from module names</p> <p>For more complicated set-ups I recommend use of: - autoflake --remove-all-unused-imports - isort</p> <p>Parameters:</p> Name Type Description Default <code>imports</code> <code>Iterable[ImportFrom]</code> <p><code>ImportFrom</code> nodes</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[ImportFrom]</code> <p><code>ImportFrom</code> nodes</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def optimise_imports(imports):\n    \"\"\"\n    Optimise imports involves:\n    - Deduplication of module names\n    - Deduplication of symbols import from module names\n\n    For more complicated set-ups I recommend use of:\n    - autoflake --remove-all-unused-imports\n    - isort\n\n    :param imports: `ImportFrom` nodes\n    :type imports: ```Iterable[ImportFrom]```\n\n    :return: `ImportFrom` nodes\n    :rtype: ```list[ImportFrom]```\n    \"\"\"\n    seen_pair = set()\n    return [\n        ImportFrom(\n            module=module_name,\n            level=sym[0].level,\n            names=list(\n                map(\n                    lambda al: alias(\n                        name=al.name,\n                        asname=al.asname,\n                        identifier=None,\n                        identifier_name=None,\n                    ),\n                    sym[1],\n                )\n            ),\n        )\n        for module_name, symbols in map(\n            lambda key_group: (\n                key_group[0],\n                filter(\n                    None,\n                    map(\n                        lambda node: (\n                            lambda filtered: (\n                                (\n                                    namedtuple(\"_\", (\"level\",))(node.level),\n                                    filtered,\n                                )\n                                if filtered\n                                else None\n                            )\n                        )(\n                            tuple(\n                                filter(\n                                    None,\n                                    map(\n                                        lambda name_asname_key: (\n                                            None\n                                            if name_asname_key.key in seen_pair\n                                            else (\n                                                seen_pair.add(name_asname_key.key)\n                                                or namedtuple(\"_\", (\"name\", \"asname\"))(\n                                                    name_asname_key.name,\n                                                    name_asname_key.asname,\n                                                )\n                                            )\n                                        ),\n                                        map(\n                                            lambda _alias: namedtuple(\n                                                \"_\", (\"name\", \"asname\", \"key\")\n                                            )(\n                                                _alias.name,\n                                                _alias.asname,\n                                                \"{}{}{}\".format(\n                                                    key_group[0],\n                                                    _alias.name,\n                                                    _alias.asname,\n                                                ),\n                                            ),\n                                            node.names,\n                                        ),\n                                    ),\n                                )\n                            )\n                        ),\n                        key_group[1],\n                    ),\n                ),\n            ),\n            groupby(\n                sorted(\n                    imports,\n                    key=attrgetter(\"module\"),\n                ),\n                key=attrgetter(\"module\"),\n            ),\n        )\n        for sym in symbols\n    ]\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.param2argparse_param","title":"param2argparse_param","text":"<pre><code>param2argparse_param(param, word_wrap=True, emit_default_doc=True)\n</code></pre> <p>Converts a param to an Expr <code>argparse.add_argument</code> call</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Expr</code> <p><code>argparse.add_argument</code> call\u2014with arguments\u2014as an AST node</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def param2argparse_param(param, word_wrap=True, emit_default_doc=True):\n    \"\"\"\n    Converts a param to an Expr `argparse.add_argument` call\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, Dict[str, Any]]```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: `argparse.add_argument` call\u2014with arguments\u2014as an AST node\n    :rtype: ```Expr```\n    \"\"\"\n    name, _param = param\n    del param\n    typ, choices, required, action = (\n        \"str\",\n        None,\n        _param.get(\"default\") is not None,\n        None,\n    )\n    _param.setdefault(\"typ\", \"Any\")\n    action, choices, required, typ, (name, _param) = _resolve_arg(\n        action, choices, (name, _param), required, typ\n    )\n    # is_kwarg = param[0].endswith(\"kwargs\")\n\n    _param.setdefault(\"doc\", \"\")\n    doc, _default = extract_default(_param[\"doc\"], emit_default_doc=emit_default_doc)\n    _action, default, _required, _typ = infer_type_and_default(\n        action,\n        _param.get(\"default\", _default),\n        typ,\n        required=required,\n        # _default, _param, action, required, typ#\n    )\n    if default is None and _param.get(\"default\") == NoneStr:\n        required = False\n    if _action:\n        action = _action\n    if _typ is not None:\n        typ = _typ\n    if typ == \"pickle.loads\":\n        required = False\n    elif typ == \"str\" and action is None:\n        typ = None  # Because `str` is default anyway\n\n    return Expr(\n        Call(\n            args=[set_value(\"--{name}\".format(name=name))],\n            func=Attribute(\n                Name(\"argument_parser\", Load(), lineno=None, col_offset=None),\n                \"add_argument\",\n                Load(),\n                lineno=None,\n                col_offset=None,\n            ),\n            keywords=list(\n                filter(\n                    None,\n                    (\n                        (\n                            typ\n                            if typ is None\n                            else keyword(\n                                arg=\"type\",\n                                value=(\n                                    FALLBACK_ARGPARSE_TYP\n                                    if typ == \"globals().__getitem__\"\n                                    else Name(typ, Load(), lineno=None, col_offset=None)\n                                ),\n                                identifier=None,\n                            )\n                        ),\n                        (\n                            choices\n                            if choices is None\n                            else keyword(\n                                arg=\"choices\",\n                                value=Tuple(\n                                    ctx=Load(),\n                                    elts=list(map(set_value, choices)),\n                                    expr=None,\n                                    lineno=None,\n                                    col_offset=None,\n                                ),\n                                identifier=None,\n                            )\n                        ),\n                        (\n                            action\n                            if action is None\n                            else keyword(\n                                arg=\"action\",\n                                value=set_value(action),\n                                identifier=None,\n                            )\n                        ),\n                        (\n                            keyword(\n                                arg=\"help\",\n                                value=set_value((fill if word_wrap else identity)(doc)),\n                                identifier=None,\n                            )\n                            if doc\n                            else None\n                        ),\n                        (\n                            keyword(\n                                arg=\"required\",\n                                value=set_value(True),\n                                identifier=None,\n                            )\n                            if required is True\n                            else None\n                        ),\n                        (\n                            default\n                            if default is None\n                            else keyword(\n                                arg=\"default\",\n                                value=set_value(default),\n                                identifier=None,\n                            )\n                        ),\n                    ),\n                )\n            ),\n            expr=None,\n            expr_func=None,\n            lineno=None,\n            col_offset=None,\n        ),\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.param2ast","title":"param2ast","text":"<pre><code>param2ast(param)\n</code></pre> <p>Converts a param to an AnnAssign</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[AnnAssign, Assign]</code> <p>AST node for assignment</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def param2ast(param):\n    \"\"\"\n    Converts a param to an AnnAssign\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :return: AST node for assignment\n    :rtype: ```Union[AnnAssign, Assign]```\n    \"\"\"\n    name, _param = param\n    del param\n\n    def get_default_val(val):\n        \"\"\"\n        retrieve default val for application to `.value` of `Assign | AnnAssign`\n\n        :param val: value to retrieve default val for\n        :type val: ```Optional[str]```\n\n        :return: default val for application to `.value` of `Assign | AnnAssign`\n        :rtype: ```Optional[str]```\n        \"\"\"\n        return None if val is None else set_value(None if val == NoneStr else val)\n\n    if \"default\" in _param:\n        if isinstance(_param[\"default\"], (Constant, Str, NameConstant, Num)):\n            _param[\"default\"] = get_value(_param[\"default\"])\n        if _param.get(\"typ\") is None and not getattr(\n            _param[\"default\"], \"__contains__\", iter(())\n        )(\"[\"):\n            _param[\"typ\"] = (\n                \"Optional[Any]\"\n                if _param[\"default\"] == NoneStr\n                else type(_param[\"default\"]).__name__\n            )\n        elif _param.get(\"typ\") == \"Str\":\n            _param[\"typ\"] = \"str\"\n        elif _param.get(\"typ\") in frozenset((\"Constant\", \"NameConstant\", \"Num\")):\n            _param[\"typ\"] = \"object\"\n    if \"typ\" in _param and needs_quoting(_param[\"typ\"]):\n        default = (\n            _param.get(\"default\")\n            if _param.get(\"default\") in (None, NoneStr)\n            else quote(_param[\"default\"])\n        )\n        return AnnAssign(\n            annotation=(\n                Name(_param[\"typ\"], Load(), lineno=None, col_offset=None)\n                if _param[\"typ\"] in simple_types\n                else get_value(ast.parse(_param[\"typ\"]).body[0])\n            ),\n            simple=1,\n            target=Name(name, Store(), lineno=None, col_offset=None),\n            value=get_default_val(default),\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            col_offset=None,\n            lineno=None,\n        )\n    if _param.get(\"typ\") is None:\n        return Assign(\n            annotation=None,\n            simple=1,\n            targets=[Name(name, Store(), lineno=None, col_offset=None)],\n            value=(lambda val: set_value(val) if val is None else val)(\n                get_default_val(_param.get(\"default\"))\n            ),\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            lineno=None,\n            col_offset=None,\n            **maybe_type_comment,\n        )\n    elif _param[\"typ\"] in simple_types:\n        return AnnAssign(\n            annotation=Name(_param[\"typ\"], Load(), lineno=None, col_offset=None),\n            simple=1,\n            target=Name(name, Store(), lineno=None, col_offset=None),\n            value=get_default_val(_param.get(\"default\")),\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            col_offset=None,\n            lineno=None,\n        )\n    elif _param[\"typ\"] == \"dict\" or _param[\"typ\"].startswith(\"*\"):\n        return AnnAssign(\n            annotation=set_slice(Name(\"dict\", Load(), lineno=None, col_offset=None)),\n            simple=1,\n            target=Name(name, Store(), lineno=None, col_offset=None),\n            value=Dict(keys=[], values=_param.get(\"default\", []), expr=None),\n            expr=None,\n            expr_target=None,\n            expr_annotation=None,\n            col_offset=None,\n            lineno=None,\n        )\n    else:\n        return _generic_param2ast((name, _param))\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.parse_to_scalar","title":"parse_to_scalar","text":"<pre><code>parse_to_scalar(node)\n</code></pre> <p>Parse the input to a scalar</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Any</code> <p>Any value</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[str, int, float, complex, None]</code> <p>Scalar</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def parse_to_scalar(node):\n    \"\"\"\n    Parse the input to a scalar\n\n    :param node: Any value\n    :type node: ```Any```\n\n    :return: Scalar\n    :rtype: ```Union[str, int, float, complex, None]```\n    \"\"\"\n    if isinstance(node, (int, float, complex, str, type(None))):\n        return node\n    elif isinstance(node, (Constant, Expr, Str, Num)):\n        return get_value(node)\n    elif isinstance(node, ast.AST):\n        return _to_code(node).rstrip(\"\\n\")\n    else:\n        raise NotImplementedError(\n            \"Converting this to scalar: {node!r}\".format(node=node)\n        )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.set_arg","title":"set_arg","text":"<pre><code>set_arg(arg, annotation=None)\n</code></pre> <p>In Python 3.8 <code>expr</code> and <code>type_comment</code> need to be set on arg. This function handles constructs an <code>ast.arg</code> handling that issue.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>Optional[str]</code> <p>The argument name</p> required <code>annotation</code> <code>Optional[ast.AST]</code> <p>The argument's annotation</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ast.arg</code> <p>The constructed <code>ast.arg</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def set_arg(arg, annotation=None):\n    \"\"\"\n    In Python 3.8 `expr` and `type_comment` need to be set on arg.\n    This function handles constructs an `ast.arg` handling that issue.\n\n    :param arg: The argument name\n    :type arg: ```Optional[str]```\n\n    :param annotation: The argument's annotation\n    :type annotation: ```Optional[ast.AST]```\n\n    :return: The constructed ```ast.arg```\n    :rtype: ```ast.arg```\n    \"\"\"\n    return ast.arg(\n        arg=arg,\n        annotation=annotation,\n        identifier_arg=None,\n        lineno=None,\n        col_offset=None,\n        **dict(expr=None, **maybe_type_comment) if PY_GTE_3_8 else {},\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.set_docstring","title":"set_docstring","text":"<pre><code>set_docstring(doc_str, empty, node)\n</code></pre> <p>Set docstring on node that can have a docstring. If doc_str is empty, the doc_str node is removed.</p> <p>Parameters:</p> Name Type Description Default <code>doc_str</code> <code>Optional[str]</code> <p>Docstring</p> required <code>empty</code> <code>bool</code> <p>Whether the doc_str is empty (micro-optimization)</p> required <code>node</code> <code>Union[Module, AsyncFunctionDef, FunctionDef, ClassDef]</code> <p>AST node to set the docstring on</p> required Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def set_docstring(doc_str, empty, node):\n    \"\"\"\n    Set docstring on node that can have a docstring. If doc_str is empty, the doc_str node is removed.\n\n    :param doc_str: Docstring\n    :type doc_str: ```Optional[str]```\n\n    :param empty: Whether the doc_str is empty (micro-optimization)\n    :type empty: ```bool```\n\n    :param node: AST node to set the docstring on\n    :type node: ```Union[Module, AsyncFunctionDef, FunctionDef, ClassDef]```\n    \"\"\"\n    (\n        node.body.__setitem__\n        if isinstance(node.body[0], Expr)\n        and isinstance(get_value(node.body[0].value), str)\n        else node.body.insert\n    )(\n        0,\n        Expr(set_value(doc_str), lineno=None, col_offset=None),\n    )\n    if empty or get_value(node.body[0].value).isspace():\n        del node.body[0]\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.set_slice","title":"set_slice","text":"<pre><code>set_slice(node)\n</code></pre> <p>In Python 3.9 there's a new ast parser (PEG) that no longer wraps things in Index. This function handles this issue.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ast.AST</code> <p>An AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[ast.AST, Index]</code> <p>Original node, possibly wrapped in an <code>Index</code></p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def set_slice(node):\n    \"\"\"\n    In Python 3.9 there's a new ast parser (PEG) that no longer wraps things in Index.\n    This function handles this issue.\n\n    :param node: An AST node\n    :type node: ```ast.AST```\n\n    :return: Original node, possibly wrapped in an ```Index```\n    :rtype: ```Union[ast.AST, Index]```\n    \"\"\"\n    return node if PY_GTE_3_9 else Index(node)\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.set_value","title":"set_value","text":"<pre><code>set_value(value, kind=None)\n</code></pre> <p>Creates a <code>Constant</code> on Python &gt;= 3.8 otherwise more specific AST type</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>AST node</p> required <code>kind</code> <code>Optional[Any]</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[Constant, Num, Str, NameConstant]</code> <p>Probably a string, but could be any constant value</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def set_value(value, kind=None):\n    \"\"\"\n    Creates a `Constant` on Python &gt;= 3.8 otherwise more specific AST type\n\n    :param value: AST node\n    :type value: ```Any```\n\n    :param kind: AST node\n    :type kind: ```Optional[Any]```\n\n    :return: Probably a string, but could be any constant value\n    :rtype: ```Union[Constant, Num, Str, NameConstant]```\n    \"\"\"\n    if (\n        value is not None\n        and isinstance(value, str)\n        and len(value) &gt; 2\n        and value[0] + value[-1] in frozenset(('\"\"', \"''\"))\n    ):\n        value = value[1:-1]\n    return (\n        Constant(kind=kind, value=value, constant_value=None, string=None)\n        if PY_GTE_3_8\n        else (\n            Str(s=value, constant_value=None, string=None, col_offset=None, lineno=None)\n            if isinstance(value, str)\n            else (\n                Num(n=value, constant_value=None, string=None)\n                if not isinstance(value, bool)\n                and isinstance(value, (int, float, complex))\n                else NameConstant(\n                    value=value,\n                    constant_value=None,\n                    string=None,\n                    lineno=None,\n                    col_offset=None,\n                )\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.symbol_to_import","title":"symbol_to_import","text":"<pre><code>symbol_to_import(symbol, modules_to_all)\n</code></pre> <p>Resolve symbol to module</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>symbol to look for within various modules</p> required <code>modules_to_all</code> <code>tuple[tuple[str, frozenset], ...]</code> <p>Tuple of module_name to all of module; (str) to FrozenSet[str]</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Tuple[str, str]]</code> <p>(symbol, module) if name in module else None</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def symbol_to_import(\n    symbol,\n    modules_to_all,\n):\n    \"\"\"\n    Resolve symbol to module\n\n    :param symbol: symbol to look for within various modules\n    :type symbol: ```str```\n\n    :param modules_to_all: Tuple of module_name to __all__ of module; (str) to FrozenSet[str]\n    :type modules_to_all: ```tuple[tuple[str, frozenset], ...]```\n\n    :return: (symbol, module) if name in module else None\n    :rtype: ```Optional[Tuple[str, str]]```\n    \"\"\"\n    return next(\n        ((symbol, module) for (module, all_) in modules_to_all if symbol in all_), None\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.to_annotation","title":"to_annotation","text":"<pre><code>to_annotation(typ)\n</code></pre> <p>Converts the typ to an annotation</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>str</code> <p>A string representation of the type to annotate with. Else return give identity.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>The annotation as a <code>Name</code> (usually) or else some more complex type</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def to_annotation(typ):\n    \"\"\"\n    Converts the typ to an annotation\n\n    :param typ: A string representation of the type to annotate with. Else return give identity.\n    :type typ: ```Union[str, AST]```\n\n    :return: The annotation as a `Name` (usually) or else some more complex type\n    :rtype: ```AST```\n    \"\"\"\n    if isinstance(typ, AST):\n        return typ\n    return (\n        None\n        if typ in none_types\n        else (\n            Name(typ, Load(), lineno=None, col_offset=None)\n            if typ in simple_types\n            else get_value(\n                (\n                    lambda parsed: (\n                        parsed.body[0] if getattr(parsed, \"body\", None) else parsed\n                    )\n                )(ast.parse(typ))\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.ast_utils.to_type_comment","title":"to_type_comment","text":"<pre><code>to_type_comment(node)\n</code></pre> <p>Convert annotation to a type comment</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>str</code> <p>AST node with a '.annotation' or Name or str</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>type_comment</p> Source code in <code>cdd/shared/ast_utils.py</code> <pre><code>def to_type_comment(node):\n    \"\"\"\n    Convert annotation to a type comment\n\n    :param node: AST node with a '.annotation' or Name or str\n    :type node: ```Union[Name, str, AnnAssign, arg, arguments]```\n\n    :return: type_comment\n    :rtype: ```str```\n    \"\"\"\n    return (\n        node.id\n        if isinstance(node, Name)\n        else (\n            node\n            if isinstance(node, str) or not hasattr(node, \"annotation\")\n            else _to_code(node.annotation).strip()\n        )\n    )\n</code></pre>"},{"location":"api/#cddsharedconformance","title":"<code>cdd.shared.conformance</code>","text":""},{"location":"api/#cdd.shared.conformance","title":"cdd.shared.conformance","text":"<p>Given the truth, show others the path</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.conformance.ground_truth","title":"ground_truth","text":"<pre><code>ground_truth(args, truth_file)\n</code></pre> <p>There is but one truth. Conform.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Namespace with the values of the CLI arguments</p> required <code>truth_file</code> <code>str</code> <p>contains the filename of the one true source</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>OrderedDict</code> <p>Filenames and whether they were changed</p> Source code in <code>cdd/shared/conformance.py</code> <pre><code>def ground_truth(args, truth_file):\n    \"\"\"\n    There is but one truth. Conform.\n\n    :param args: Namespace with the values of the CLI arguments\n    :type args: ```Namespace```\n\n    :param truth_file: contains the filename of the one true source\n    :type truth_file: ```str```\n\n    :return: Filenames and whether they were changed\n    :rtype: ```OrderedDict```\n    \"\"\"\n    arg2parse_emit_type = {\n        \"argparse_function\": (\n            cdd.argparse_function.parse.argparse_ast,\n            cdd.argparse_function.emit.argparse_function,\n            FunctionDef,\n        ),\n        \"class\": (cdd.class_.parse.class_, cdd.class_.emit.class_, ClassDef),\n        \"function\": (\n            cdd.function.parse.function,\n            cdd.function.emit.function,\n            FunctionDef,\n        ),\n    }\n\n    parse_func, emit_func, type_wanted = arg2parse_emit_type[args.truth]\n    search: List[str] = _get_name_from_namespace(args, args.truth).split(\".\")\n\n    with open(truth_file, \"rt\") as f:\n        true_ast = ast_parse(f.read(), filename=truth_file)\n\n    original_node = find_in_ast(search, true_ast)\n    gold_ir: IntermediateRepr = parse_func(\n        original_node,\n        **_default_options(node=original_node, search=search, type_wanted=type_wanted)()\n    )\n\n    effect = OrderedDict()\n    # filter(lambda arg: arg != args.truth, arg2parse_emit_type.keys()):\n    for fun_name, (parse_func, emit_func, type_wanted) in arg2parse_emit_type.items():\n        search = list(strip_split(_get_name_from_namespace(args, fun_name), \".\"))\n\n        filenames = getattr(args, pluralise(fun_name))\n        assert isinstance(\n            filenames, (list, tuple)\n        ), \"Expected `Union[list, tuple]` got `{type_name}`\".format(\n            type_name=type(filenames).__name__\n        )\n\n        effect.update(\n            map(\n                lambda filename: _conform_filename(\n                    filename=filename,\n                    search=search,\n                    emit_func=partial(emit_func, word_wrap=args.no_word_wrap is None),\n                    replacement_node_ir=gold_ir,\n                    type_wanted=type_wanted,\n                ),\n                filenames,\n            )\n        )\n\n    return effect\n</code></pre>"},{"location":"api/#cddsharedcst","title":"<code>cdd.shared.cst</code>","text":""},{"location":"api/#cdd.shared.cst","title":"cdd.shared.cst","text":"<p>Concrete Syntax Tree for Python 3.6+ source code</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.cst.cst_parse","title":"cst_parse","text":"<pre><code>cst_parse(source)\n</code></pre> <p>Parse Python source lines into a Concrete Syntax Tree</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Python source code</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[Any]</code> <p>List of <code>namedtuple</code>s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> Source code in <code>cdd/shared/cst.py</code> <pre><code>def cst_parse(source):\n    \"\"\"\n    Parse Python source lines into a Concrete Syntax Tree\n\n    :param source: Python source code\n    :type source: ```str```\n\n    :return: List of `namedtuple`s with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :rtype: ```list[Any]```\n    \"\"\"\n    scanned = cst_scanner(source)\n    parsed = cst_parser(scanned)\n    return parsed\n</code></pre>"},{"location":"api/#cddsharedcst_utils","title":"<code>cdd.shared.cst_utils</code>","text":""},{"location":"api/#cdd.shared.cst_utils","title":"cdd.shared.cst_utils","text":"<p>Concrete Syntax Tree utility functions</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.cst_utils.cst_parse_one_node","title":"cst_parse_one_node","text":"<pre><code>cst_parse_one_node(statement, state)\n</code></pre> <p>Parse one statement into a CST node</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>str</code> <p>Statement that was scanned from Python source code</p> required <code>state</code> <code>dict</code> <p>Number of lines between runs in <code>acc</code> key; <code>prev_node</code>; <code>parsed</code></p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>NamedTuple</code> <p>NamedTuple with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>@set_prev_node\ndef cst_parse_one_node(statement, state):\n    \"\"\"\n    Parse one statement into a CST node\n\n    :param statement: Statement that was scanned from Python source code\n    :type statement: ```str```\n\n    :param state: Number of lines between runs in `acc` key; `prev_node`; `parsed`\n    :type state: ```dict```\n\n    :return: NamedTuple with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :rtype: ```NamedTuple```\n    \"\"\"\n    prev_acc = state[\"acc\"]\n    state[\"acc\"] += statement.count(\"\\n\")\n\n    statement_stripped = statement.strip()\n\n    words = tuple(filter(None, map(str.strip, statement_stripped.split(\" \"))))\n\n    common_kwargs = dict(\n        line_no_start=prev_acc,\n        line_no_end=state[\"acc\"],\n        value=statement,\n    )\n\n    if len(statement_stripped) &gt; 5:\n        is_single_quote = (statement_stripped[:3], statement_stripped[-3:]) == (\n            \"'''\",\n            \"'''\",\n        )\n        is_double_quote = not is_single_quote and (\n            statement_stripped[:3],\n            statement_stripped[-3:],\n        ) == (\n            '\"\"\"',\n            '\"\"\"',\n        )\n        if is_single_quote or is_double_quote:\n            return TripleQuoted(\n                **common_kwargs,\n                is_double_q=is_double_quote,\n                is_docstr=isinstance(\n                    state[\"prev_node\"], (ClassDefinitionStart, FunctionDefinitionStart)\n                ),\n            )\n\n    if words:\n        if len(words) &gt; 1:\n            name: Optional[str] = get_construct_name(words)\n            if name is not None:\n                return (\n                    ClassDefinitionStart\n                    if words[0] == \"class\"\n                    else FunctionDefinitionStart\n                )(**common_kwargs, name=name)\n\n        return infer_cst_type(statement_stripped, words)(**common_kwargs)\n\n    return UnchangingLine(**common_kwargs)\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.cst_parser","title":"cst_parser","text":"<pre><code>cst_parser(scanned)\n</code></pre> <p>Checks if what has been scanned (stack) is ready for the <code>scanned</code> array Add then clear stack if ready else do nothing with both</p> <p>Parameters:</p> Name Type Description Default <code>scanned</code> <code>list[str]</code> <p>List of statements observed</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[NamedTuple]</code> <p>Parse of scanned statements. One dimensional.</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def cst_parser(scanned):\n    \"\"\"\n    Checks if what has been scanned (stack) is ready for the `scanned` array\n    Add then clear stack if ready else do nothing with both\n\n    :param scanned: List of statements observed\n    :type scanned: ```list[str]```\n\n    :return: Parse of scanned statements. One dimensional.\n    :rtype: ```tuple[NamedTuple]```\n    \"\"\"\n    state = {\n        \"acc\": 1,\n        \"prev_node\": UnchangingLine(line_no_start=None, line_no_end=None, value=\"\"),\n        \"parsed\": [],\n    }\n    # return accumulate(scanned, partial(cst_parse_one_node, state=state), initial=[])\n    deque(map(partial(cst_parse_one_node, state=state), scanned), maxlen=0)\n    return tuple(state[\"parsed\"])\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.cst_scan","title":"cst_scan","text":"<pre><code>cst_scan(scanned, stack)\n</code></pre> <p>Checks if what has been scanned (stack) is ready for the <code>scanned</code> array Add then clear stack if ready else do nothing with both</p> <p>Parameters:</p> Name Type Description Default <code>scanned</code> <code>list[str]</code> <p>List of statements observed</p> required <code>stack</code> <code>list[str]</code> <p>List of characters observed</p> required Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def cst_scan(scanned, stack):\n    \"\"\"\n    Checks if what has been scanned (stack) is ready for the `scanned` array\n    Add then clear stack if ready else do nothing with both\n\n    :param scanned: List of statements observed\n    :type scanned: ```list[str]```\n\n    :param stack: List of characters observed\n    :type stack: ```list[str]```\n    \"\"\"\n    statement = \"\".join(stack)\n    statement_stripped = statement.strip()\n\n    is_comment = statement_stripped.startswith(\"#\")\n    if statement_stripped.endswith(\"\\\\\"):\n        has_triple_quotes = is_other_statement = False\n    else:\n        has_triple_quotes = is_triple_quoted(statement_stripped)\n        is_other_statement = all(\n            (\n                statement_stripped,\n                balanced_parentheses(statement_stripped),\n                not statement_stripped.startswith(\"@\")\n                or statement_stripped.endswith(\":\"),\n                not statement_stripped.startswith(\"'''\"),\n                not statement_stripped.startswith('\"\"\"'),\n            )\n        )\n\n    statement_found = is_comment or has_triple_quotes or is_other_statement\n    if statement_found:\n        if is_comment:\n            scanned.append(statement)\n            stack.clear()\n        elif is_other_statement:\n            expression = []\n\n            def add_and_clear(the_expression_str, expr, scanned_tokens, the_stack):\n                \"\"\"\n                Add the found statement and clear the stacks\n\n                :param the_expression_str: Expression string\n                :type the_expression_str: ```str```\n\n                :param expr: The expression\n                :type expr: ```list[str]```\n\n                :param scanned_tokens: Scanned tokens\n                :type scanned_tokens: ```list[str]```\n\n                :param the_stack: The current stack\n                :type the_stack: ```list[str]```\n\n                \"\"\"\n                scanned_tokens.append(the_expression_str)\n                expr.clear()\n                the_stack.clear()\n\n            expression_str: str = \"\"\n            for idx, ch in enumerate(statement):\n                expression.append(ch)\n                expression_str: str = \"\".join(expression)\n                expression_stripped = expression_str.strip()\n\n                if (\n                    is_triple_quoted(expression_stripped)\n                    or expression_stripped.startswith(\"#\")\n                    and expression_str.endswith(\"\\n\")\n                ):\n                    add_and_clear(expression_str, expression, scanned, stack)\n                    # Single comment should be picked up\n                elif balanced_parentheses(expression_stripped):\n                    if (\n                        expression_str.endswith(\"\\n\")\n                        and not expression_stripped.endswith(\"\\\\\")\n                        and (\n                            not expression_stripped.endswith(\":\")\n                            or \"class\" not in expression_stripped\n                            and \"def\" not in expression_stripped\n                        )\n                        and not expression_str.isspace()\n                        and not expression_stripped.startswith(\"@\")\n                    ):\n                        add_and_clear(expression_str, expression, scanned, stack)\n                    else:\n                        words = tuple(\n                            filter(None, map(str.strip, expression_stripped.split(\" \")))\n                        )\n                        if \"def\" in words or \"class\" in words:\n                            if words[-1].endswith(\":\") and balanced_parentheses(\n                                expression_stripped\n                            ):\n                                add_and_clear(\n                                    expression_str, expression, scanned, stack\n                                )\n                        # elif \";\"\n            if expression:\n                add_and_clear(expression_str, expression, scanned, stack)\n            # Longest matching pattern should be parsed out but this does shortest^\n        else:\n            scanned.append(statement)\n            stack.clear()\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.cst_scanner","title":"cst_scanner","text":"<pre><code>cst_scanner(source)\n</code></pre> <p>Reduce source code into chunks useful for parsing. These chunks include newlines and the array is one dimensional.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Python source code</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[str]</code> <p>List of scanned source code</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def cst_scanner(source):\n    \"\"\"\n    Reduce source code into chunks useful for parsing.\n    These chunks include newlines and the array is one dimensional.\n\n    :param source: Python source code\n    :type source: ```str```\n\n    :return: List of scanned source code\n    :rtype: ```list[str]```\n    \"\"\"\n    scanned, stack = [], []\n    for idx, ch in enumerate(source):\n        if ch == \"\\n\":  # in frozenset((\"\\n\", \":\", \";\", '\"\"\"', \"'''\", '#')):\n            cst_scan(scanned, stack)\n        stack.append(ch)\n    cst_scan(scanned, stack)\n    if stack:\n        scanned.append(\"\".join(stack))\n    return scanned\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.get_construct_name","title":"get_construct_name","text":"<pre><code>get_construct_name(words)\n</code></pre> <p>Find the construct name, currently works for: - AsyncFunctionDef - FunctionDef - ClassDef</p> <p>Parameters:</p> Name Type Description Default <code>words</code> <code>tuple[str]</code> <p>Tuple of words (no whitespace)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[str]</code> <p>Name of construct if found else None</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def get_construct_name(words):\n    \"\"\"\n    Find the construct name, currently works for:\n    - AsyncFunctionDef\n    - FunctionDef\n    - ClassDef\n\n    :param words: Tuple of words (no whitespace)\n    :type words: ```tuple[str]```\n\n    :return: Name of construct if found else None\n    :rtype: ```Optional[str]```\n    \"\"\"\n    for idx, word in enumerate(words):\n        if len(words) &gt; idx + 1:\n            if word == \"def\":\n                return words[idx + 1][: words[idx + 1].find(\"(\")]\n            elif word == \"class\":\n                end_idx = (\n                    lambda _end_idx: (\n                        words[idx + 1].find(\":\") if _end_idx == -1 else _end_idx\n                    )\n                )(words[idx + 1].find(\"(\"))\n                return words[idx + 1][:end_idx]\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.infer_cst_type","title":"infer_cst_type","text":"<pre><code>infer_cst_type(statement_stripped, words)\n</code></pre> <p>Infer the CST type. This is the most important function of the CST parser!</p> <p>Parameters:</p> Name Type Description Default <code>statement_stripped</code> <code>str</code> <p>Original scanned statement minus both ends of whitespace</p> required <code>words</code> <code>Iterable[str]</code> <p>List of whitespace stripped and empty-str removed words from original statement</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>NamedTuple</code> <p>CST type\u2026 a NamedTuple with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def infer_cst_type(statement_stripped, words):\n    \"\"\"\n    Infer the CST type. This is the most important function of the CST parser!\n\n    :param statement_stripped: Original scanned statement minus both ends of whitespace\n    :type statement_stripped: ```str```\n\n    :param words: List of whitespace stripped and empty-str removed words from original statement\n    :type words: ```Iterable[str]```\n\n    :return: CST type\u2026 a NamedTuple with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n    :rtype: ```NamedTuple```\n    \"\"\"\n    if statement_stripped.startswith(\"[\"):\n        return ListCompStatement\n    elif statement_stripped.startswith(\"{\"):\n        # Won't work with nested dict inside a SetExpr\n        if \":\" in statement_stripped:\n            return DictExprStatement\n        return SetExprStatement\n    elif statement_stripped.startswith(\"(\"):\n        return GenExprStatement\n\n    for word in words:\n        if word in contains2statement:\n            return contains2statement[word]\n\n    if any(aug_assign in statement_stripped for aug_assign in augassign):\n        return AugAssignment\n\n    statement_frozenset = frozenset(statement_stripped)\n    for key, constructor in multicontains2statement:\n        if statement_frozenset &amp; key == key:\n            return constructor\n\n    if any(math_operator in statement_stripped for math_operator in math_operators):\n        return ExprStatement\n\n    elif \"(\" in statement_frozenset:\n        return CallStatement\n\n    return UnchangingLine  # or: raise NotImplementedError(repr(statement_stripped))\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.reindent_block_with_pass_body","title":"reindent_block_with_pass_body","text":"<pre><code>reindent_block_with_pass_body(s)\n</code></pre> <p>Reindent block (e.g., function definition) and give it a <code>pass</code> body</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Block defining string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Reindented string with <code>pass</code> body</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def reindent_block_with_pass_body(s):\n    \"\"\"\n    Reindent block (e.g., function definition) and give it a `pass` body\n\n    :param s: Block defining string\n    :type s: ```str```\n\n    :return: Reindented string with `pass` body\n    :rtype: ```str```\n    \"\"\"\n    return \"{block_def} pass\".format(\n        block_def=\"\\n\".join(\n            map(\n                str.lstrip,\n                s.split(\"\\n\"),\n            )\n        ).replace(tab, \"\", 1)\n    )\n</code></pre>"},{"location":"api/#cdd.shared.cst_utils.set_prev_node","title":"set_prev_node","text":"<pre><code>set_prev_node(function)\n</code></pre> <p>Store the result of the current function run into the <code>prev_node</code> attribute</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[str, dict], NamedTuple]</code> <p>The <code>cst_parse_one_node</code> function</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Callable[[], Callable[[str, dict], NamedTuple]]</code> <p>Wrapped function</p> Source code in <code>cdd/shared/cst_utils.py</code> <pre><code>def set_prev_node(function):\n    \"\"\"\n    Store the result of the current function run into the `prev_node` attribute\n\n    :param function: The `cst_parse_one_node` function\n    :type function: ```Callable[[str, dict], NamedTuple]```\n\n    :return: Wrapped function\n    :rtype: ```Callable[[], Callable[[str, dict], NamedTuple]]```\n    \"\"\"\n\n    @wraps(function)\n    def wrapper(statement, state):\n        \"\"\"\n        Store the result of parsing one statement into a CST node in the `prev_node` key of the `state` dict\n\n        :param statement: Statement that was scanned from Python source code\n        :type statement: ```str```\n\n        :param state: Number of lines between runs in `acc` key; `prev_node`\n        :type state: ```dict```\n\n        :return: NamedTuple with at least (\"line_no_start\", \"line_no_end\", \"value\") attributes\n        :rtype: ```NamedTuple```\n        \"\"\"\n        state[\"prev_node\"] = function(statement, state)\n        state[\"parsed\"].append(state[\"prev_node\"])\n        return state[\"prev_node\"]\n\n    return wrapper\n</code></pre>"},{"location":"api/#cddshareddefaults_utils","title":"<code>cdd.shared.defaults_utils</code>","text":""},{"location":"api/#cdd.shared.defaults_utils","title":"cdd.shared.defaults_utils","text":"<p>Functions to handle default parameterisation</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.defaults_utils.ast_parse_fix","title":"ast_parse_fix","text":"<pre><code>ast_parse_fix(s)\n</code></pre> <p>Hack to resolve unbalanced parentheses SyntaxError acquired from PyTorch parsing TODO: remove</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to parse</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>Value</p> Source code in <code>cdd/shared/defaults_utils.py</code> <pre><code>def ast_parse_fix(s):\n    \"\"\"\n    Hack to resolve unbalanced parentheses SyntaxError acquired from PyTorch parsing\n    TODO: remove\n\n    :param s: String to parse\n    :type s: ```str```\n\n    :return: Value\n    \"\"\"\n    # return ast.parse(s).body[0].value\n    balanced = (s.count(\"[\") + s.count(\"]\")) &amp; 1 == 0\n    return ast.parse(s if balanced else \"{}]\".format(s)).body[0].value\n</code></pre>"},{"location":"api/#cdd.shared.defaults_utils.extract_default","title":"extract_default","text":"<pre><code>extract_default(line, rstrip_default=True, default_search_announce=None, typ=None, emit_default_doc=True)\n</code></pre> <p>Extract a tuple of (doc, default) from a doc line</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Example - \"dataset. Defaults to mnist\"</p> <code>mnist</code> <code>rstrip_default</code> <code>bool</code> <p>Whether to rstrip whitespace, newlines, and '.' from the default</p> required <code>default_search_announce</code> <code>Optional[Union[str, Iterable[str]]]</code> <p>Default text(s) to look for. If None, uses default specified in default_utils.</p> required <code>typ</code> <code>float</code> <p>The type of the default value, useful to disambiguate <code>25</code> the float from  <code>25</code> the float</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, Optional[str]]</code> <p>Example - (\"dataset. Defaults to mnist\", \"mnist\") if emit_default_doc else (\"dataset\", \"mnist\")</p> Source code in <code>cdd/shared/defaults_utils.py</code> <pre><code>def extract_default(\n    line,\n    rstrip_default=True,\n    default_search_announce=None,\n    typ=None,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Extract a tuple of (doc, default) from a doc line\n\n    :param line: Example - \"dataset. Defaults to mnist\"\n    :type line: ```str```\n\n    :param rstrip_default: Whether to rstrip whitespace, newlines, and '.' from the default\n    :type rstrip_default: ```bool```\n\n    :param default_search_announce: Default text(s) to look for. If None, uses default specified in default_utils.\n    :type default_search_announce: ```Optional[Union[str, Iterable[str]]]```\n\n    :param typ: The type of the default value, useful to disambiguate `25` the float from  `25` the float\n    :type typ: ```Optional[str]```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Example - (\"dataset. Defaults to mnist\", \"mnist\") if emit_default_doc else (\"dataset\", \"mnist\")\n    :rtype: ```tuple[str, Optional[str]]```\n    \"\"\"\n    if line is None:\n        return line, line\n\n    default_search_announce_paren, default_search_announce = (\n        lambda _default_search_announce: (\n            map(partial(str.format, \"({}\"), _default_search_announce),\n            _default_search_announce,\n        )\n    )(\n        DEFAULTS_TO_VARIANTS\n        if default_search_announce is None\n        else (\n            (default_search_announce,)\n            if isinstance(default_search_announce, str)\n            else default_search_announce\n        )\n    )\n\n    _start_idx, _end_idx, default_end_offset = None, None, None\n    for idx, _default_search_announce in enumerate(\n        (default_search_announce_paren, default_search_announce)\n    ):\n        _start_idx, _end_idx, _found = location_within(\n            line,\n            _default_search_announce,\n            cmp=lambda a, b: eq(*map(str.casefold, (a, b))),\n        )\n\n        if idx == 0:\n            if _start_idx != -1:\n                _start_idx += 1  # eat '('\n                default_end_offset = (\n                    -1 if line[-1] == \")\" else -2 if line[-2:] == \").\" else 0\n                )  # eat ')', ').'\n                break\n        elif _start_idx &lt; 0:\n            return line, None\n\n    default = \"\"\n    par: Dict[str, int] = {\"{\": 0, \"[\": 0, \"(\": 0, \")\": 0, \"]\": 0, \"}\": 0}\n    sub_l: str = line[_end_idx:default_end_offset]\n    sub_l_len: int = len(sub_l)\n    for idx, ch in enumerate(sub_l):\n        if (\n            ch == \".\"\n            and (idx == (sub_l_len - 1) or not (sub_l[idx + 1]).isdigit())\n            and not sum(par.values())\n        ):\n            break\n        elif ch in par:\n            par[ch] += 1\n        default += ch\n\n    start_rest_offset = _end_idx + len(default)\n\n    default = default.strip(\" \\t`\")\n\n    if default.count('\"') &amp; 1:\n        default = default.strip('\"')\n    if default.count(\"'\") &amp; 1:\n        default = default.strip(\"'\")\n\n    # Correct for parsing errors where a quote is captured at the start or end, but not both\n    if len(default) &gt; 0:\n        if default.count('\"') == 1 and default.count(\"'\") == 0:\n            if default.startswith('\"'):\n                default = default + '\"'\n            elif default.endswith('\"'):\n                default = '\"' + default\n        elif default.count(\"'\") == 1 and default.count('\"') == 0:\n            if default.startswith(\"'\"):\n                default = default + \"'\"\n            elif default.endswith(\"'\"):\n                default = \"'\" + default\n\n    return _parse_out_default_and_doc(\n        _start_idx,\n        start_rest_offset,\n        default,\n        line,\n        rstrip_default,\n        typ,\n        default_end_offset,\n        emit_default_doc,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.defaults_utils.needs_quoting","title":"needs_quoting","text":"<pre><code>needs_quoting(typ)\n</code></pre> <p>Figures out whether values with this type need quoting</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>Optional[str]</code> <p>The type</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the type needs quoting</p> Source code in <code>cdd/shared/defaults_utils.py</code> <pre><code>def needs_quoting(typ):\n    \"\"\"\n    Figures out whether values with this type need quoting\n\n    :param typ: The type\n    :type typ: ```Optional[str]```\n\n    :return: Whether the type needs quoting\n    :rtype: ```bool```\n    \"\"\"\n    if typ is None or typ.startswith(\"*\"):\n        return False\n    elif typ == \"str\":\n        return True\n    elif typ == \"Optional[str]\":\n        return True\n\n    typ = typ.replace(\"\\n\", \"\").strip()\n    parsed_typ_ast = ast_parse_fix(typ)\n    if isinstance(parsed_typ_ast, ast.Name):\n        return parsed_typ_ast.id == \"str\"\n\n    return any(\n        filter(\n            lambda node: isinstance(node, Str)\n            or isinstance(node, ast.Constant)\n            and type(node.value).__name__ == \"str\"\n            or isinstance(node, ast.Name)\n            and node.id == \"str\",\n            ast.walk(parsed_typ_ast),\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.defaults_utils.remove_defaults_from_intermediate_repr","title":"remove_defaults_from_intermediate_repr","text":"<pre><code>remove_defaults_from_intermediate_repr(intermediate_repr, emit_default_prop=True)\n</code></pre> <p>Remove \"Default of\" text from IR</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_default_prop</code> <code>bool</code> <p>Whether to emit default property</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/shared/defaults_utils.py</code> <pre><code>def remove_defaults_from_intermediate_repr(intermediate_repr, emit_default_prop=True):\n    \"\"\"\n    Remove \"Default of\" text from IR\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param emit_default_prop: Whether to emit default property\n    :type emit_default_prop: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    ir: IntermediateRepr = deepcopy(intermediate_repr)\n\n    remove_default_from_param = partial(\n        _remove_default_from_param, emit_default_prop=emit_default_prop\n    )\n    ir.update(\n        {\n            key: OrderedDict(map(remove_default_from_param, ir[key].items()))\n            for key in (\"params\", \"returns\")\n        }\n    )\n    return ir\n</code></pre>"},{"location":"api/#cdd.shared.defaults_utils.set_default_doc","title":"set_default_doc","text":"<pre><code>set_default_doc(param, emit_default_doc=True)\n</code></pre> <p>Emit param with 'doc' set to include 'Defaults'</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Same shape as input but with Default append to doc.</p> Source code in <code>cdd/shared/defaults_utils.py</code> <pre><code>def set_default_doc(param, emit_default_doc=True):\n    \"\"\"\n    Emit param with 'doc' set to include 'Defaults'\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Same shape as input but with Default append to doc.\n    :rtype: ```dict```\n    \"\"\"\n    name, _param = param\n    del param\n    # if param is None: param = {\"doc\": \"\", \"typ\": \"Any\"}\n    if _param is None or \"doc\" not in _param:\n        return name, _param\n    has_defaults = \"Defaults\" in _param[\"doc\"] or \"defaults\" in _param[\"doc\"]\n\n    if has_defaults and not emit_default_doc:\n        # Remove the default text\n        _param[\"doc\"] = extract_default(\n            _param[\"doc\"], emit_default_doc=emit_default_doc\n        )[0]\n    elif \"default\" in _param and not has_defaults and emit_default_doc:\n        # if _param[\"default\"] == NoneStr: _param[\"default\"] = None\n        if _param[\"default\"] is not None or not name.endswith(\"kwargs\"):\n            _param[\"doc\"] = \"{doc} Defaults to {default}\".format(\n                doc=(\n                    _param[\"doc\"]\n                    if _param[\"doc\"][-1] in frozenset((\".\", \",\"))\n                    else \"{doc}.\".format(doc=_param[\"doc\"])\n                ),\n                default=(\n                    quote(_param[\"default\"])\n                    if (\n                        needs_quoting(_param.get(\"typ\"))\n                        and (\n                            len(_param[\"default\"]) &lt; 2\n                            or not _param[\"default\"].startswith(\"`\")\n                            or not _param[\"default\"].endswith(\"`\")\n                        )\n                        if isinstance(_param[\"default\"], str)\n                        else True\n                    )\n                    else _param[\"default\"]\n                ),\n            )\n\n    return name, _param\n</code></pre>"},{"location":"api/#cddshareddocstring_parsers","title":"<code>cdd.shared.docstring_parsers</code>","text":""},{"location":"api/#cdd.shared.docstring_parsers","title":"cdd.shared.docstring_parsers","text":"<p>Docstring parsers.</p> <p>Parses these formats into the cdd_python common IR format:  - ReST docstring format (Sphinx)  - numpydoc docstring format  - Google's docstring format</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.docstring_parsers.Style","title":"Style","text":"<p>               Bases: <code>Enum</code></p> <p>Simple enum taken from the docstring_parser codebase</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.docstring_parsers.__set_name_and_type_handle_doc_in_param","title":"__set_name_and_type_handle_doc_in_param","text":"<pre><code>__set_name_and_type_handle_doc_in_param(_param, name, was_none, word_wrap)\n</code></pre> <p>Internal function to internal function <code>_set_name_and_type</code>.</p> <p>Parameters:</p> Name Type Description Default <code>_param</code> <code>dict</code> <p>dict with keys: 'typ', 'doc', 'default'</p> required <code>name</code> <code>str</code> <p>Name of argument; useful for debugging and if the name hints as to the type</p> required <code>was_none</code> <code>bool</code> <p>Whether the default value was <code>None</code></p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required Source code in <code>cdd/shared/docstring_parsers.py</code> <pre><code>def __set_name_and_type_handle_doc_in_param(_param, name, was_none, word_wrap):\n    \"\"\"\n    Internal function to internal function `_set_name_and_type`.\n\n    :param _param: dict with keys: 'typ', 'doc', 'default'\n    :type _param: ```dict```\n\n    :param name: Name of argument; useful for debugging and if the name hints as to the type\n    :type name: ```str```\n\n    :param was_none: Whether the default value was `None`\n    :type was_none: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n    \"\"\"\n    if \"doc\" in _param:\n        if not isinstance(_param[\"doc\"], str):\n            _param[\"doc\"] = \"\".join(_param[\"doc\"]).rstrip()\n        else:\n            _param[\"doc\"] = (\n                \" \".join(map(str.strip, _param[\"doc\"].split(\"\\n\")))\n                if word_wrap\n                else _param[\"doc\"]\n            ).rstrip()\n\n        typ = parse_adhoc_doc_for_typ(\n            _param[\"doc\"], name, _param.get(\"default\") == cdd.shared.ast_utils.NoneStr\n        )\n        if typ is not None:\n            try:\n                eval(typ, globals(), locals())\n                _param[\"typ\"] = typ\n            except (NameError, SyntaxError, TypeError) as e:\n                print(e, file=sys.stderr)\n\n        if (\n            (_param[\"doc\"].startswith((\"(Optional)\", \"Optional\")) or was_none)\n            and \"typ\" in _param\n            and not _param[\"typ\"].startswith(\"Optional[\")\n        ):\n            _param[\"typ\"] = \"Optional[{typ}]\".format(typ=_param[\"typ\"])\n</code></pre>"},{"location":"api/#cdd.shared.docstring_parsers.parse_docstring","title":"parse_docstring","text":"<pre><code>parse_docstring(docstring, infer_type=False, default_search_announce=None, parse_original_whitespace=False, word_wrap=True, emit_default_prop=True, emit_default_doc=False)\n</code></pre> <p>Parse the docstring into its components.</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>Optional[str]</code> <p>the docstring</p> required <code>default_search_announce</code> <code>Optional[Union[str, Iterable[str]]]</code> <p>Default text(s) to look for. If None, uses default specified in default_utils.</p> required <code>infer_type</code> <code>bool</code> <p>Whether to try inferring the typ (from the default)</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_default_prop</code> <code>dict</code> <p>Whether to include the default dictionary property.</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/shared/docstring_parsers.py</code> <pre><code>def parse_docstring(\n    docstring,\n    infer_type=False,\n    default_search_announce=None,\n    parse_original_whitespace=False,\n    word_wrap=True,\n    emit_default_prop=True,\n    emit_default_doc=False,\n):\n    \"\"\"Parse the docstring into its components.\n\n    :param docstring: the docstring\n    :type docstring: ```Optional[str]```\n\n    :param default_search_announce: Default text(s) to look for. If None, uses default specified in default_utils.\n    :type default_search_announce: ```Optional[Union[str, Iterable[str]]]```\n\n    :param infer_type: Whether to try inferring the typ (from the default)\n    :type infer_type: ```bool```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param emit_default_prop: Whether to include the default dictionary property.\n    :type emit_default_prop: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n\n    assert isinstance(\n        docstring, (type(None), str)\n    ), \"Expected `Union[type(None), str]` got `{type_name}`\".format(\n        type_name=type(docstring).__name__\n    )\n    style: Style = derive_docstring_format(docstring)\n\n    ir: IntermediateRepr = {\n        \"name\": None,\n        \"type\": \"static\",\n        # \"_internal\": {\"_style\": style.value},\n        \"doc\": \"\",\n        \"params\": OrderedDict(),\n        \"returns\": None,\n    }\n    if not docstring:\n        return ir\n\n    scanned = _scan_phase(docstring, style=style)\n\n    _parse_phase(\n        ir,\n        scanned,\n        default_search_announce=default_search_announce,\n        emit_default_doc=emit_default_doc,\n        emit_default_prop=emit_default_prop,\n        infer_type=infer_type,\n        parse_original_whitespace=parse_original_whitespace,\n        style=style,\n        word_wrap=word_wrap,\n    )\n\n    # Apply certain functions regardless of style\n    if style is Style.rest:\n        ir.update(\n            {\n                k: (\n                    OrderedDict(\n                        map(\n                            partial(\n                                interpolate_defaults,\n                                emit_default_doc=emit_default_doc,\n                                require_default=False,\n                            ),\n                            ir[k].items(),\n                        )\n                    )\n                    if ir[k]\n                    else ir[k]\n                )\n                for k in (\"params\", \"returns\")\n            }\n        )\n    return ir\n</code></pre>"},{"location":"api/#cddshareddocstring_utils","title":"<code>cdd.shared.docstring_utils</code>","text":""},{"location":"api/#cdd.shared.docstring_utils","title":"cdd.shared.docstring_utils","text":"<p>Functions which produce docstring portions from various inputs</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.docstring_utils.Style","title":"Style","text":"<p>               Bases: <code>Enum</code></p> <p>Simple enum taken from the docstring_parser codebase</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.docstring_utils.derive_docstring_format","title":"derive_docstring_format","text":"<pre><code>derive_docstring_format(docstring)\n</code></pre> <p>Infer the docstring format of the provided docstring</p> <p>Parameters:</p> Name Type Description Default <code>docstring</code> <code>Optional[str]</code> <p>the docstring</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>the style of docstring</p> Source code in <code>cdd/shared/docstring_utils.py</code> <pre><code>def derive_docstring_format(docstring):\n    \"\"\"\n    Infer the docstring format of the provided docstring\n\n    :param docstring: the docstring\n    :type docstring: ```Optional[str]```\n\n    :return: the style of docstring\n    :rtype: ```Literal['rest', 'numpydoc', 'google']```\n    \"\"\"\n    if docstring is None or any(map(partial(contains, docstring), TOKENS.rest)):\n        style = Style.rest\n    elif any(map(partial(contains, docstring), TOKENS.google)):\n        style = Style.google\n    else:\n        style = Style.numpydoc\n    return style\n</code></pre>"},{"location":"api/#cdd.shared.docstring_utils.emit_param_str","title":"emit_param_str","text":"<pre><code>emit_param_str(param, style, purpose, emit_doc=True, emit_type=True, word_wrap=True, emit_default_doc=True)\n</code></pre> <p>Produce the docstring param/return lines</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>style</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>the style of docstring</p> required <code>purpose</code> <code>Literal['class', 'function']</code> required <code>if purpose == 'function' elif purpose == 'class' then </code> <p>:param<code>if purpose == 'function' elif purpose == 'class' then</code></p> required <code>(ReST only)</code> <p>:cvar` (ReST only)</p> required <code>emit_doc</code> <code>bool</code> <p>Whether to emit the doc</p> required <code>emit_type</code> <code>bool</code> <p>Whether to emit the type</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Newline joined pair of param, type</p> Source code in <code>cdd/shared/docstring_utils.py</code> <pre><code>def emit_param_str(\n    param,\n    style,\n    purpose,\n    emit_doc=True,\n    emit_type=True,\n    word_wrap=True,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Produce the docstring param/return lines\n\n    :param param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type param: ```tuple[str, dict]```\n\n    :param style: the style of docstring\n    :type style: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param purpose: Emit `:param` if purpose == 'function' elif purpose == 'class' then `:cvar` (ReST only)\n    :type purpose: ```Literal['class', 'function']```\n\n    :param emit_doc: Whether to emit the doc\n    :type emit_doc: ```bool```\n\n    :param emit_type: Whether to emit the type\n    :type emit_type: ```bool```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: Newline joined pair of param, type\n    :rtype: ```str```\n    \"\"\"\n    name, _param = param\n    del param\n\n    _fill = fill if word_wrap else identity\n\n    if style == \"rest\":\n        emit_type &amp;= purpose == \"function\"\n        key, key_typ = (\n            (\"return\", \"rtype\")\n            if name == \"return_type\" and purpose != \"class\"\n            else (\n                \"{var} {name}\".format(\n                    var=\"param\" if purpose == \"function\" else \"cvar\", name=name\n                ),\n                \"type {name}\".format(name=name),\n            )\n        )\n\n        return \"\\n\".join(\n            map(\n                indent_all_but_first,\n                map(\n                    _fill,\n                    filter(\n                        None,\n                        (\n                            (\n                                \":{key}: {doc}\".format(\n                                    key=key,\n                                    doc=set_default_doc(\n                                        (name, _param),\n                                        emit_default_doc=emit_default_doc,\n                                    )[1][\"doc\"].lstrip(),\n                                )\n                                if emit_doc and _param.get(\"doc\")\n                                else None\n                            ),\n                            (\n                                \":{key_typ}: ```{typ}```\".format(\n                                    key_typ=key_typ, typ=_param[\"typ\"]\n                                )\n                                if emit_type and _param.get(\"typ\")\n                                else None\n                            ),\n                        ),\n                    ),\n                ),\n            )\n        )\n    elif style == \"numpydoc\":\n        return \"\\n\".join(\n            filter(\n                None,\n                (\n                    (\n                        _fill(\n                            (_param[\"typ\"] if _param.get(\"typ\") else None)\n                            if name == \"return_type\"\n                            else \"{name} :{typ}\".format(\n                                name=name,\n                                typ=(\n                                    \" {typ}\".format(typ=_param[\"typ\"])\n                                    if _param.get(\"typ\")\n                                    else \"\"\n                                ),\n                            )\n                        )\n                        if emit_type and _param.get(\"typ\")\n                        else None\n                    ),\n                    (\n                        _fill(\n                            indent(\n                                set_default_doc(\n                                    (name, _param), emit_default_doc=emit_default_doc\n                                )[1][\"doc\"],\n                                tab,\n                            )\n                        )\n                        if emit_doc and _param.get(\"doc\")\n                        else None\n                    ),\n                ),\n            )\n        )\n    else:\n        return \"\".join(\n            filter(\n                None,\n                (\n                    (\n                        (\n                            \"  {typ}:\".format(typ=_param[\"typ\"])\n                            if _param.get(\"typ\")\n                            else None\n                        )\n                        if name == \"return_type\"\n                        else (\n                            \"  {name} ({typ}): \".format(\n                                name=name,\n                                typ=(\n                                    \"{typ!s}\".format(typ=_param[\"typ\"])\n                                    if _param.get(\"typ\")\n                                    else \"\"\n                                ),\n                            )\n                            if _param.get(\"typ\")\n                            else \"  {name}: \".format(name=name)\n                        )\n                    ),\n                    (\n                        \"{nl}{tab}{doc}\".format(\n                            doc=set_default_doc(\n                                (name, _param), emit_default_doc=emit_default_doc\n                            )[1][\"doc\"],\n                            **(\n                                {\"nl\": \"\\n\", \"tab\": \" \" * 3}\n                                if name == \"return_type\"\n                                else {\"nl\": \"\", \"tab\": \"\"}\n                            )\n                        )\n                        if emit_doc and _param.get(\"doc\")\n                        else None\n                    ),\n                ),\n            )\n        )\n</code></pre>"},{"location":"api/#cdd.shared.docstring_utils.ensure_doc_args_whence_original","title":"ensure_doc_args_whence_original","text":"<pre><code>ensure_doc_args_whence_original(current_doc_str, original_doc_str)\n</code></pre> <p>Ensure doc args appear where they appeared originally</p> <p>Parameters:</p> Name Type Description Default <code>current_doc_str</code> <code>str</code> <p>The current doc_str</p> required <code>original_doc_str</code> <code>str</code> <p>The original doc_str</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>reshuffled doc_str with args/returns in same place as original (same header, footer, and whitespace)</p> Source code in <code>cdd/shared/docstring_utils.py</code> <pre><code>def ensure_doc_args_whence_original(current_doc_str, original_doc_str):\n    \"\"\"\n    Ensure doc args appear where they appeared originally\n\n    :param current_doc_str: The current doc_str\n    :type current_doc_str: ```str```\n\n    :param original_doc_str: The original doc_str\n    :type original_doc_str: ```str```\n\n    :return: reshuffled doc_str with args/returns in same place as original (same header, footer, and whitespace)\n    :rtype: ```str```\n    \"\"\"\n    if original_doc_str and eq(\n        *map(omit_whitespace, (original_doc_str, current_doc_str))\n    ):\n        return original_doc_str\n    (\n        original_header,\n        current_args_returns,\n        original_footer,\n    ) = parse_docstring_into_header_args_footer(current_doc_str, original_doc_str)\n\n    return header_args_footer_to_str(\n        header=original_header or \"\",\n        args_returns=current_args_returns or \"\",\n        footer=original_footer or \"\",\n    )\n</code></pre>"},{"location":"api/#cdd.shared.docstring_utils.header_args_footer_to_str","title":"header_args_footer_to_str","text":"<pre><code>header_args_footer_to_str(header, args_returns, footer)\n</code></pre> <p>Ensure there is always two newlines between header and next, and one between non-empty: args_returns and footer</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>str</code> <p>Header section</p> required <code>args_returns</code> <code>str</code> <p>args|returns section</p> required <code>footer</code> <code>str</code> <p>Footer section</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>One string with these three section combined with a minimum of one nl betwixt each and two at first</p> Source code in <code>cdd/shared/docstring_utils.py</code> <pre><code>def header_args_footer_to_str(header, args_returns, footer):\n    \"\"\"\n    Ensure there is always two newlines between header and next, and one between non-empty: args_returns and footer\n\n    :param header: Header section\n    :type header: ```str```\n\n    :param args_returns: args|returns section\n    :type args_returns: ```str```\n\n    :param footer: Footer section\n    :type footer: ```str```\n\n    :return: One string with these three section combined with a minimum of one nl betwixt each and two at first\n    :rtype: ```str```\n    \"\"\"\n    header_end_nls = num_of_nls(header, end=True) if header else 0\n    if args_returns:\n        args_returns_start_nls = num_of_nls(args_returns, end=False)\n        args_returns_ends_nls = num_of_nls(args_returns, end=True)\n        args_returns = \"{maybe_nls0}{args_returns}{maybe_nl1}\".format(\n            maybe_nls0=(\n                \"\\n\" * (args_returns_start_nls or 2)\n                if args_returns_start_nls &lt; 2 and header and not header_end_nls\n                else \"\"\n            ),\n            args_returns=args_returns,\n            maybe_nl1=\"\\n\" if not args_returns_ends_nls else \"\",\n        )\n        args_returns_start_nls = num_of_nls(args_returns, end=False)\n        args_returns_ends_nls = num_of_nls(args_returns, end=True)\n    else:\n        args_returns_start_nls = args_returns_ends_nls = 0\n    if footer:\n        footer_start_nls = (\n            count_chars_from(footer, str.isspace, \"\\n\", end=False)\n            or args_returns_ends_nls\n        )\n        # foot_end_has_nl = footer[-1] == \"\\n\"\n    else:\n        footer_start_nls: int = 0  # foot_end_has_nl\n\n    # Match indent of args_returns to header or footer\n    if args_returns:\n        header_or_footer: str = header if header else footer\n        indent_amount: int = count_iter_items(takewhile(str.isspace, header_or_footer))\n        newlines: int = (\n            header_or_footer[:indent_amount].count(\"\\n\") if header_or_footer else 0\n        )\n        indent_amount: int = indent_amount - newlines\n        current_indent_amount: int = count_iter_items(\n            takewhile(str.isspace, args_returns)\n        )\n        if current_indent_amount != indent_amount:\n            _indent: str = indent_amount * \" \"\n            len_args_returns: int = len(args_returns)\n            args_returns: str = indent(args_returns, _indent, predicate=lambda _: _)\n            if args_returns[-1] == \"\\n\" and len_args_returns &gt; 1:\n                args_returns += _indent\n\n    nls_after_header = header_end_nls + args_returns_start_nls\n    nls_needed_after_header = (\n        0\n        if (nls_after_header &gt; 1 or not header or not args_returns)\n        else 1 if nls_after_header == 1 else 2 if nls_after_header == 0 else 0\n    )\n\n    return \"{header}{maybe_nl0}{args_returns}{maybe_nl1}{footer}{maybe_nl2}\".format(\n        header=header,\n        maybe_nl0=\"\\n\" * nls_needed_after_header,\n        args_returns=args_returns,\n        maybe_nl1=(\n            \"\\n\"\n            if args_returns\n            and footer\n            and not footer_start_nls\n            and not args_returns_ends_nls\n            else \"\"\n        ),\n        footer=footer,\n        maybe_nl2=\"\",  # if foot_end_has_nl else \"\\n\",\n    )\n</code></pre>"},{"location":"api/#cdd.shared.docstring_utils.parse_docstring_into_header_args_footer","title":"parse_docstring_into_header_args_footer","text":"<pre><code>parse_docstring_into_header_args_footer(current_doc_str, original_doc_str)\n</code></pre> <p>Parse docstring into three parts: header; args|returns; footer</p> <p>Parameters:</p> Name Type Description Default <code>current_doc_str</code> <code>str</code> <p>The current doc_str</p> required <code>original_doc_str</code> <code>str</code> <p>The original doc_str</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[Optional[str], Optional[str], Optional[str]]</code> <p>Header, args|returns, footer</p> Source code in <code>cdd/shared/docstring_utils.py</code> <pre><code>def parse_docstring_into_header_args_footer(current_doc_str, original_doc_str):\n    \"\"\"\n    Parse docstring into three parts: header; args|returns; footer\n\n    :param current_doc_str: The current doc_str\n    :type current_doc_str: ```str```\n\n    :param original_doc_str: The original doc_str\n    :type original_doc_str: ```str```\n\n    :return: Header, args|returns, footer\n    :rtype: ```tuple[Optional[str], Optional[str], Optional[str]]```\n    \"\"\"\n    # if not current_doc_str and not original_doc_str: return None, None, None\n\n    # To quieten linter\n    header_original = footer_original = None\n    start_idx_current = last_idx_current = start_idx_original = last_idx_original = None\n\n    if current_doc_str:\n        start_idx_current = _get_token_start_idx(current_doc_str)\n        last_idx_current = _get_token_last_idx(current_doc_str)\n        # footer_current = (\n        #     current_doc_str[last_idx_current:] if last_idx_current != -1 else None\n        # )\n        # header_current = (\n        #     original_doc_str[:start_idx_current] if start_idx_current &gt; -1 else None\n        # )\n        #\n        # args_returns_current = current_doc_str[\n        #     slice(\n        #         start_idx_current if start_idx_current &gt; -1 else None,\n        #         last_idx_current if last_idx_current &gt; -1 else None,\n        #     )\n        # ]\n\n    if original_doc_str:\n        start_idx_original = _get_token_start_idx(original_doc_str)\n        last_idx_original = _get_token_last_idx(original_doc_str)\n        header_original = (\n            original_doc_str[:start_idx_original] if start_idx_original &gt; -1 else None\n        )\n        args_returns_original = original_doc_str[\n            slice(\n                start_idx_original if start_idx_original &gt; -1 else None,\n                last_idx_original if last_idx_original &gt; -1 else None,\n            )\n        ]\n        footer_original = (\n            original_doc_str[last_idx_original:] if last_idx_original != -1 else None\n        )\n\n    # Now we know where the args/returns were, and where they are now\n    # To avoid whitespace issues, only copy across the args/returns portion, keep rest as original\n\n    args_returns_current, args_returns_original = map(\n        lambda doc_start_end: doc_start_end[0][\n            slice(\n                (\n                    doc_start_end[1]\n                    if doc_start_end[1] is not None and doc_start_end[1] &gt; -1\n                    else None\n                ),\n                (\n                    doc_start_end[2]\n                    if doc_start_end[2] is not None and doc_start_end[2] &gt; -1\n                    else None\n                ),\n            )\n        ],\n        (\n            (current_doc_str, start_idx_current, last_idx_current),\n            (original_doc_str, start_idx_original, last_idx_original),\n        ),\n    )\n\n    indent_args_returns_original: int = count_iter_items(\n        takewhile(str.isspace, args_returns_original or iter(()))\n    )\n    if indent_args_returns_original &gt; 1 and args_returns_current:\n        args_returns_current = indent(\n            args_returns_current,\n            prefix=\" \" * indent_args_returns_original,\n            predicate=lambda _: _,\n        )\n\n    return header_original, args_returns_current, footer_original\n</code></pre>"},{"location":"api/#cddsharedemit","title":"<code>cdd.shared.emit</code>","text":""},{"location":"api/#cdd.shared.emit","title":"cdd.shared.emit","text":"<p>Transform from string or AST representations of input, to AST, file, or str input_str.</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsharedemitfile","title":"<code>cdd.shared.emit.file</code>","text":""},{"location":"api/#cdd.shared.emit.file","title":"cdd.shared.emit.file","text":"<p>File emitter</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.emit.file.file","title":"file","text":"<pre><code>file(node, filename, mode='a', skip_black=False)\n</code></pre> <p>Convert AST to a file</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Union[Module, ClassDef, FunctionDef]</code> <p>AST node</p> required <code>filename</code> <code>str</code> <p>emit to this file</p> required <code>mode</code> <code>str</code> <p>Mode to open the file in, defaults to append</p> <code>append</code> <code>skip_black</code> <code>bool</code> <p>Whether to skip formatting with black</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>NoneType</code> <p>None</p> Source code in <code>cdd/shared/emit/file.py</code> <pre><code>def file(node, filename, mode=\"a\", skip_black=False):\n    \"\"\"\n    Convert AST to a file\n\n    :param node: AST node\n    :type node: ```Union[Module, ClassDef, FunctionDef]```\n\n    :param filename: emit to this file\n    :type filename: ```str```\n\n    :param mode: Mode to open the file in, defaults to append\n    :type mode: ```str```\n\n    :param skip_black: Whether to skip formatting with black\n    :type skip_black: ```bool```\n\n    :return: None\n    :rtype: ```NoneType```\n    \"\"\"\n    if not isinstance(node, Module):\n        node: Module = Module(body=[node], type_ignores=[], stmt=None)\n    src: str = cdd.shared.source_transformer.to_code(node)\n    if not skip_black:\n        src = black.format_str(\n            src,\n            mode=black.Mode(\n                target_versions=set(),\n                line_length=119,\n                is_pyi=False,\n                string_normalization=False,\n            ),\n        )\n    with open(filename, mode) as f:\n        f.write(src)\n</code></pre>"},{"location":"api/#cddsharedemitutils","title":"<code>cdd.shared.emit.utils</code>","text":""},{"location":"api/#cdd.shared.emit.utils","title":"cdd.shared.emit.utils","text":"<p>Utility functions for <code>cdd.emit</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsharedemitutilsemitter_utils","title":"<code>cdd.shared.emit.utils.emitter_utils</code>","text":""},{"location":"api/#cdd.shared.emit.utils.emitter_utils","title":"cdd.shared.emit.utils.emitter_utils","text":"<p>Functions which produce intermediate_repr from various different inputs</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.emit.utils.emitter_utils.ast_parse_fix","title":"ast_parse_fix","text":"<pre><code>ast_parse_fix(s)\n</code></pre> <p>Hack to resolve unbalanced parentheses SyntaxError acquired from PyTorch parsing TODO: remove</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>String to parse</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>Value</p> Source code in <code>cdd/shared/emit/utils/emitter_utils.py</code> <pre><code>def ast_parse_fix(s):\n    \"\"\"\n    Hack to resolve unbalanced parentheses SyntaxError acquired from PyTorch parsing\n    TODO: remove\n\n    :param s: String to parse\n    :type s: ```str```\n\n    :return: Value\n    \"\"\"\n    balanced: bool = (s.count(\"[\") + s.count(\"]\")) &amp; 1 == 0\n    return ast.parse(s if balanced else \"{}]\".format(s)).body[0].value\n</code></pre>"},{"location":"api/#cdd.shared.emit.utils.emitter_utils.get_emitter","title":"get_emitter","text":"<pre><code>get_emitter(emit_name)\n</code></pre> <p>Get emitter function specialised for output <code>node</code></p> <p>Parameters:</p> Name Type Description Default <code>emit_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                              \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]</code> <p>Which type to emit.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Callable[[...], dict]`</code> <p>Function which returns intermediate_repr</p> Source code in <code>cdd/shared/emit/utils/emitter_utils.py</code> <pre><code>def get_emitter(emit_name):\n    \"\"\"\n    Get emitter function specialised for output `node`\n\n    :param emit_name: Which type to emit.\n    :type emit_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\"]```\n\n    :return: Function which returns intermediate_repr\n    :rtype: ```Callable[[...], dict]````\n    \"\"\"\n    emit_name: str = {\"class\": \"class_\"}.get(emit_name, emit_name)\n    return getattr(\n        import_module(\n            \".\".join(\n                (\n                    \"cdd\",\n                    (\n                        \"sqlalchemy\"\n                        if emit_name\n                        in frozenset((\"sqlalchemy_hybrid\", \"sqlalchemy_table\"))\n                        else emit_name\n                    ),\n                    \"emit\",\n                )\n            )\n        ),\n        emit_name,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.emit.utils.emitter_utils.get_internal_body","title":"get_internal_body","text":"<pre><code>get_internal_body(target_name, target_type, intermediate_repr)\n</code></pre> <p>Get the internal body from our IR</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>name of target. If both <code>target_name</code> and <code>target_type</code> match internal body extract, then emit</p> required <code>target_type</code> <code>Literal['self', 'cls', 'static']</code> <p>Type of target, static is static or global method, others just become first arg</p> required <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[list, tuple]</code> <p>Internal body or an empty tuple</p> Source code in <code>cdd/shared/emit/utils/emitter_utils.py</code> <pre><code>def get_internal_body(target_name, target_type, intermediate_repr):\n    \"\"\"\n    Get the internal body from our IR\n\n    :param target_name: name of target. If both `target_name` and `target_type` match internal body extract, then emit\n    :type target_name: ```str```\n\n    :param target_type: Type of target, static is static or global method, others just become first arg\n    :type target_type: ```Literal['self', 'cls', 'static']```\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :return: Internal body or an empty tuple\n    :rtype: ```Union[list, tuple]```\n    \"\"\"\n    return (\n        intermediate_repr[\"_internal\"][\"body\"]\n        if intermediate_repr.get(\"_internal\", {}).get(\"body\")\n        and intermediate_repr[\"_internal\"][\"from_name\"] == target_name\n        and intermediate_repr[\"_internal\"][\"from_type\"] == target_type\n        else tuple()\n    )\n</code></pre>"},{"location":"api/#cddsharedparse","title":"<code>cdd.shared.parse</code>","text":""},{"location":"api/#cdd.shared.parse","title":"cdd.shared.parse","text":"<p>Transform from string or AST representations of input, to intermediate_repr, a dictionary consistent    with <code>IntermediateRepr</code>, defined as:         ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})         IntermediateRepr = TypedDict(\"IntermediateRepr\", {             \"name\": Optional[str],             \"type\": Optional[str],             \"doc\": Optional[str],             \"params\": OrderedDict[str, ParamVal],             \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],         })</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsharedparseutils","title":"<code>cdd.shared.parse.utils</code>","text":""},{"location":"api/#cdd.shared.parse.utils","title":"cdd.shared.parse.utils","text":"<p>Utility functions for <code>cdd.parse</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsharedparseutilsparser_utils","title":"<code>cdd.shared.parse.utils.parser_utils</code>","text":""},{"location":"api/#cdd.shared.parse.utils.parser_utils","title":"cdd.shared.parse.utils.parser_utils","text":"<p>Functions which help the functions within the parser module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.parse.utils.parser_utils.get_parser","title":"get_parser","text":"<pre><code>get_parser(node, parse_name)\n</code></pre> <p>Get parser function specialised for input <code>node</code></p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>Node to parse</p> required <code>parse_name</code> <code>Literal[\"argparse\", \"class\", \"function\", \"json_schema\",                              \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\",\"infer\"]</code> <p>Which type to parse.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Callable[[...], dict]`</code> <p>Function which returns intermediate_repr</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def get_parser(node, parse_name):\n    \"\"\"\n    Get parser function specialised for input `node`\n\n    :param node: Node to parse\n    :type node: ```AST```\n\n    :param parse_name: Which type to parse.\n    :type parse_name: ```Literal[\"argparse\", \"class\", \"function\", \"json_schema\",\n                                 \"pydantic\", \"sqlalchemy\", \"sqlalchemy_table\", \"sqlalchemy_hybrid\",\"infer\"]```\n\n    :return: Function which returns intermediate_repr\n    :rtype: ```Callable[[...], dict]````\n    \"\"\"\n    if parse_name in (None, \"infer\"):\n        parse_name: str = infer(node)\n    parse_name: str = {\n        \"class\": \"class_\",\n        \"sqlalchemy_hybrid\": \"sqlalchemy\",\n        \"sqlalchemy_table\": \"sqlalchemy\",\n    }.get(parse_name, parse_name)\n    return getattr(import_module(\".\".join((\"cdd\", parse_name, \"parse\"))), parse_name)\n</code></pre>"},{"location":"api/#cdd.shared.parse.utils.parser_utils.infer","title":"infer","text":"<pre><code>infer(*args, **kwargs)\n</code></pre> <p>Infer the <code>parse</code> type</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple[args]</code> <p>The arguments</p> required <code>kwargs</code> <code>Optional[dict]</code> <p>Keyword arguments</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Name of inferred parser</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def infer(*args, **kwargs):\n    \"\"\"\n    Infer the `parse` type\n\n    :param args: The arguments\n    :type args: ```tuple[args]```\n\n    :param kwargs: Keyword arguments\n    :type kwargs: ```dict```\n\n    :return: Name of inferred parser\n    :rtype: ```str```\n    \"\"\"\n    node = (\n        args[0]\n        if args\n        else kwargs.get(\n            \"class_def\", kwargs.get(\"function_def\", kwargs.get(\"call_or_name\"))\n        )\n    )\n    is_supported_ast_node: bool = isinstance(\n        node, (Module, Assign, AnnAssign, Call, ClassDef, FunctionDef)\n    )\n    if not is_supported_ast_node and (\n        isinstance(node, (type, FunctionType)) or type(node).__name__ == \"function\"\n    ):\n        return infer(ast.parse(getsource(node)).body[0])\n\n    if not is_supported_ast_node:\n        if not isinstance(node, str):\n            node = cdd.shared.ast_utils.get_value(node)\n        if (\n            isinstance(node, str)\n            and not node.startswith(\"def \")\n            and not node.startswith(\"class \")\n        ):\n            return \"docstring\"\n\n    if isinstance(node, FunctionDef):\n        if next(\n            filter(\n                partial(eq, \"argument_parser\"), map(attrgetter(\"arg\"), node.args.args)\n            ),\n            False,\n        ):\n            return \"argparse_ast\"\n\n        return \"function\"\n\n    elif isinstance(node, ClassDef):\n        if any(\n            filter(\n                partial(eq, \"Base\"),\n                map(attrgetter(\"id\"), filter(rpartial(hasattr, \"id\"), node.bases)),\n            )\n        ):\n            return \"sqlalchemy\"\n        return \"class_\"\n    elif isinstance(node, (AnnAssign, Assign)):\n        return infer(node.value)\n    elif isinstance(node, Call):\n        if len(node.args) &gt; 2 and node.args[1].id == \"metadata\":\n            return \"sqlalchemy_table\"\n    else:\n        raise NotImplementedError(node)\n</code></pre>"},{"location":"api/#cdd.shared.parse.utils.parser_utils.ir_merge","title":"ir_merge","text":"<pre><code>ir_merge(target, other)\n</code></pre> <p>Merge two intermediate_repr (IR) together. It doesn't do a <code>target.update(other)</code>,  instead it carefully merges <code>params</code> and <code>returns</code></p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target IR to modify. These values take precedence. Dict is consistent with <code>IntermediateRepr</code>: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>other</code> <code>dict</code> <p>Read-only IR to use in update. IR is a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>IR of updated target. <code>target</code> is also updated in-place, and the memory of <code>other</code> is used.</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def ir_merge(target, other):\n    \"\"\"\n    Merge two intermediate_repr (IR) together. It doesn't do a `target.update(other)`,\n     instead it carefully merges `params` and `returns`\n\n    :param target: The target IR to modify. These values take precedence. Dict is consistent with `IntermediateRepr`:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type target: ```dict```\n\n    :param other: Read-only IR to use in update. IR is a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type other: ```dict```\n\n    :return: IR of updated target. `target` is also updated in-place, and the memory of `other` is used.\n    :rtype: ```dict```\n    \"\"\"\n    if not target[\"params\"]:\n        target[\"params\"] = other[\"params\"]\n    elif other[\"params\"]:\n        target_params, other_params = map(itemgetter(\"params\"), (target, other))\n        target[\"params\"] = merge_params(other_params, target_params)\n\n    if \"return_type\" not in (target.get(\"returns\") or iter(())):\n        target[\"returns\"] = other[\"returns\"]\n    elif other[\"returns\"]:\n        target[\"returns\"][\"return_type\"] = _join_non_none(\n            target[\"returns\"][\"return_type\"], other[\"returns\"][\"return_type\"]\n        )\n    # if \"return_type\" in target.get(\"params\", frozenset()):\n    #     target[\"returns\"][\"return_type\"] = _join_non_none(\n    #         target[\"returns\"][\"return_type\"], target[\"params\"].pop(\"return_type\")\n    #     )\n\n    other_internal = other.get(\"_internal\", {})\n    if other_internal.get(\"body\"):\n        if \"_internal\" in target:\n            # Merging internal bodies would be a bad idea IMHO\n            target[\"_internal\"].update(other_internal)\n        else:\n            target[\"_internal\"] = other_internal\n\n    return target\n</code></pre>"},{"location":"api/#cdd.shared.parse.utils.parser_utils.merge_params","title":"merge_params","text":"<pre><code>merge_params(other_params, target_params)\n</code></pre> <p>Merge two ParamVal dicts together. It doesn't do a <code>target_params.update(other_params)</code>,  instead it carefully merges two collections of dicts.</p> <p>Parameters:</p> Name Type Description Default <code>other_params</code> <code>str</code> <p>Read-only params to use in update. Iterable of <code>dict</code>s consistent with <code>ParamVal</code>, defined as: TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})</p> required <code>target_params</code> <code>str</code> <p>The target params to modify. These values take precedence. Iterable of <code>dict</code>s consistent with <code>ParamVal</code>, defined as: TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>IR of updated target. <code>target</code> is also updated in-place, and the memory of <code>other</code> is used.</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def merge_params(other_params, target_params):\n    \"\"\"\n    Merge two ParamVal dicts together. It doesn't do a `target_params.update(other_params)`,\n     instead it carefully merges two collections of dicts.\n\n    :param other_params: Read-only params to use in update. Iterable of `dict`s consistent with `ParamVal`, defined as:\n        TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n    :type other_params: ```Iterable[dict]```\n\n    :param target_params: The target params to modify. These values take precedence. Iterable of `dict`s consistent\n      with `ParamVal`, defined as:\n        TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n    :type target_params: ```Iterable[dict]```\n\n    :return: IR of updated target. `target` is also updated in-place, and the memory of `other` is used.\n    :rtype: ```dict```\n    \"\"\"\n    for name in other_params.keys() &amp; target_params.keys():\n        merge_present_params(other_params[name], target_params[name])\n    for name in other_params.keys() - target_params.keys():\n        target_params[name] = other_params[name]\n    return target_params\n</code></pre>"},{"location":"api/#cdd.shared.parse.utils.parser_utils.merge_present_params","title":"merge_present_params","text":"<pre><code>merge_present_params(other_param, target_param)\n</code></pre> <p>Merge two ParamVal dicts together. It doesn't do a <code>target_params.update(other_params)</code>,  instead it carefully merges two dicts.</p> <p>Parameters:</p> Name Type Description Default <code>other_param</code> <code>str</code> <p>Read-only param to use in update. Dict consistent with <code>ParamVal</code>, defined as: TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})</p> required <code>target_param</code> <code>str</code> <p>The target param to modify. These values take precedence. Dict consistent with <code>ParamVal</code>, defined as: TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>IR of updated target. <code>target</code> is also updated in-place, and the memory of <code>other</code> is used.</p> Source code in <code>cdd/shared/parse/utils/parser_utils.py</code> <pre><code>def merge_present_params(other_param, target_param):\n    \"\"\"\n    Merge two ParamVal dicts together. It doesn't do a `target_params.update(other_params)`,\n     instead it carefully merges two dicts.\n\n    :param other_param: Read-only param to use in update. Dict consistent with `ParamVal`, defined as:\n        TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n    :type other_param: ```dict```\n\n    :param target_param: The target param to modify. These values take precedence. Dict consistent with\n      `ParamVal`, defined as:\n        TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n    :type target_param: ```dict```\n\n    :return: IR of updated target. `target` is also updated in-place, and the memory of `other` is used.\n    :rtype: ```dict```\n    \"\"\"\n    if not target_param.get(\"doc\") and other_param.get(\"doc\"):\n        target_param[\"doc\"] = other_param[\"doc\"]\n    if other_param.get(\"typ\") is not None and (\n        target_param.get(\"typ\") is None\n        or target_param[\"typ\"] in simple_types\n        and other_param[\"typ\"] not in simple_types\n    ):\n        target_param[\"typ\"] = other_param[\"typ\"]\n    if (\n        target_param.get(\"default\") in none_types\n        and other_param.get(\"default\") is not None\n    ):\n        target_param[\"default\"] = other_param[\"default\"]\n</code></pre>"},{"location":"api/#cddsharedpkg_utils","title":"<code>cdd.shared.pkg_utils</code>","text":""},{"location":"api/#cdd.shared.pkg_utils","title":"cdd.shared.pkg_utils","text":"<p>pkg_utils</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.pkg_utils.relative_filename","title":"relative_filename","text":"<pre><code>relative_filename(filename, remove_hints=tuple())\n</code></pre> <p>Remove all the paths which are not relevant</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename</p> required <code>remove_hints</code> <code>tuple[str, ...]</code> <p>Hints as to what can be removed</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Relative <code>os.path</code> (if derived) else original</p> Source code in <code>cdd/shared/pkg_utils.py</code> <pre><code>def relative_filename(filename, remove_hints=tuple()):\n    \"\"\"\n    Remove all the paths which are not relevant\n\n    :param filename: Filename\n    :type filename: ```str```\n\n    :param remove_hints: Hints as to what can be removed\n    :type remove_hints: ```tuple[str, ...]```\n\n    :return: Relative `os.path` (if derived) else original\n    :rtype: ```str```\n    \"\"\"\n    _filename: str = filename.casefold()\n    lib = get_python_lib(), get_python_lib(prefix=\"\")  # type: tuple[str, str]\n    return next(\n        map(\n            lambda elem: filename[len(elem) + 1 :],\n            filter(\n                lambda elem: _filename.startswith(elem.casefold()), remove_hints + lib\n            ),\n        ),\n        filename,\n    )\n</code></pre>"},{"location":"api/#cddsharedpure_utils","title":"<code>cdd.shared.pure_utils</code>","text":""},{"location":"api/#cdd.shared.pure_utils","title":"cdd.shared.pure_utils","text":"<p>Pure utils for pure functions. For the same input will always produce the same input_str.</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.pure_utils.FilenameProtocol","title":"FilenameProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Filename protocol</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.pure_utils.SetEncoder","title":"SetEncoder","text":"<p>               Bases: <code>JSONEncoder</code></p> <p>JSON encoder that supports <code>set</code>s</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.pure_utils.SetEncoder.default","title":"default","text":"<pre><code>default(obj)\n</code></pre> <p>Handle <code>set</code> by giving a sorted list in its place</p> <p>Parameters:</p> Name Type Description Default Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def default(self, obj):\n    \"\"\"\n    Handle `set` by giving a sorted list in its place\n    \"\"\"\n    return (sorted if isinstance(obj, set) else partial(JSONEncoder.default, self))(\n        obj\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.all_dunder_for_module","title":"all_dunder_for_module","text":"<pre><code>all_dunder_for_module(module_directory, include, exclude=frozenset(('compound', 'shared', 'tests')), path_validator=path.isdir)\n</code></pre> <p>Generate <code>__all__</code> for a given module using single-level filename hierarchy exclusively</p> <p>Parameters:</p> Name Type Description Default <code>module_directory</code> <code>str</code> <p>Module path</p> required <code>include</code> <code>Iterable[str]</code> <p>Additional strings to include</p> required <code>exclude</code> <code>frozenset</code> <p>base filenames to ignore</p> required <code>path_validator</code> <code>Callable[[str], bool]</code> <p>Path validation function</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>list[str]</code> <p>list of strings matching the expected <code>__all__</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def all_dunder_for_module(\n    module_directory,\n    include,\n    exclude=frozenset((\"compound\", \"shared\", \"tests\")),\n    path_validator=path.isdir,\n):\n    \"\"\"\n    Generate `__all__` for a given module using single-level filename hierarchy exclusively\n\n    :param module_directory: Module path\n    :type module_directory: ```str```\n\n    :param include: Additional strings to include\n    :type include: ```Iterable[str]```\n\n    :param exclude: base filenames to ignore\n    :type exclude: ```frozenset```\n\n    :param path_validator: Path validation function\n    :type path_validator: ```Callable[[str], bool]```\n\n    :return: list of strings matching the expected `__all__`\n    :rtype: ```list[str]```\n    \"\"\"\n    return sorted(\n        chain.from_iterable(\n            (\n                include,\n                map(\n                    itemgetter(0),\n                    map(\n                        path.splitext,\n                        filter(\n                            lambda base: path_validator(\n                                path.join(module_directory, base)\n                            )\n                            and not base.startswith(\"_\")\n                            and not base.endswith(\"_utils{}py\".format(path.extsep))\n                            and base not in exclude,\n                            listdir(module_directory),\n                        ),\n                    ),\n                ),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.append_to_dict","title":"append_to_dict","text":"<pre><code>append_to_dict(d, keys, value)\n</code></pre> <p>Append keys to a dictionary in a hierarchical manner and set the last key to a value. For example, given an empty dictionary and keys = [a, b, c] and value = d then the new dictionary would look like the following: {a: {b: {c: d}}}</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dictionary to append keys</p> required <code>keys</code> <code>list[str]</code> <p>keys to append to d</p> required <code>value</code> <code>any</code> <p>value to set keys[-1]</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p><code>dict</code> with new keys and value added</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def append_to_dict(d, keys, value):\n    \"\"\"\n    Append keys to a dictionary in a hierarchical manner and set the last key to a value.\n    For example, given an empty dictionary and keys = [a, b, c] and value = d then the new\n    dictionary would look like the following: {a: {b: {c: d}}}\n\n    :param d: dictionary to append keys\n    :type d: ```dict```\n\n    :param keys: keys to append to d\n    :type keys: ```list[str]```\n\n    :param value: value to set keys[-1]\n    :type value: ```any```\n\n    :return: `dict` with new keys and value added\n    :rtype: ```dict```\n    \"\"\"\n    pointer = d\n    for i, key in enumerate(keys):\n        if i == len(keys) - 1 and isinstance(pointer, dict):\n            pointer[key] = value\n            return d\n        if isinstance(pointer, dict):\n            pointer.setdefault(key, {})\n            pointer = pointer[key]\n        else:\n            return d\n    return d\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.assert_equal","title":"assert_equal","text":"<pre><code>assert_equal(a, b, cmp=eq)\n</code></pre> <p>assert a and b are equal</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Any</code> <p>anything</p> required <code>b</code> <code>Any</code> <p>anything else</p> required <code>cmp</code> <code>Callable[[a, b], bool]</code> <p>comparator function</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Literal[True]</code> <p>True if equal, otherwise raises <code>AssertionError</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def assert_equal(a, b, cmp=eq):\n    \"\"\"\n    assert a and b are equal\n\n    :param a: anything\n    :type a: ```Any```\n\n    :param b: anything else\n    :type b: ```Any```\n\n    :param cmp: comparator function\n    :type cmp: ```Callable[[a, b], bool]```\n\n    :return: True if equal, otherwise raises `AssertionError`\n    :rtype: ```Literal[True]```\n    \"\"\"\n    if not cmp(a, b):\n        raise AssertionError(\"{a!r} != {b!r}\".format(a=a, b=b))\n    return True\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.balanced_parentheses","title":"balanced_parentheses","text":"<pre><code>balanced_parentheses(s)\n</code></pre> <p>Checks if parentheses are balanced, ignoring whatever is inside quotes</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the parens are balanced</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def balanced_parentheses(s):\n    \"\"\"\n    Checks if parentheses are balanced, ignoring whatever is inside quotes\n\n    :param s: Input string\n    :type s: ```str```\n\n    :return: Whether the parens are balanced\n    :rtype: ```bool```\n    \"\"\"\n    open_parens: str = \"([{\"\n    closed_parens: str = \")]}\"\n    counter: Dict[str, int] = {paren: 0 for paren in open_parens + closed_parens}\n    quote_mark: Optional[Literal[\"'\", '\"']] = None\n    for idx, ch in enumerate(s):\n        if (\n            quote_mark is not None\n            and ch == quote_mark\n            and (idx == 0 or s[idx - 1] != \"\\\\\")\n        ):\n            quote_mark: Optional[Literal[\"'\", '\"']] = None\n        elif quote_mark is None:\n            if ch in frozenset((\"'\", '\"')):\n                quote_mark: Optional[Literal[\"'\", '\"']] = cast(Literal[\"'\", '\"'], ch)\n            elif ch in counter:\n                counter[ch] += 1\n    return all(\n        counter[open_parens[i]] == counter[closed_parens[i]]\n        for i in range(len(open_parens))\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.blockwise","title":"blockwise","text":"<pre><code>blockwise(t, size=2, fillvalue=None)\n</code></pre> <p>Blockwise, like pairwise but with a <code>size</code> parameter From: https://stackoverflow.com/a/4628446</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Iterator</code> <p>iterator</p> required <code>size</code> <code>int</code> <p>size of each block</p> required <code>fillvalue</code> <code>Any</code> <p>What to use to \"pair\" with if uneven</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterator</code> <p>iterator with iterators inside of block size</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def blockwise(t, size=2, fillvalue=None):\n    \"\"\"\n    Blockwise, like pairwise but with a `size` parameter\n    From: https://stackoverflow.com/a/4628446\n\n    :param t: iterator\n    :type t: ```Iterator```\n\n    :param size: size of each block\n    :type size: ```int```\n\n    :param fillvalue: What to use to \"pair\" with if uneven\n    :type fillvalue: ```Any```\n\n    :return: iterator with iterators inside of block size\n    :rtype: ```Iterator```\n    \"\"\"\n    return zip_longest(*[iter(t)] * abs(size), fillvalue=fillvalue)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.code_quoted","title":"code_quoted","text":"<pre><code>code_quoted(s)\n</code></pre> <p>Internally user-provided <code>None</code> and non <code>literal_eval</code>able input is quoted with ```</p> <p>This function checks if the input is quoted such</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>Any</code> <p>The input</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether the input is code quoted</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def code_quoted(s):\n    \"\"\"\n    Internally user-provided `None` and non `literal_eval`able input is quoted with ```\n\n    This function checks if the input is quoted such\n\n    :param s: The input\n    :type s: ```Any```\n\n    :return: Whether the input is code quoted\n    :rtype: ```bool```\n    \"\"\"\n    return (\n        isinstance(s, str) and len(s) &gt; 6 and s.startswith(\"```\") and s.endswith(\"```\")\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.count_chars_from","title":"count_chars_from","text":"<pre><code>count_chars_from(s, sentinel_char_unseen, char, end, s_len=len, start_idx=0, char_f=None)\n</code></pre> <p>Count number of chars in string from one or other end, until <code>ignore</code> is no longer True (or entire <code>s</code> is covered)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <code>sentinel_char_unseen</code> <code>bool</code> <p>Function that takes one char and decided whether to ignore it or not</p> required <code>char</code> <code>str</code> <p>Single character for counting occurrences of</p> required <code>end</code> <code>bool</code> <p>True to look from the end; False to look from start</p> required <code>s_len</code> <code>Callable[str, [int]]</code> <p>String len function to use, override to work at a shorter substr, e.g., <code>lambda _: 5</code></p> required <code>start_idx</code> <code>str</code> <p>Index to start looking at string from, override to work at a shorter substr, e.g., <code>3</code></p> required <code>char_f</code> <code>Optional[Callable[[str], bool]]</code> <p>char function, if <code>True</code> adds 1 to count. Overrides <code>char</code> if provided.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>int</code> <p>Number of chars counted (until <code>ignore</code>)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def count_chars_from(\n    s, sentinel_char_unseen, char, end, s_len=len, start_idx=0, char_f=None\n):\n    \"\"\"\n    Count number of chars in string from one or other end, until `ignore` is no longer True (or entire `s` is covered)\n\n    :param s: Input string\n    :type s: ```str``\n\n    :param sentinel_char_unseen: Function that takes one char and decided whether to ignore it or not\n    :type sentinel_char_unseen: ```Callable[[str], bool]```\n\n    :param char: Single character for counting occurrences of\n    :type char: ```str```\n\n    :param end: True to look from the end; False to look from start\n    :type end: ```bool```\n\n    :param s_len: String len function to use, override to work at a shorter substr, e.g., `lambda _: 5`\n    :type s_len: ```Callable[str, [int]]```\n\n    :param start_idx: Index to start looking at string from, override to work at a shorter substr, e.g., `3`\n    :type start_idx: ```int```\n\n    :param char_f: char function, if `True` adds 1 to count. Overrides `char` if provided.\n    :type char_f: ```Optional[Callable[[str], bool]]```\n\n    :return: Number of chars counted (until `ignore`)\n    :rtype: ```int```\n    \"\"\"\n    char_count: int = 0\n\n    if char_f is None:\n        char_f: Callable[[str], bool] = rpartial(eq, char)\n\n    for i in range(*((s_len(s) - 1, start_idx, -1) if end else (start_idx, s_len(s)))):\n        if char_f(s[i]):\n            char_count += 1\n        elif not sentinel_char_unseen(s[i]):\n            break\n    return char_count\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.count_iter_items","title":"count_iter_items","text":"<pre><code>count_iter_items(iterable)\n</code></pre> <p>Consume an iterable not reading it into memory; return the number of items.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>An iterable</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>int</code> <p>Number of items in iterable</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def count_iter_items(iterable):\n    \"\"\"\n    Consume an iterable not reading it into memory; return the number of items.\n\n    :param iterable: An iterable\n    :type iterable: ```Iterable```\n\n    :return: Number of items in iterable\n    :rtype: ```int```\n    \"\"\"\n    counter: count = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.deindent","title":"deindent","text":"<pre><code>deindent(s, level=None, sep=tab)\n</code></pre> <p>Remove all indentation from the input string, or <code>level</code>(s) of indent if specified</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <code>level</code> <code>str</code> <p>Number of tabs to remove from input string or if None: remove all</p> required <code>sep</code> <code>str</code> <p>Separator (usually <code>tab</code>)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AnyStr</code> <p>Deindented string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def deindent(s, level=None, sep=tab):\n    \"\"\"\n    Remove all indentation from the input string, or `level`(s) of indent if specified\n\n    :param s: Input string\n    :type s: ```AnyStr```\n\n    :param level: Number of tabs to remove from input string or if None: remove all\n    :type level: ```Optional[int]```\n\n    :param sep: Separator (usually `tab`)\n    :type sep: ```str```\n\n    :return: Deindented string\n    :rtype: ```AnyStr```\n    \"\"\"\n    if level is None:\n        process_line: Callable[[str], str] = str.lstrip\n    else:\n        sep *= level\n\n        def process_line(line):\n            \"\"\"\n            :param line: The line to dedent\n            :type line: ```AnyStr```\n\n            :return: Dedented line\n            :rtype: ```AnyStr```\n            \"\"\"\n            return line[len(sep) :] if line.startswith(sep) else line\n\n    return \"\\n\".join(map(process_line, s.splitlines()))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.diff","title":"diff","text":"<pre><code>diff(input_obj, op)\n</code></pre> <p>Given an input with <code>__len__</code> defined and an op which takes the input and produces one output   with <code>__len__</code> defined, compute the difference and return (diff_len, output)</p> <p>Parameters:</p> Name Type Description Default <code>input_obj</code> <code>Any</code> <p>The input</p> required <code>op</code> <code>Callable[[Any], Sized]</code> <p>The operation to run</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[int, Any]</code> <p>length of difference, response of operated input</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def diff(input_obj, op):\n    \"\"\"\n    Given an input with `__len__` defined and an op which takes the input and produces one output\n      with `__len__` defined, compute the difference and return (diff_len, output)\n\n    :param input_obj: The input\n    :type input_obj: ```Any```\n\n    :param op: The operation to run\n    :type op: ```Callable[[Any], Sized]```\n\n    :return: length of difference, response of operated input\n    :rtype: ```tuple[int, Any]```\n    \"\"\"\n    input_len: int = len(\n        input_obj\n    )  # Separate line and binding, as `op` could mutate the `input`\n    result: Sized = op(input_obj)\n    return input_len - len(result), result\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.emit_separating_tabs","title":"emit_separating_tabs","text":"<pre><code>emit_separating_tabs(s, indent_level=1, run_per_line=str.lstrip)\n</code></pre> <p>Emit a separating tab between paragraphs</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string (probably a docstring)</p> required <code>indent_level</code> <code>int</code> <p>docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs</p> required <code>run_per_line</code> <code>Callable[[str], str]</code> <p>Run this function per line</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Original string with a separating tab between paragraphs, &amp; possibly addition indentation on other lines</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def emit_separating_tabs(s, indent_level=1, run_per_line=str.lstrip):\n    \"\"\"\n    Emit a separating tab between paragraphs\n\n    :param s: Input string (probably a docstring)\n    :type s: ```str```\n\n    :param indent_level: docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs\n    :type indent_level: ```int```\n\n    :param run_per_line: Run this function per line\n    :type run_per_line: ```Callable[[str], str]```\n\n    :return: Original string with a separating tab between paragraphs, &amp; possibly addition indentation on other lines\n    :rtype: ```str```\n    \"\"\"\n    sep: str = tab * indent_level\n    return \"\\n{sep}{}\\n{sep}\".format(\n        run_per_line(\n            \"\\n\".join(map(lambda line: sep if len(line) == 0 else line, s.splitlines()))\n        ),\n        sep=sep,\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.ensure_valid_identifier","title":"ensure_valid_identifier","text":"<pre><code>ensure_valid_identifier(s)\n</code></pre> <p>Ensure identifier is valid</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Potentially valid identifier</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Valid identifier from <code>s</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def ensure_valid_identifier(s):\n    \"\"\"\n    Ensure identifier is valid\n\n    :param s: Potentially valid identifier\n    :type s: ```str```\n\n    :return: Valid identifier from `s`\n    :rtype: ```str```\n    \"\"\"\n    if not s:\n        return \"_\"\n    elif iskeyword(s):\n        return \"{}_\".format(s)\n    elif s[0].isdigit():\n        s: str = \"_{}\".format(s)\n    valid: FrozenSet[str] = frozenset(\n        \"_{}{}\".format(string.ascii_letters, string.digits)\n    )\n    return \"\".join(filter(valid.__contains__, s)) or \"_\"\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.filename_from_mod_or_filename","title":"filename_from_mod_or_filename","text":"<pre><code>filename_from_mod_or_filename(mod_or_filename)\n</code></pre> <p>Resolve filename from module name or filename</p> <p>Parameters:</p> Name Type Description Default <code>mod_or_filename</code> <code>str</code> <p>Module name or filename</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Filename</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def filename_from_mod_or_filename(mod_or_filename):\n    \"\"\"\n    Resolve filename from module name or filename\n\n    :param mod_or_filename: Module name or filename\n    :type mod_or_filename: ```str```\n\n    :return: Filename\n    :rtype: ```str```\n    \"\"\"\n    filename: FilenameProtocol = cast(\n        FilenameProtocol, type(\"\", tuple(), {\"origin\": mod_or_filename})\n    )\n    return (\n        filename\n        if path.sep in mod_or_filename or path.isfile(mod_or_filename)\n        else find_spec(mod_or_filename) or filename\n    ).origin\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.find_module_filepath","title":"find_module_filepath","text":"<pre><code>find_module_filepath(module_name, submodule_name=None, none_when_no_spec=False)\n</code></pre> <p>Find module's file location without first importing it</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <p>Module name, e.g., \"cdd.tests\" or \"cdd\"</p> required <code>```str``` </code> <code>:type: str</code> required <code>submodule_name</code> <p>Submodule name, e.g., \"test_pure_utils\"</p> required <code>```Optional[str]``` </code> <code>:type: Optional[str]</code> required <code>none_when_no_spec</code> <code>bool</code> <p>When <code>find_spec</code> returns <code>None</code> return that. If <code>False</code> raises <code>AssertionError</code> then.</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <p>Module location :rpath: <code>str</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def find_module_filepath(module_name, submodule_name=None, none_when_no_spec=False):\n    \"\"\"\n    Find module's file location without first importing it\n\n    :param module_name: Module name, e.g., \"cdd.tests\" or \"cdd\"\n    :type: ```str```\n\n    :param submodule_name: Submodule name, e.g., \"test_pure_utils\"\n    :type: ```Optional[str]```\n\n    :param none_when_no_spec: When `find_spec` returns `None` return that. If `False` raises `AssertionError` then.\n    :type none_when_no_spec: ```bool```\n\n    :return: Module location\n    :rpath: ```str```\n    \"\"\"\n    assert module_name is not None\n    module_spec: Optional[ModuleSpec] = find_spec(module_name)\n    if module_spec is None:\n        if none_when_no_spec:\n            return module_spec\n        raise AssertionError(\"spec not found for {}\".format(module_name))\n    module_origin: Optional[str] = module_spec.origin\n    assert module_origin is not None\n    module_parent: str = path.dirname(module_origin)\n    return (\n        module_origin\n        if submodule_name is None\n        else next(\n            filter(\n                path.exists,\n                (\n                    path.join(\n                        module_parent,\n                        submodule_name,\n                        \"__init__{}py\".format(path.extsep),\n                    ),\n                    path.join(\n                        module_parent, \"{}{}py\".format(submodule_name, path.extsep)\n                    ),\n                    path.join(\n                        module_parent,\n                        submodule_name,\n                        \"__init__{}py\".format(path.extsep),\n                    ),\n                ),\n            ),\n            module_origin,\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.get_module","title":"get_module","text":"<pre><code>get_module(name, package=None, extra_symbols=None)\n</code></pre> <p>Import a module.</p> <p>The 'package' argument is required when performing a relative import. It specifies the package to use as the anchor point from which to resolve the relative import to an absolute import.</p> <p>Wraps <code>importlib.import_module</code> to return the module if it's available in interpreter on ModuleNotFoundError error</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Module name</p> required <code>package</code> <code>Optional[str]</code> <p>Package name</p> required <code>extra_symbols</code> <code>Optional[dict]</code> <p>Dictionary of extra symbols to use if <code>importlib.import_module</code> fails</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Module</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def get_module(name, package=None, extra_symbols=None):\n    \"\"\"\n    Import a module.\n\n    The 'package' argument is required when performing a relative import. It\n    specifies the package to use as the anchor point from which to resolve the\n    relative import to an absolute import.\n\n    Wraps `importlib.import_module` to return the module if it's available in interpreter on ModuleNotFoundError error\n\n    :param name: Module name\n    :type name: ```str```\n\n    :param package: Package name\n    :type package: ```Optional[str]```\n\n    :param extra_symbols: Dictionary of extra symbols to use if `importlib.import_module` fails\n    :type extra_symbols: ```Optional[dict]```\n\n    :return: Module\n    :rtype: ```Module```\n    \"\"\"\n    try:\n        return import_module(name, package)\n    except ModuleNotFoundError:\n        if name in globals():\n            return globals()[name]\n        else:\n            pkg, _, rest_path = name.partition(\".\")\n            if pkg in extra_symbols:\n                return getmodule(\n                    (attrgetter(rest_path) if rest_path else identity)(\n                        extra_symbols[pkg]\n                    )\n                )\n            raise\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.identity","title":"identity","text":"<pre><code>identity(*args, **kwargs)\n</code></pre> <p>Identity function</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>tuple[Any]</code> <p>Any values</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Any</code> <p>the input value</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def identity(*args, **kwargs):\n    \"\"\"\n    Identity function\n\n    :param args: Any values\n    :type args: ```tuple[Any]```\n\n    :return: the input value\n    :rtype: ```Any```\n    \"\"\"\n    return args[0] if len(args) == 1 else args\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.indent_all_but_first","title":"indent_all_but_first","text":"<pre><code>indent_all_but_first(s, indent_level=1, wipe_indents=False, sep=tab)\n</code></pre> <p>Indent all lines except the first one</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <code>indent_level</code> <code>int</code> <p>indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs</p> required <code>wipe_indents</code> <code>bool</code> <p>Whether to clean the <code>s</code> of indents first</p> required <code>sep</code> <code>str</code> <p>Separator (usually <code>tab</code>)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>input string indented (except first line)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def indent_all_but_first(s, indent_level=1, wipe_indents=False, sep=tab):\n    \"\"\"\n    Indent all lines except the first one\n\n    :param s: Input string\n    :type s: ```str```\n\n    :param indent_level: indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs\n    :type indent_level: ```int```\n\n    :param wipe_indents: Whether to clean the `s` of indents first\n    :type wipe_indents: ```bool```\n\n    :param sep: Separator (usually `tab`)\n    :type sep: ```str```\n\n    :return: input string indented (except first line)\n    :rtype: ```str```\n    \"\"\"\n    lines: typing.List[str] = indent(\n        deindent(s) if wipe_indents else s, sep * abs(indent_level)\n    ).split(\"\\n\")\n    return \"\\n\".join([lines[0].lstrip()] + lines[1:])\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.is_ir_empty","title":"is_ir_empty","text":"<pre><code>is_ir_empty(intermediate_repr)\n</code></pre> <p>Checks whether the IR is empty, i.e., might have name and params but will generate a docstr without types or argdoc</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether IR is empty</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def is_ir_empty(intermediate_repr):\n    \"\"\"\n    Checks whether the IR is empty, i.e., might have name and params but will generate a docstr without types or argdoc\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :return: Whether IR is empty\n    :rtype: ```bool```\n    \"\"\"\n    return not intermediate_repr.get(\"doc\") and not any(\n        param_d is not None and (param_d.get(\"typ\") or param_d.get(\"doc\"))\n        for key in (\"params\", \"returns\")\n        for param_d in (intermediate_repr.get(key) or {}).values()\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.is_triple_quoted","title":"is_triple_quoted","text":"<pre><code>is_triple_quoted(s)\n</code></pre> <p>Whether the str is triple quoted</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>bool</code> <p>Whether it has balanced triple quotes (either variety)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def is_triple_quoted(s):\n    \"\"\"\n    Whether the str is triple quoted\n\n    :param s: Input string\n    :type s: ```str```\n\n    :return: Whether it has balanced triple quotes (either variety)\n    :rtype: ```bool```\n    \"\"\"\n    return len(s) &gt; 5 and (\n        s.startswith(\"'''\")\n        and s.endswith(\"'''\")\n        or s.startswith('\"\"\"')\n        and s.endswith('\"\"\"')\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.location_within","title":"location_within","text":"<pre><code>location_within(container, iterable, cmp=eq)\n</code></pre> <p>Finds element within iterable within container</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Any</code> <p>The container, e.g., a str, or list. We are looking for the subset which matches an element in <code>iterable</code>.</p> required <code>iterable</code> <code>Any</code> <p>The iterable, can be constructed</p> required <code>cmp</code> <code>Callable[[str, str], bool]</code> <p>Comparator to check input against</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[int, int, Optional[Any]]</code> <p>(Start index iff found else -1, End index iff found else -1, subset iff found else None)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def location_within(container, iterable, cmp=eq):\n    \"\"\"\n    Finds element within iterable within container\n\n    :param container: The container, e.g., a str, or list.\n      We are looking for the subset which matches an element in `iterable`.\n    :type container: ```Any```\n\n    :param iterable: The iterable, can be constructed\n    :type iterable: ```Any```\n\n    :param cmp: Comparator to check input against\n    :type cmp: ```Callable[[str, str], bool]```\n\n    :return: (Start index iff found else -1, End index iff found else -1, subset iff found else None)\n    :rtype: ```tuple[int, int, Optional[Any]]```\n    \"\"\"\n    if not hasattr(container, \"__len__\"):\n        container: Tuple[Any] = tuple(container)\n    container_len: int = len(container)\n\n    for elem in iterable:\n        elem_len: int = len(elem)\n        if elem_len &gt; container_len:\n            continue\n        elif cmp(elem, container):\n            return 0, elem_len, elem\n        else:\n            for i in range(container_len):\n                end: int = i + elem_len\n                if cmp(container[i:end], elem):\n                    return i, end, elem\n                elif i + elem_len + 1 &gt; container_len:\n                    break\n    return -1, -1, None\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.lstrip_namespace","title":"lstrip_namespace","text":"<pre><code>lstrip_namespace(s, namespaces)\n</code></pre> <p>Remove starting namespace</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>input string</p> required <code>namespaces</code> <code>Union[list[str], tuple[str], Generator[str], Iterator[str]]</code> <p>namespaces to strip</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AnyStr</code> <p><code>str.lstrip</code>ped input (potentially just the original!)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def lstrip_namespace(s, namespaces):\n    \"\"\"\n    Remove starting namespace\n\n    :param s: input string\n    :type s: ```AnyStr```\n\n    :param namespaces: namespaces to strip\n    :type namespaces: ```Union[list[str], tuple[str], Generator[str], Iterator[str]]```\n\n    :return: `str.lstrip`ped input (potentially just the original!)\n    :rtype: ```AnyStr```\n    \"\"\"\n    for namespace in namespaces:\n        s: str = s.lstrip(cast(str, namespace))\n    return s\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.multiline","title":"multiline","text":"<pre><code>multiline(s, quote_with=(\"'\", \"'\"))\n</code></pre> <p>For readability and linting, it's useful to turn a long line, like:     &gt;&gt;&gt; '''123456789_ 123456789_ 123456789_ 123456789'''</p> <pre><code>Into:\n&gt;&gt;&gt; '''123456789_\n</code></pre> <p>'''         '''123456789_ '''         '''123456789_ '''         '''123456789'''</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <code>quote_with</code> <code>tuple[str, str]</code> <p>What to quote with</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>multine input string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def multiline(s, quote_with=(\"'\", \"'\")):\n    \"\"\"\n    For readability and linting, it's useful to turn a long line, like:\n    &gt;&gt;&gt; '''123456789_\\n123456789_\\n123456789_\\n123456789'''\n\n    Into:\n    &gt;&gt;&gt; '''123456789_\\n''' \\\n        '''123456789_\\n''' \\\n        '''123456789_\\n''' \\\n        '''123456789'''\n\n    :param s: Input string\n    :type s: ```str```\n\n    :param quote_with: What to quote with\n    :type quote_with: ```tuple[str, str]```\n\n    :return: multine input string\n    :rtype: ```str```\n    \"\"\"\n    return \"{}{}\".format(\n        \"\",\n        tab.join(\n            map(\n                lambda _s: \"{quote_with[0]}{_s}{quote_with[1]} \\\\\\n\".format(\n                    quote_with=quote_with, _s=_s\n                ),\n                s.splitlines(),\n            )\n        ).rstrip(\" \\n\\\\\"),\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.namespaced_pascal_to_upper_camelcase","title":"namespaced_pascal_to_upper_camelcase","text":"<pre><code>namespaced_pascal_to_upper_camelcase(s, sep='__')\n</code></pre> <p>Convert potentially namespaced pascal to upper camelcase</p> <p>E.g., \"foo__bar_can\" becomes \"Foo__BarCan\"</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Pascal cased string (potentially with namespace, i.e., <code>sep</code>)</p> required <code>sep</code> <code>str</code> <p>Separator (a.k.a., namespace)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Upper camel case string (potentially with namespace)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def namespaced_pascal_to_upper_camelcase(s, sep=\"__\"):\n    \"\"\"\n    Convert potentially namespaced pascal to upper camelcase\n\n    E.g., \"foo__bar_can\" becomes \"Foo__BarCan\"\n\n    :param s: Pascal cased string (potentially with namespace, i.e., `sep`)\n    :type s: ```str```\n\n    :param sep: Separator (a.k.a., namespace)\n    :type sep: ```str```\n\n    :return: Upper camel case string (potentially with namespace)\n    :rtype: ```str```\n    \"\"\"\n    first, sep, last = s.rpartition(sep)\n    return \"{}{}{}\".format(first.title(), sep, pascal_to_upper_camelcase(last))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.namespaced_upper_camelcase_to_pascal","title":"namespaced_upper_camelcase_to_pascal","text":"<pre><code>namespaced_upper_camelcase_to_pascal(s, sep='__')\n</code></pre> <p>Convert potentially namespaced pascal to upper camelcase</p> <p>E.g., \"Foo__BarCan\" becomes \"foo__bar_can\"</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Upper camel case string (potentially with namespace, i.e., <code>sep</code>)</p> required <code>sep</code> <code>str</code> <p>Separator (a.k.a., namespace)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Pascal cased string (potentially with namespace)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def namespaced_upper_camelcase_to_pascal(s, sep=\"__\"):\n    \"\"\"\n    Convert potentially namespaced pascal to upper camelcase\n\n    E.g., \"Foo__BarCan\" becomes \"foo__bar_can\"\n\n    :param s: Upper camel case string (potentially with namespace, i.e., `sep`)\n    :type s: ```str```\n\n    :param sep: Separator (a.k.a., namespace)\n    :type sep: ```str```\n\n    :return: Pascal cased string (potentially with namespace)\n    :rtype: ```str```\n    \"\"\"\n    first, sep, last = s.rpartition(sep)\n    return \"{}{}{}\".format(first.lower(), sep, upper_camelcase_to_pascal(last))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.pairwise","title":"pairwise","text":"<pre><code>pairwise(iterable)\n</code></pre> <p>Return successive overlapping pairs taken from the input iterable.</p> <p>The number of 2-tuples in the output iterator will be one fewer than the number of inputs. It will be empty if the input iterable has fewer than two values.</p> <p>https://docs.python.org/3/library/itertools.html#itertools.pairwise but it's only avail. from 3.10 onwards</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>An iterable</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>zip</code> <p>A pair of 2-tuples or empty</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def pairwise(iterable):\n    \"\"\"\n    Return successive overlapping pairs taken from the input iterable.\n\n    The number of 2-tuples in the output iterator will be one fewer than the number of inputs.\n    It will be empty if the input iterable has fewer than two values.\n\n    https://docs.python.org/3/library/itertools.html#itertools.pairwise\n    but it's only avail. from 3.10 onwards\n\n    :param iterable: An iterable\n    :type iterable: ```Iterable```\n\n    :return: A pair of 2-tuples or empty\n    :rtype: ```zip```\n    \"\"\"\n    # pairwise('ABCDEFG') --&gt; AB BC CD DE EF FG\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.paren_wrap_code","title":"paren_wrap_code","text":"<pre><code>paren_wrap_code(code)\n</code></pre> <p>The new builtin AST unparser adds extra parentheses, so match that behaviour on older versions</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Source code string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Potentially parenthetically wrapped input</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def paren_wrap_code(code):\n    \"\"\"\n    The new builtin AST unparser adds extra parentheses, so match that behaviour on older versions\n\n    :param code: Source code string\n    :type code: ```str```\n\n    :return: Potentially parenthetically wrapped input\n    :rtype: ```str```\n    \"\"\"\n    return (\n        \"({code})\".format(code=code)\n        if PY_GTE_3_9 and code[0] + code[-1] not in frozenset((\"()\", \"[]\", \"{}\"))\n        else code\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.parse_comment_from_line","title":"parse_comment_from_line","text":"<pre><code>parse_comment_from_line(line)\n</code></pre> <p>Remove from comment onwards in line</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Python source line</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p><code>line</code> without comments</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def parse_comment_from_line(line):\n    \"\"\"\n    Remove from comment onwards in line\n\n    :param line: Python source line\n    :type line: ```str```\n\n    :return: `line` without comments\n    :rtype: ```str```\n    \"\"\"\n    double: int = 0\n    single: int = 0\n    for col, ch in enumerate(line):\n        if col &gt; 3 and line[col - 1] == \"\\\\\" and ch in frozenset(('\"', \"'\", \"#\")):\n            pass  # Ignore the char\n        elif ch == '\"':\n            double += 1\n        elif ch == \"'\":\n            single += 1\n        elif ch == \"#\" and single &amp; 1 == 0 and double &amp; 1 == 0:\n            col_offset = (\n                col\n                if col == 0\n                else (col - count_iter_items(takewhile(str.isspace, line[:col][::-1])))\n            )\n            return \"\".join(islice(line, 0, col_offset))\n    return line\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.pascal_to_upper_camelcase","title":"pascal_to_upper_camelcase","text":"<pre><code>pascal_to_upper_camelcase(s)\n</code></pre> <p>Transform pascal input to upper camelcase</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Pascal cased string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Upper camel case string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def pascal_to_upper_camelcase(s):\n    \"\"\"\n    Transform pascal input to upper camelcase\n\n    :param s: Pascal cased string\n    :type s: ```str```\n\n    :return: Upper camel case string\n    :rtype: ```str```\n    \"\"\"\n    return \"\".join(filterfalse(str.isspace, s.title().replace(\"_\", \"\")))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.pluralise","title":"pluralise","text":"<pre><code>pluralise(singular)\n</code></pre> <p>Return plural form of given lowercase singular word (English only). Based on ActiveState recipe http://code.activestate.com/recipes/413172/ and 577781</p> <p>Note: For production you'd probably want to use nltk or an NLP AI model</p> <p>Parameters:</p> Name Type Description Default <code>singular</code> <code>str</code> <p>Non-plural</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Plural version</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def pluralise(singular):\n    \"\"\"Return plural form of given lowercase singular word (English only). Based on\n    ActiveState recipe http://code.activestate.com/recipes/413172/ and 577781\n\n    Note: For production you'd probably want to use nltk or an NLP AI model\n\n    :param singular: Non-plural\n    :type singular: ```str```\n\n    :return: Plural version\n    :rtype: ```str```\n    \"\"\"\n    if not singular:\n        return \"\"\n    plural: str = (\n        _ABERRANT_PLURAL_MAP.get(singular) or singular.endswith(\"es\") and singular\n    )\n    if plural:\n        return plural\n    root: str = singular\n    try:\n        if singular[-1] == \"y\" and singular[-2] not in VOWELS:\n            root: str = singular[:-1]\n            suffix: str = \"ies\"\n        elif singular[-1] == \"s\":\n            if singular[-2] in VOWELS:\n                if singular[-3:] == \"ius\":\n                    root: str = singular[:-2]\n                    suffix: str = \"i\"\n                else:\n                    root: str = singular[:-1]\n                    suffix: str = \"ses\"\n            else:\n                suffix: str = \"es\"\n        elif singular[-2:] in (\"ch\", \"sh\"):\n            suffix: str = \"es\"\n        else:\n            suffix: str = \"s\"\n    except IndexError:\n        suffix: str = \"s\"\n\n    return root + suffix\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.quote","title":"quote","text":"<pre><code>quote(s, mark='\"')\n</code></pre> <p>Quote the input string if it's not already quoted</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>Union[str, float, complex, int, None]</code> <p>Input string or literal or None</p> required <code>mark</code> <code>str</code> <p>Quote mark to wrap with</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Union[str, float, complex, int, None]</code> <p>Quoted string or input (if input is not str)</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def quote(s, mark='\"'):\n    \"\"\"\n    Quote the input string if it's not already quoted\n\n    :param s: Input string or literal or None\n    :type s: ```Union[str, float, complex, int, None]```\n\n    :param mark: Quote mark to wrap with\n    :type mark: ```str```\n\n    :return: Quoted string or input (if input is not str)\n    :rtype: ```Union[str, float, complex, int, None]```\n    \"\"\"\n    very_simple_types = (\n        type(None),\n        int,\n        float,\n        complex,\n    )  # type: tuple[Type[None], Type[int], Type[float], Type[complex]]\n    s: str = (\n        s\n        if isinstance(s, (str, *very_simple_types))\n        else (\n            s.s\n            if isinstance(s, Str)\n            else s.id if isinstance(s, Name) else getattr(s, \"value\", s)\n        )\n    )\n    # ^ Poor man's `get_value`\n    if (\n        isinstance(s, very_simple_types)\n        or len(s) == 0\n        or len(s) &gt; 1\n        and s[0] == s[-1]\n        and s[0] in frozenset((\"'\", '\"'))\n    ):\n        return s\n    return \"{mark}{s}{mark}\".format(mark=mark, s=s)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.read_file_to_str","title":"read_file_to_str","text":"<pre><code>read_file_to_str(filename, mode='rt')\n</code></pre> <p>Read filename into a str, closing the file afterwards</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Input filename</p> required <code>mode</code> <code>str</code> <p>File mode</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Filename content as str</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def read_file_to_str(filename, mode=\"rt\"):\n    \"\"\"\n    Read filename into a str, closing the file afterwards\n\n    :param filename: Input filename\n    :type filename: ```str```\n\n    :param mode: File mode\n    :type mode: ```str```\n\n    :return: Filename content as str\n    :rtype: ```str```\n    \"\"\"\n    with open(filename, mode) as f:\n        return f.read()\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.reindent","title":"reindent","text":"<pre><code>reindent(s, indent_level=1, join_on='\\n')\n</code></pre> <p>Reindent the input string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <code>indent_level</code> <code>int</code> <p>docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs</p> required <code>join_on</code> <code>str</code> <p>What to join on, e.g., ' '</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AnyStr</code> <p>Reindented string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def reindent(s, indent_level=1, join_on=\"\\n\"):\n    \"\"\"\n    Reindent the input string\n\n    :param s: Input string\n    :type s: ```AnyStr```\n\n    :param indent_level: docstring indentation level whence: 0=no_tabs, 1=one tab; 2=two tabs\n    :type indent_level: ```int```\n\n    :param join_on: What to join on, e.g., '\\n'\n    :type join_on: ```str```\n\n    :return: Reindented string\n    :rtype: ```AnyStr```\n    \"\"\"\n    return join_on.join(\n        map(\n            lambda line: \"{tab}{line}\".format(\n                tab=abs(indent_level) * tab, line=line.lstrip()\n            ),\n            s.split(\"\\n\"),\n        )\n    ).replace(tab, \"\", 1)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.remove_whitespace_comments","title":"remove_whitespace_comments","text":"<pre><code>remove_whitespace_comments(source)\n</code></pre> <p>Remove all insignificant whitespace and comments from source</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Python source string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p><code>source</code> without significant whitespace and comments</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def remove_whitespace_comments(source):\n    \"\"\"\n    Remove all insignificant whitespace and comments from source\n\n    :param source: Python source string\n    :type source: ```str```\n\n    :return: `source` without significant whitespace and comments\n    :rtype: ```str```\n    \"\"\"\n    return \"\\n\".join(\n        filter(\n            None,\n            filterfalse(str.isspace, map(parse_comment_from_line, source.splitlines())),\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.rpartial","title":"rpartial","text":"<pre><code>rpartial(func, *args)\n</code></pre> <p>Partially applies last arguments.</p> <p>Parameters:</p> Name Type Description Default Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def rpartial(func, *args):\n    \"\"\"Partially applies last arguments.\"\"\"\n    return lambda *a: func(*(a + args))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.sanitise","title":"sanitise","text":"<pre><code>sanitise(s)\n</code></pre> <p>Sanitise the input string, appending an <code>_</code> if it's a keyword</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Input string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>input string with '_' append if it's a keyword else input string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def sanitise(s):\n    \"\"\"\n    Sanitise the input string, appending an `_` if it's a keyword\n\n    :param s: Input string\n    :type s: ```str```\n\n    :return: input string with '_' append if it's a keyword else input string\n    :rtype: ```str```\n    \"\"\"\n    return \"{}_\".format(s) if iskeyword(s) else s\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.set_attr","title":"set_attr","text":"<pre><code>set_attr(obj, key, val)\n</code></pre> <p>Sets the named attribute on the given object to the specified value.</p> <p>set_attr(x, 'y', v) is equivalent to ``x.y = v; return x''</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>An object</p> required <code>key</code> <code>str</code> <p>A key</p> required <code>val</code> <code>Any</code> <p>A value</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Any</code> <p>The modified <code>obj</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def set_attr(obj, key, val):\n    \"\"\"\n    Sets the named attribute on the given object to the specified value.\n\n    set_attr(x, 'y', v) is equivalent to ``x.y = v; return x''\n\n    :param obj: An object\n    :type obj: ```Any```\n\n    :param key: A key\n    :type key: ```str```\n\n    :param val: A value\n    :type val: ```Any```\n\n    :return: The modified `obj`\n    :rtype: ```Any```\n    \"\"\"\n    setattr(obj, key, val)\n    return obj\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.set_item","title":"set_item","text":"<pre><code>set_item(obj, key, val)\n</code></pre> <p>Sets the item on the given object to the specified value.</p> <p>set_item(x, 'y', v) is equivalent to ``x[y] = v; return x''</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>An object</p> required <code>key</code> <code>Union[str, int]</code> <p>A key</p> required <code>val</code> <code>Any</code> <p>A value</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Any</code> <p>The modified <code>obj</code></p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def set_item(obj, key, val):\n    \"\"\"\n    Sets the item on the given object to the specified value.\n\n    set_item(x, 'y', v) is equivalent to ``x[y] = v; return x''\n\n    :param obj: An object\n    :type obj: ```Any```\n\n    :param key: A key\n    :type key: ```Union[str, int]```\n\n    :param val: A value\n    :type val: ```Any```\n\n    :return: The modified `obj`\n    :rtype: ```Any```\n    \"\"\"\n    obj[key] = val\n    return obj\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.sliding_window","title":"sliding_window","text":"<pre><code>sliding_window(iterable, n)\n</code></pre> <p>Sliding window</p> <p>https://docs.python.org/3/library/itertools.html#itertools-recipes</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Iterable</code> <p>An iterable</p> required <code>n</code> <code>int</code> <p>Window size</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Generator[tuple]</code> <p>sliding window</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def sliding_window(iterable, n):\n    \"\"\"\n    Sliding window\n\n    https://docs.python.org/3/library/itertools.html#itertools-recipes\n\n    :param iterable: An iterable\n    :type iterable: ```Iterable```\n\n    :param n: Window size\n    :type n: ```int```\n\n    :return: sliding window\n    :rtype: ```Generator[tuple]```\n    \"\"\"\n    # sliding_window('ABCDEFG', 4) --&gt; ABCD BCDE CDEF DEFG\n    it = iter(iterable)\n    window = deque(islice(it, n - 1), maxlen=n)\n    for x in it:\n        window.append(x)\n        yield tuple(window)\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.strip_split","title":"strip_split","text":"<pre><code>strip_split(param, sep)\n</code></pre> <p>Split and strip the input string on given separator</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>Module/ClassDef/FunctionDef/AnnAssign/Assign resolver with a dot syntax.</p> required <code>sep</code> <code>str</code> <p>Separator</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterator[str, ...]</code> <p>Iterator of each element of the hierarchy</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def strip_split(param, sep):\n    \"\"\"\n    Split and strip the input string on given separator\n\n    :param param: Module/ClassDef/FunctionDef/AnnAssign/Assign resolver with a dot syntax.\n    :type param: ```str```\n\n    :param sep: Separator\n    :type sep: ```str```\n\n    :return: Iterator of each element of the hierarchy\n    :rtype: ```Iterator[str, ...]```\n    \"\"\"\n    return map(str.strip, param.split(sep))\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.strip_starting","title":"strip_starting","text":"<pre><code>strip_starting(line, str_to_strip=tab)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>Input string</p> required <code>str_to_strip</code> <code>str</code> <p>Removes only this (once\u2026 so not <code>str.lstrip</code>) from the start</p> required Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def strip_starting(line, str_to_strip=tab):\n    \"\"\"\n    :param line: Input string\n    :type line: ```AnyStr```\n\n    :param str_to_strip: Removes only this (once\u2026 so not `str.lstrip`) from the start\n    :type str_to_strip: ```str```\n    \"\"\"\n    return line[len(str_to_strip) :] if line.startswith(str_to_strip) else line\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.unquote","title":"unquote","text":"<pre><code>unquote(input_str)\n</code></pre> <p>Unquote a string. Removes one set of leading quotes <code>'''</code> or <code>'\"'</code></p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[str]</code> <p>Unquoted string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def unquote(input_str):\n    \"\"\"\n    Unquote a string. Removes one set of leading quotes `'\\''` or `'\"'`\n\n    :param input_str: Input string\n    :type input_str: ```Optional[str]```\n\n    :return: Unquoted string\n    :rtype: ```Optional[str]```\n    \"\"\"\n    if (\n        isinstance(input_str, str)\n        and len(input_str) &gt; 1\n        and (\n            input_str.startswith('\"')\n            and input_str.endswith('\"')\n            or input_str.startswith(\"'\")\n            and input_str.endswith(\"'\")\n        )\n    ):\n        return input_str[1:-1]\n    return input_str\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.update_d","title":"update_d","text":"<pre><code>update_d(d, arg=None, **kwargs)\n</code></pre> <p>Update d inplace</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>dict to update</p> required <code>arg</code> <code>dict</code> <p>dict to update with</p> required <code>kwargs</code> <code>Optional[dict]</code> <p>keyword args to update with</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>Updated dict</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def update_d(d, arg=None, **kwargs):\n    \"\"\"\n    Update d inplace\n\n    :param d: dict to update\n    :type d: ```dict```\n\n    :param arg: dict to update with\n    :type arg: ```Optional[dict]```\n\n    :param kwargs: keyword args to update with\n    :type kwargs: ```**kwargs```\n\n    :return: Updated dict\n    :rtype: ```dict```\n    \"\"\"\n    if arg:\n        d.update(cast(dict, arg))\n    if kwargs:\n        d.update(kwargs)\n    return d\n</code></pre>"},{"location":"api/#cdd.shared.pure_utils.upper_camelcase_to_pascal","title":"upper_camelcase_to_pascal","text":"<pre><code>upper_camelcase_to_pascal(s)\n</code></pre> <p>Transform upper camelcase input to pascal case</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Upper camel case string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Pascal cased string</p> Source code in <code>cdd/shared/pure_utils.py</code> <pre><code>def upper_camelcase_to_pascal(s):\n    \"\"\"\n    Transform upper camelcase input to pascal case\n\n    :param s: Upper camel case string\n    :type s: ```str```\n\n    :return: Pascal cased string\n    :rtype: ```str```\n    \"\"\"\n    return \"_\".join(\n        map(\n            str.lower,\n            \"\".join((\" {}\".format(c) if c.isupper() else c) for c in s)\n            .lstrip(\" \")\n            .split(\" \"),\n        )\n    )\n</code></pre>"},{"location":"api/#cddsharedsource_transformer","title":"<code>cdd.shared.source_transformer</code>","text":""},{"location":"api/#cdd.shared.source_transformer","title":"cdd.shared.source_transformer","text":"<p>Source transformer module. Uses astor on Python &lt; 3.9</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.shared.source_transformer.ast_parse","title":"ast_parse","text":"<pre><code>ast_parse(source, filename='&lt;unknown&gt;', mode='exec', skip_annotate=False, skip_docstring_remit=False)\n</code></pre> <p>Convert the AST input to Python source string</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>Python source</p> required <code> source</code> <code>str</code> required <code>filename</code> <code>str</code> <p>Filename being parsed</p> required <code>mode</code> <code>Literal['exec', 'single', 'eval']</code> <p>'exec' to compile a module, 'single' to compile a single (interactive) statement, or 'eval' to compile an expression.</p> required <code>skip_annotate</code> <code>bool</code> <p>Don't run <code>annotate_ancestry</code></p> required <code>skip_docstring_remit</code> <code>bool</code> <p>Don't parse &amp; emit the docstring as a replacement for current docstring</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>AST</code> <p>AST node</p> Source code in <code>cdd/shared/source_transformer.py</code> <pre><code>def ast_parse(\n    source,\n    filename=\"&lt;unknown&gt;\",\n    mode=\"exec\",\n    skip_annotate=False,\n    skip_docstring_remit=False,\n):\n    \"\"\"\n    Convert the AST input to Python source string\n\n    :param source: Python source\n    :type  source: ```str```\n\n    :param filename: Filename being parsed\n    :type filename: ```str```\n\n    :param mode: 'exec' to compile a module, 'single' to compile a single (interactive) statement,\n      or 'eval' to compile an expression.\n    :type mode: ```Literal['exec', 'single', 'eval']```\n\n    :param skip_annotate: Don't run `annotate_ancestry`\n    :type skip_annotate: ```bool```\n\n    :param skip_docstring_remit: Don't parse &amp; emit the docstring as a replacement for current docstring\n    :type skip_docstring_remit: ```bool```\n\n    :return: AST node\n    :rtype: ```AST```\n    \"\"\"\n    parsed_ast = parse(source, filename=filename, mode=mode)\n    if not skip_annotate:\n        cdd.shared.ast_utils.annotate_ancestry(parsed_ast, filename=filename)\n        setattr(parsed_ast, \"__file__\", filename)\n    if not skip_docstring_remit and isinstance(\n        parsed_ast, (Module, ClassDef, FunctionDef, AsyncFunctionDef)\n    ):\n        docstring: Optional[str] = get_docstring(parsed_ast, clean=True)\n        if docstring is None:\n            return parsed_ast\n\n        # Reindent docstring\n        parsed_ast.body[0].value.value = \"\\n{tab}{docstring}\\n{tab}\".format(\n            tab=tab, docstring=reindent(docstring)\n        )\n    return parsed_ast\n</code></pre>"},{"location":"api/#cdd.shared.source_transformer.to_code","title":"to_code","text":"<pre><code>to_code(node)\n</code></pre> <p>Convert the AST input to Python source string</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>AST</code> <p>AST node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Python source</p> Source code in <code>cdd/shared/source_transformer.py</code> <pre><code>def to_code(node):\n    \"\"\"\n    Convert the AST input to Python source string\n\n    :param node: AST node\n    :type node: ```AST```\n\n    :return: Python source\n    :rtype: ```str```\n    \"\"\"\n    # ^Not `to_code = getattr\u2026` so docstring can be included^\n    return unparse(node)\n</code></pre>"},{"location":"api/#cddsharedtypes","title":"<code>cdd.shared.types</code>","text":""},{"location":"api/#cdd.shared.types","title":"cdd.shared.types","text":"<p>Shared types</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsqlalchemy","title":"<code>cdd.sqlalchemy</code>","text":""},{"location":"api/#cdd.sqlalchemy","title":"cdd.sqlalchemy","text":"<p>SQLalchemy parsers and emitters module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsqlalchemyemit","title":"<code>cdd.sqlalchemy.emit</code>","text":""},{"location":"api/#cdd.sqlalchemy.emit","title":"cdd.sqlalchemy.emit","text":"<p>SQLalchemy emitters</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.sqlalchemy.emit.sqlalchemy","title":"sqlalchemy","text":"<pre><code>sqlalchemy(intermediate_repr, emit_repr=True, class_name=None, class_bases=('Base',), decorator_list=None, table_name=None, force_pk_id=FORCE_PK_ID, docstring_format='rest', word_wrap=True, emit_original_whitespace=False, emit_default_doc=True)\n</code></pre> <p>Construct an SQLAlchemy declarative class</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_repr</code> <code>bool</code> <p>Whether to generate a <code>__repr__</code> method</p> required <code>class_name</code> <code>name</code> <p>name of class</p> required <code>class_bases</code> <code>Iterable[str]</code> <p>bases of class (the generated class will inherit these)</p> required <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>table_name</code> <code>str</code> <p>Table name, defaults to <code>class_name</code></p> <code>class_name</code> <code>force_pk_id</code> <code>bool</code> <p>Whether to force primary_key to be named <code>id</code> (if there isn't already a primary_key)</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit an original whitespace (in docstring) or strip it out</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ClassDef</code> <p>SQLalchemy declarative class AST</p> Source code in <code>cdd/sqlalchemy/emit.py</code> <pre><code>def sqlalchemy(\n    intermediate_repr,\n    emit_repr=True,\n    class_name=None,\n    class_bases=(\"Base\",),\n    decorator_list=None,\n    table_name=None,\n    force_pk_id=FORCE_PK_ID,\n    docstring_format=\"rest\",\n    word_wrap=True,\n    emit_original_whitespace=False,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Construct an SQLAlchemy declarative class\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param emit_repr: Whether to generate a `__repr__` method\n    :type emit_repr: ```bool```\n\n    :param class_name: name of class\n    :type class_name: ```str```\n\n    :param class_bases: bases of class (the generated class will inherit these)\n    :type class_bases: ```Iterable[str]```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param table_name: Table name, defaults to `class_name`\n    :type table_name: ```str```\n\n    :param force_pk_id: Whether to force primary_key to be named `id` (if there isn't already a primary_key)\n    :type force_pk_id: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param emit_original_whitespace: Whether to emit an original whitespace (in docstring) or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: SQLalchemy declarative class AST\n    :rtype: ```ClassDef```\n    \"\"\"\n\n    if class_name is None and intermediate_repr[\"name\"]:\n        class_name: Optional[str] = intermediate_repr[\"name\"]\n    assert class_name is not None, \"`class_name` is `None`\"\n\n    return ClassDef(\n        name=class_name,\n        bases=list(\n            map(\n                lambda class_base: Name(\n                    class_base, Load(), lineno=None, col_offset=None\n                ),\n                class_bases,\n            )\n        ),\n        decorator_list=decorator_list or [],\n        type_params=[],\n        keywords=[],\n        body=list(\n            filter(\n                None,\n                chain.from_iterable(\n                    (\n                        (\n                            (\n                                Expr(\n                                    set_value(\n                                        concat_with_whitespace(\n                                            *map(\n                                                partial(\n                                                    docstring,\n                                                    docstring_format=docstring_format,\n                                                    emit_default_doc=emit_default_doc,\n                                                    emit_original_whitespace=emit_original_whitespace,\n                                                    emit_separating_tab=True,\n                                                    emit_types=True,\n                                                    indent_level=1,\n                                                    word_wrap=word_wrap,\n                                                ),\n                                                (\n                                                    {\n                                                        \"doc\": intermediate_repr[\"doc\"],\n                                                        \"params\": OrderedDict(),\n                                                        \"returns\": None,\n                                                    },\n                                                    {\n                                                        \"doc\": \"\",\n                                                        \"params\": OrderedDict(),\n                                                        \"returns\": intermediate_repr[\n                                                            \"returns\"\n                                                        ],\n                                                    },\n                                                ),\n                                            )\n                                        )\n                                    ),\n                                    lineno=None,\n                                    col_offset=None,\n                                )\n                                if intermediate_repr.get(\"doc\")\n                                or (intermediate_repr[\"returns\"] or {})\n                                .get(\"return_type\", {})\n                                .get(\"doc\")\n                                else None\n                            ),\n                            Assign(\n                                targets=[\n                                    Name(\n                                        \"__tablename__\",\n                                        Store(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    )\n                                ],\n                                value=set_value(table_name or class_name),\n                                expr=None,\n                                lineno=None,\n                                **maybe_type_comment,\n                            ),\n                        ),\n                        *map(\n                            lambda name_param: map(\n                                lambda column: Assign(\n                                    targets=[\n                                        Name(\n                                            name_param[0],\n                                            Store(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        )\n                                    ],\n                                    value=column,\n                                    expr=None,\n                                    lineno=None,\n                                    **maybe_type_comment,\n                                ),\n                                cdd.sqlalchemy.utils.emit_utils.param_to_sqlalchemy_column_calls(\n                                    name_param, include_name=False\n                                ),\n                            ),\n                            cdd.sqlalchemy.utils.emit_utils.ensure_has_primary_key(\n                                intermediate_repr[\"params\"], force_pk_id\n                            ).items(),\n                        ),\n                        (\n                            (\n                                cdd.sqlalchemy.utils.emit_utils.generate_repr_method(\n                                    intermediate_repr[\"params\"],\n                                    class_name,\n                                    docstring_format,\n                                )\n                                if emit_repr\n                                else None\n                            ),\n                        ),\n                    )\n                ),\n            )\n        ),\n        expr=None,\n        identifier_name=None,\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.emit.sqlalchemy_hybrid","title":"sqlalchemy_hybrid","text":"<pre><code>sqlalchemy_hybrid(intermediate_repr, emit_repr=True, emit_create_from_attr=True, class_name=None, class_bases=('Base',), decorator_list=None, table_name=None, force_pk_id=FORCE_PK_ID, docstring_format='rest', word_wrap=True, emit_original_whitespace=False, emit_default_doc=True)\n</code></pre> <p>Construct an <code>class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)</code></p> <p>Valid in SQLalchemy 2.0 and 1.4: - docs.sqlalchemy.org/en/14/orm/declarative_tables.html#declarative-with-imperative-table-a-k-a-hybrid-declarative - docs.sqlalchemy.org/en/20/orm/declarative_tables.html#declarative-with-imperative-table-a-k-a-hybrid-declarative</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>emit_repr</code> <code>bool</code> <p>Whether to generate a <code>__repr__</code> method</p> required <code>emit_create_from_attr</code> <code>bool</code> <p>Whether to generate a <code>create_from_attr</code> staticmethod</p> required <code>class_name</code> <code>name</code> <p>name of class</p> required <code>class_bases</code> <code>Iterable[str]</code> <p>bases of class (the generated class will inherit these)</p> required <code>decorator_list</code> <code>Optional[Union[List[str], List[]]]</code> <p>List of decorators</p> required <code>table_name</code> <code>str</code> <p>Table name, defaults to <code>class_name</code></p> <code>class_name</code> <code>force_pk_id</code> <code>bool</code> <p>Whether to force primary_key to be named <code>id</code> (if there isn't already a primary_key)</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit an original whitespace (in docstring) or strip it out</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ClassDef</code> <p>SQLalchemy hybrids declarative class AST</p> Source code in <code>cdd/sqlalchemy/emit.py</code> <pre><code>def sqlalchemy_hybrid(\n    intermediate_repr,\n    emit_repr=True,\n    emit_create_from_attr=True,\n    class_name=None,\n    class_bases=(\"Base\",),\n    decorator_list=None,\n    table_name=None,\n    force_pk_id=FORCE_PK_ID,\n    docstring_format=\"rest\",\n    word_wrap=True,\n    emit_original_whitespace=False,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Construct an `class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)`\n\n    Valid in SQLalchemy 2.0 and 1.4:\n    - docs.sqlalchemy.org/en/14/orm/declarative_tables.html#declarative-with-imperative-table-a-k-a-hybrid-declarative\n    - docs.sqlalchemy.org/en/20/orm/declarative_tables.html#declarative-with-imperative-table-a-k-a-hybrid-declarative\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param emit_repr: Whether to generate a `__repr__` method\n    :type emit_repr: ```bool```\n\n    :param emit_create_from_attr: Whether to generate a `create_from_attr` staticmethod\n    :type emit_create_from_attr: ```bool```\n\n    :param class_name: name of class\n    :type class_name: ```str```\n\n    :param class_bases: bases of class (the generated class will inherit these)\n    :type class_bases: ```Iterable[str]```\n\n    :param decorator_list: List of decorators\n    :type decorator_list: ```Optional[Union[List[str], List[]]]```\n\n    :param table_name: Table name, defaults to `class_name`\n    :type table_name: ```str```\n\n    :param force_pk_id: Whether to force primary_key to be named `id` (if there isn't already a primary_key)\n    :type force_pk_id: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param emit_original_whitespace: Whether to emit an original whitespace (in docstring) or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: SQLalchemy hybrids declarative class AST\n    :rtype: ```ClassDef```\n    \"\"\"\n\n    if class_name is None and intermediate_repr[\"name\"]:\n        class_name: str = intermediate_repr[\"name\"]\n    assert class_name is not None, \"`class_name` is `None`\"\n\n    return ClassDef(\n        name=class_name,\n        bases=list(\n            map(\n                lambda class_base: Name(\n                    class_base, Load(), lineno=None, col_offset=None\n                ),\n                class_bases,\n            )\n        ),\n        decorator_list=decorator_list or [],\n        type_params=[],\n        keywords=[],\n        body=list(\n            filter(\n                None,\n                (\n                    (\n                        Expr(\n                            set_value(\n                                concat_with_whitespace(\n                                    *map(\n                                        partial(\n                                            docstring,\n                                            docstring_format=docstring_format,\n                                            emit_default_doc=emit_default_doc,\n                                            emit_original_whitespace=emit_original_whitespace,\n                                            emit_separating_tab=True,\n                                            emit_types=True,\n                                            indent_level=1,\n                                            word_wrap=word_wrap,\n                                        ),\n                                        (\n                                            {\n                                                \"doc\": intermediate_repr[\"doc\"],\n                                                \"params\": OrderedDict(),\n                                                \"returns\": None,\n                                            },\n                                            {\n                                                \"doc\": \"\",\n                                                \"params\": OrderedDict(),\n                                                \"returns\": intermediate_repr[\"returns\"],\n                                            },\n                                        ),\n                                    )\n                                )\n                            ),\n                            lineno=None,\n                            col_offset=None,\n                        )\n                        if intermediate_repr.get(\"doc\")\n                        or (intermediate_repr[\"returns\"] or {})\n                        .get(\"return_type\", {})\n                        .get(\"doc\")\n                        else None\n                    ),\n                    Assign(\n                        targets=[\n                            Name(\"__tablename__\", Store(), lineno=None, col_offset=None)\n                        ],\n                        value=set_value(table_name or class_name),\n                        expr=None,\n                        lineno=None,\n                        **maybe_type_comment,\n                    ),\n                    sqlalchemy_table(\n                        intermediate_repr=intermediate_repr,\n                        name=\"__table__\",\n                        table_name=table_name or intermediate_repr[\"name\"],\n                        force_pk_id=force_pk_id,\n                        docstring_format=docstring_format,\n                        word_wrap=word_wrap,\n                        emit_original_whitespace=emit_original_whitespace,\n                        emit_default_doc=emit_default_doc,\n                    ),\n                    (\n                        cdd.sqlalchemy.utils.emit_utils.generate_repr_method(\n                            intermediate_repr[\"params\"],\n                            class_name,\n                            docstring_format,\n                            hybrid=True,\n                        )\n                        if emit_repr\n                        else None\n                    ),\n                    (\n                        cdd.sqlalchemy.utils.emit_utils.generate_create_from_attr_staticmethod(\n                            intermediate_repr[\"params\"], class_name, docstring_format\n                        )\n                        if emit_create_from_attr\n                        else None\n                    ),\n                ),\n            )\n        ),\n        expr=None,\n        identifier_name=None,\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.emit.sqlalchemy_table","title":"sqlalchemy_table","text":"<pre><code>sqlalchemy_table(intermediate_repr, name='config_tbl', table_name=None, force_pk_id=FORCE_PK_ID, docstring_format='rest', word_wrap=True, emit_original_whitespace=False, emit_default_doc=True)\n</code></pre> <p>Construct an <code>name = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)</code></p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>name</code> <code>str</code> <p>name of binding + table</p> required <code>table_name</code> <code>str</code> <p>Table name, defaults to <code>name</code></p> <code>name</code> <code>force_pk_id</code> <code>bool</code> <p>Whether to force primary_key to be named <code>id</code> (if there isn't already a primary_key)</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>word_wrap</code> <code>bool</code> <p>Whether to word-wrap. Set <code>DOCTRANS_LINE_LENGTH</code> to configure length.</p> required <code>emit_original_whitespace</code> <code>bool</code> <p>Whether to emit original whitespace or strip it out</p> required <code>emit_default_doc</code> <code>bool</code> <p>Whether help/docstring should include 'With default' text</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>ClassDef</code> <p>AST of the Table expression + assignment</p> Source code in <code>cdd/sqlalchemy/emit.py</code> <pre><code>def sqlalchemy_table(\n    intermediate_repr,\n    name=\"config_tbl\",\n    table_name=None,\n    force_pk_id=FORCE_PK_ID,\n    docstring_format=\"rest\",\n    word_wrap=True,\n    emit_original_whitespace=False,\n    emit_default_doc=True,\n):\n    \"\"\"\n    Construct an `name = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)`\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param name: name of binding + table\n    :type name: ```str```\n\n    :param table_name: Table name, defaults to `name`\n    :type table_name: ```str```\n\n    :param force_pk_id: Whether to force primary_key to be named `id` (if there isn't already a primary_key)\n    :type force_pk_id: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param word_wrap: Whether to word-wrap. Set `DOCTRANS_LINE_LENGTH` to configure length.\n    :type word_wrap: ```bool```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param emit_original_whitespace: Whether to emit an original whitespace (in docstring) or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_original_whitespace: Whether to emit original whitespace or strip it out\n    :type emit_original_whitespace: ```bool```\n\n    :param emit_default_doc: Whether help/docstring should include 'With default' text\n    :type emit_default_doc: ```bool```\n\n    :return: AST of the Table expression + assignment\n    :rtype: ```ClassDef```\n    \"\"\"\n    return Assign(\n        targets=[\n            Name(\n                ensure_valid_identifier(\n                    name\n                    if name not in (None, \"config_tbl\") or not intermediate_repr[\"name\"]\n                    else intermediate_repr[\"name\"]\n                ),\n                Store(),\n            )\n        ],\n        value=Call(\n            func=Name(\"Table\", Load(), lineno=None, col_offset=None),\n            args=list(\n                chain.from_iterable(\n                    (\n                        iter(\n                            (\n                                set_value(name if table_name is None else table_name),\n                                Name(\"metadata\", Load(), lineno=None, col_offset=None),\n                            )\n                        ),\n                        *map(\n                            partial(\n                                cdd.sqlalchemy.utils.emit_utils.param_to_sqlalchemy_column_calls,\n                                include_name=True,\n                            ),\n                            cdd.sqlalchemy.utils.emit_utils.ensure_has_primary_key(\n                                intermediate_repr[\"params\"], force_pk_id\n                            ).items(),\n                        ),\n                    )\n                )\n            ),\n            keywords=list(\n                chain.from_iterable(\n                    (\n                        (\n                            (\n                                (\n                                    lambda val: (\n                                        (\n                                            keyword(\n                                                arg=\"comment\",\n                                                value=set_value(val),\n                                                identifier=None,\n                                                expr=None,\n                                                lineno=None,\n                                                **maybe_type_comment,\n                                            ),\n                                        )\n                                        if val\n                                        else iter(())\n                                    )\n                                )(\n                                    deindent(\n                                        add(\n                                            *map(\n                                                partial(\n                                                    docstring,\n                                                    emit_default_doc=emit_default_doc,\n                                                    docstring_format=docstring_format,\n                                                    word_wrap=word_wrap,\n                                                    emit_original_whitespace=emit_original_whitespace,\n                                                    emit_types=True,\n                                                ),\n                                                (\n                                                    {\n                                                        \"doc\": (\n                                                            intermediate_repr[\n                                                                \"doc\"\n                                                            ].lstrip()\n                                                            + \"\\n\\n\"\n                                                            if intermediate_repr[\n                                                                \"returns\"\n                                                            ]\n                                                            else \"\"\n                                                        ),\n                                                        \"params\": OrderedDict(),\n                                                        \"returns\": None,\n                                                    },\n                                                    {\n                                                        \"doc\": \"\",\n                                                        \"params\": OrderedDict(),\n                                                        \"returns\": intermediate_repr[\n                                                            \"returns\"\n                                                        ],\n                                                    },\n                                                ),\n                                            )\n                                        ).strip()\n                                    )\n                                )\n                                if intermediate_repr.get(\"doc\")\n                                else iter(())\n                            )\n                        ),\n                        (\n                            keyword(\n                                arg=\"keep_existing\",\n                                value=set_value(True),\n                                identifier=None,\n                                expr=None,\n                                lineno=None,\n                                **maybe_type_comment,\n                            ),\n                        ),\n                    )\n                )\n            ),\n            expr=None,\n            expr_func=None,\n            lineno=None,\n            col_offset=None,\n        ),\n        lineno=None,\n        expr=None,\n        **maybe_type_comment,\n    )\n</code></pre>"},{"location":"api/#cddsqlalchemyparse","title":"<code>cdd.sqlalchemy.parse</code>","text":""},{"location":"api/#cdd.sqlalchemy.parse","title":"cdd.sqlalchemy.parse","text":"<p>SQLalchemy parsers</p>"},{"location":"api/#cdd.sqlalchemy.parse--todo","title":"TODO","text":"<ul> <li>Implement update (see https://github.com/sqlalchemy/sqlalchemy/discussions/5940)</li> <li>Implement batch CRUD</li> </ul> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.sqlalchemy.parse.sqlalchemy","title":"sqlalchemy","text":"<pre><code>sqlalchemy(class_def, parse_original_whitespace=False)\n</code></pre> <p>Parse out a <code>class C(Base): __tablename__=  'tbl'; dataset_name = Column(String, doc=\"p\", primary_key=True)</code>,     as constructed on an SQLalchemy declarative <code>Base</code>.</p> <p>Also supports hybrid syntax: <code>class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)</code></p> <p>Parameters:</p> Name Type Description Default <code>class_def</code> <code>Union[ClassDef]</code> <p>A class inheriting from declarative <code>Base</code>, where <code>Base = sqlalchemy.orm.declarative_base()</code></p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/sqlalchemy/parse.py</code> <pre><code>def sqlalchemy(class_def, parse_original_whitespace=False):\n    \"\"\"\n    Parse out a `class C(Base): __tablename__=  'tbl'; dataset_name = Column(String, doc=\"p\", primary_key=True)`,\n        as constructed on an SQLalchemy declarative `Base`.\n\n    Also supports hybrid syntax: `class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)`\n\n    :param class_def: A class inheriting from declarative `Base`, where `Base = sqlalchemy.orm.declarative_base()`\n    :type class_def: ```Union[ClassDef]```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n\n    if not isinstance(class_def, ClassDef):\n        class_def: ClassDef = (\n            next(filter(rpartial(isinstance, ClassDef), class_def.body))\n            if isinstance(class_def, Module)\n            else ast.parse(getsource(class_def)).body[0]\n        )\n    assert isinstance(class_def, ClassDef), \"Expected `ClassDef` got `{!r}`\".format(\n        type(class_def).__name__\n    )\n\n    return sqlalchemy_table(\n        sqlalchemy_class_to_table(class_def, parse_original_whitespace)\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.parse.sqlalchemy_hybrid","title":"sqlalchemy_hybrid","text":"<pre><code>sqlalchemy_hybrid(class_def, parse_original_whitespace=False)\n</code></pre> <p>Parse out a <code>class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)</code>,     as constructed on an SQLalchemy declarative <code>Base</code>.</p> <p>Parameters:</p> Name Type Description Default <code>class_def</code> <code>Union[ClassDef]</code> <p>A class inheriting from declarative <code>Base</code>, where <code>Base = sqlalchemy.orm.declarative_base()</code></p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/sqlalchemy/parse.py</code> <pre><code>def sqlalchemy_hybrid(class_def, parse_original_whitespace=False):\n    \"\"\"\n    Parse out a `class TableName(Base): __table__ = sqlalchemy.Table(name, metadata, Column(\u2026), \u2026)`,\n        as constructed on an SQLalchemy declarative `Base`.\n\n    :param class_def: A class inheriting from declarative `Base`, where `Base = sqlalchemy.orm.declarative_base()`\n    :type class_def: ```Union[ClassDef]```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    return sqlalchemy(\n        class_def=class_def, parse_original_whitespace=parse_original_whitespace\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.parse.sqlalchemy_table","title":"sqlalchemy_table","text":"<pre><code>sqlalchemy_table(call_or_name, parse_original_whitespace=False)\n</code></pre> <p>Parse out a <code>sqlalchemy.Table</code>, or a <code>name = sqlalchemy.Table</code>, into the IR</p> <p>Parameters:</p> Name Type Description Default <code>call_or_name</code> <code>Union[AnnAssign, Assign, Call]</code> <p>The call to <code>sqlalchemy.Table</code> or an assignment followed by the call</p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/sqlalchemy/parse.py</code> <pre><code>def sqlalchemy_table(call_or_name, parse_original_whitespace=False):\n    \"\"\"\n    Parse out a `sqlalchemy.Table`, or a `name = sqlalchemy.Table`, into the IR\n\n    :param call_or_name: The call to `sqlalchemy.Table` or an assignment followed by the call\n    :type call_or_name: ```Union[AnnAssign, Assign, Call]```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    if isinstance(call_or_name, Assign):\n        name, call_or_name = call_or_name.targets[0].id, call_or_name.value\n    elif isinstance(call_or_name, AnnAssign):\n        name, call_or_name = call_or_name.target.id, call_or_name.value\n    else:\n        if not isinstance(call_or_name, Call):\n            call_or_name = get_value(call_or_name)\n        name = get_value(call_or_name.args[0])\n\n    # Binding should be same name as table\u2026 I guess?\n    assert_equal(get_value(call_or_name.args[0]), name)\n\n    comment: Optional[str] = next(\n        map(\n            get_value,\n            map(\n                get_value, filter(lambda kw: kw.arg == \"comment\", call_or_name.keywords)\n            ),\n        ),\n        None,\n    )\n    doc: Optional[str] = next(\n        map(\n            get_value,\n            map(get_value, filter(lambda kw: kw.arg == \"doc\", call_or_name.keywords)),\n        ),\n        None,\n    )\n    intermediate_repr: IntermediateRepr = (\n        {\"type\": None, \"doc\": \"\", \"params\": OrderedDict()}\n        if comment is None and doc is None\n        else docstring(\n            doc or comment, parse_original_whitespace=parse_original_whitespace\n        )\n    )\n    intermediate_repr[\"name\"] = name\n    assert isinstance(call_or_name, Call), \"Expected `all` got `{node_name!r}`\".format(\n        node_name=type(call_or_name).__name__\n    )\n    assert_equal(call_or_name.func.id.rpartition(\".\")[2], \"Table\")\n    assert len(call_or_name.args) &gt; 2\n\n    # Partial[IntermediateRepr]\n    merge_ir = {\n        \"params\": OrderedDict(map(column_call_to_param, call_or_name.args[2:])),\n        \"returns\": None,\n    }\n    cdd.shared.parse.utils.parser_utils.ir_merge(\n        target=intermediate_repr, other=merge_ir\n    )\n    if intermediate_repr[\"returns\"] and intermediate_repr[\"returns\"].get(\n        \"return_type\", {}\n    ).get(\"doc\"):\n        intermediate_repr[\"returns\"][\"return_type\"][\"doc\"] = extract_default(\n            intermediate_repr[\"returns\"][\"return_type\"][\"doc\"], emit_default_doc=False\n        )[0]\n\n    return intermediate_repr\n</code></pre>"},{"location":"api/#cddsqlalchemyutils","title":"<code>cdd.sqlalchemy.utils</code>","text":""},{"location":"api/#cdd.sqlalchemy.utils","title":"cdd.sqlalchemy.utils","text":"<p>SQLalchemy parsers and emitters utility module</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cddsqlalchemyutilsemit_utils","title":"<code>cdd.sqlalchemy.utils.emit_utils</code>","text":""},{"location":"api/#cdd.sqlalchemy.utils.emit_utils","title":"cdd.sqlalchemy.utils.emit_utils","text":"<p>Utility functions for <code>cdd.sqlalchemy.emit</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.ensure_has_primary_key","title":"ensure_has_primary_key","text":"<pre><code>ensure_has_primary_key(intermediate_repr, force_pk_id=False)\n</code></pre> <p>Add a primary key to the input (if nonexistent) then return the input.</p> <p>Parameters:</p> Name Type Description Default <code>intermediate_repr</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as: ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any}) IntermediateRepr = TypedDict(\"IntermediateRepr\", { \"name\": Optional[str], \"type\": Optional[str], \"doc\": Optional[str], \"params\": OrderedDict[str, ParamVal], \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]], })</p> required <code>force_pk_id</code> <code>bool</code> <p>Whether to force primary_key to be named <code>id</code> (if there isn't already a primary_key)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>dict</code> <p>a dictionary consistent with <code>IntermediateRepr</code>, defined as:     ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})     IntermediateRepr = TypedDict(\"IntermediateRepr\", {         \"name\": Optional[str],         \"type\": Optional[str],         \"doc\": Optional[str],         \"params\": OrderedDict[str, ParamVal],         \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],     })</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def ensure_has_primary_key(intermediate_repr, force_pk_id=False):\n    \"\"\"\n    Add a primary key to the input (if nonexistent) then return the input.\n\n    :param intermediate_repr: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :type intermediate_repr: ```dict```\n\n    :param force_pk_id: Whether to force primary_key to be named `id` (if there isn't already a primary_key)\n    :type force_pk_id: ```bool```\n\n    :return: a dictionary consistent with `IntermediateRepr`, defined as:\n        ParamVal = TypedDict(\"ParamVal\", {\"typ\": str, \"doc\": Optional[str], \"default\": Any})\n        IntermediateRepr = TypedDict(\"IntermediateRepr\", {\n            \"name\": Optional[str],\n            \"type\": Optional[str],\n            \"doc\": Optional[str],\n            \"params\": OrderedDict[str, ParamVal],\n            \"returns\": Optional[OrderedDict[Literal[\"return_type\"], ParamVal]],\n        })\n    :rtype: ```dict```\n    \"\"\"\n    params: OrderedDict[str, ParamVal] = (\n        intermediate_repr\n        if isinstance(intermediate_repr, OrderedDict)\n        else intermediate_repr[\"params\"]\n    )\n    if not any(\n        filter(\n            rpartial(str.startswith, \"[PK]\"),\n            map(\n                methodcaller(\"get\", \"doc\", \"\"),\n                params.values(),\n            ),\n        )\n    ):\n        candidate_pks: List[str] = []\n        deque(\n            map(\n                candidate_pks.append,\n                filter(\n                    lambda k: \"_name\" in k or \"_id\" in k or \"id_\" in k or k == \"id\",\n                    params.keys(),\n                ),\n            ),\n            maxlen=0,\n        )\n        if not force_pk_id and len(candidate_pks) == 1:\n            params[candidate_pks[0]][\"doc\"] = (\n                \"[PK] {}\".format(params[candidate_pks[0]][\"doc\"])\n                if params[candidate_pks[0]].get(\"doc\")\n                else \"[PK]\"\n            )\n        elif \"id\" in intermediate_repr.get(\"params\", iter(())):\n            params[\"id\"][\"doc\"] = (\n                \"[PK] {}\".format(params[\"id\"][\"doc\"])\n                if params[\"id\"].get(\"doc\")\n                else \"[PK]\"\n            )\n        else:\n            assert \"id\" not in intermediate_repr.get(\n                \"params\", iter(())\n            ), \"Primary key unable to infer and column `id` already taken\"\n            params[\"id\"] = {\n                \"doc\": \"[PK]\",\n                \"typ\": \"int\",\n                \"x_typ\": {\n                    \"sql\": {\n                        \"constraints\": {\n                            \"server_default\": Call(\n                                args=[],\n                                func=Name(\n                                    \"Identity\", Load(), lineno=None, col_offset=None\n                                ),\n                                keywords=[],\n                                lineno=None,\n                                col_offset=None,\n                            )\n                        }\n                    }\n                },\n            }\n    return intermediate_repr\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.generate_create_from_attr_staticmethod","title":"generate_create_from_attr_staticmethod","text":"<pre><code>generate_create_from_attr_staticmethod(params, cls_name, docstring_format)\n</code></pre> <p>Generate a <code>__repr__</code> method with all params, using <code>str.format</code> syntax</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>OrderedDict</code> <p>an <code>OrderedDict</code> of form OrderedDict[str, {'typ': str, 'doc': Optional[str], 'default': Any}]</p> required <code>cls_name</code> <code>str</code> <p>Name of class</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p><code>__repr__</code> method</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def generate_create_from_attr_staticmethod(params, cls_name, docstring_format):\n    \"\"\"\n    Generate a `__repr__` method with all params, using `str.format` syntax\n\n    :param params: an `OrderedDict` of form\n        OrderedDict[str, {'typ': str, 'doc': Optional[str], 'default': Any}]\n    :type params: ```OrderedDict```\n\n    :param cls_name: Name of class\n    :type cls_name: ```str```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :return: `__repr__` method\n    :rtype: ```FunctionDef```\n    \"\"\"\n    keys = tuple(params.keys())  # type: tuple[str, ...]\n    return FunctionDef(\n        name=\"create_from_attr\",\n        args=arguments(\n            posonlyargs=[],\n            arg=None,\n            args=[cdd.shared.ast_utils.set_arg(\"record\")],\n            kwonlyargs=[],\n            kw_defaults=[],\n            defaults=[],\n            vararg=None,\n            kwarg=None,\n        ),\n        body=[\n            Expr(\n                cdd.shared.ast_utils.set_value(\n                    \"\"\"\\n{sep}{_repr_docstring}\"\"\".format(\n                        sep=tab * 2,\n                        _repr_docstring=(\n                            docstring_create_from_attr_str\n                            if docstring_format == \"rest\"\n                            else docstring_create_from_attr_google_str\n                        )\n                        .replace(\"self\", cls_name)\n                        .lstrip(),\n                    )\n                ),\n                lineno=None,\n                col_offset=None,\n            ),\n            Return(\n                value=Call(\n                    func=Name(cls_name, Load(), lineno=None, col_offset=None),\n                    args=[],\n                    keywords=[\n                        keyword(\n                            arg=None,\n                            value=DictComp(\n                                key=Name(\n                                    id=\"attr\", ctx=Load(), lineno=None, col_offset=None\n                                ),\n                                value=Call(\n                                    func=Name(\n                                        id=\"getattr\",\n                                        ctx=Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    ),\n                                    args=[\n                                        Name(\n                                            id=\"record\",\n                                            ctx=Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        Name(\n                                            id=\"attr\",\n                                            ctx=Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                    ],\n                                    keywords=[],\n                                    lineno=None,\n                                    col_offset=None,\n                                ),\n                                generators=[\n                                    comprehension(\n                                        target=Name(\n                                            id=\"attr\",\n                                            ctx=Store(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        iter=Tuple(\n                                            elts=list(\n                                                map(\n                                                    cdd.shared.ast_utils.set_value, keys\n                                                )\n                                            ),\n                                            ctx=Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        ifs=[\n                                            Compare(\n                                                left=Call(\n                                                    func=Name(\n                                                        id=\"getattr\",\n                                                        ctx=Load(),\n                                                        lineno=None,\n                                                        col_offset=None,\n                                                    ),\n                                                    args=[\n                                                        Name(\n                                                            id=\"record\",\n                                                            ctx=Load(),\n                                                            lineno=None,\n                                                            col_offset=None,\n                                                        ),\n                                                        Name(\n                                                            id=\"attr\",\n                                                            ctx=Load(),\n                                                            lineno=None,\n                                                            col_offset=None,\n                                                        ),\n                                                        cdd.shared.ast_utils.set_value(\n                                                            None\n                                                        ),\n                                                    ],\n                                                    keywords=[],\n                                                    lineno=None,\n                                                    col_offset=None,\n                                                ),\n                                                ops=[IsNot()],\n                                                comparators=[\n                                                    cdd.shared.ast_utils.set_value(None)\n                                                ],\n                                                lineno=None,\n                                                col_offset=None,\n                                            )\n                                        ],\n                                        is_async=0,\n                                    )\n                                ],\n                                lineno=None,\n                                col_offset=None,\n                            ),\n                            identifier=None,\n                        )\n                    ],\n                    expr=None,\n                    expr_func=None,\n                    lineno=None,\n                    col_offset=None,\n                ),\n                expr=None,\n            ),\n        ],\n        decorator_list=[Name(\"staticmethod\", Load(), lineno=None, col_offset=None)],\n        arguments_args=None,\n        identifier_name=None,\n        stmt=None,\n        lineno=None,\n        returns=None,\n        **cdd.shared.ast_utils.maybe_type_comment,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.generate_create_tables_mod","title":"generate_create_tables_mod","text":"<pre><code>generate_create_tables_mod(module_name)\n</code></pre> <p>Generate the <code>Base.metadata.create_all(engine)</code> for SQLalchemy</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Module to import from</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Module</code> <p>Module with imports for SQLalchemy</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def generate_create_tables_mod(module_name):\n    \"\"\"\n    Generate the `Base.metadata.create_all(engine)` for SQLalchemy\n\n    :param module_name: Module to import from\n    :type module_name: ```str```\n\n    :return: Module with imports for SQLalchemy\n    :rtype: ```Module```\n    \"\"\"\n    return Module(\n        body=[\n            ImportFrom(\n                module=module_name,\n                names=list(\n                    map(\n                        lambda name: alias(\n                            name=name,\n                            asname=None,\n                            identifier=None,\n                            identifier_name=None,\n                        ),\n                        (\"Base\", \"engine\"),\n                    )\n                ),\n                level=0,\n            ),\n            If(\n                test=Compare(\n                    left=Name(\n                        \"__name__\",\n                        Load(),\n                        lineno=None,\n                        col_offset=None,\n                    ),\n                    ops=[Eq()],\n                    comparators=[cdd.shared.ast_utils.set_value(\"__main__\")],\n                ),\n                body=[\n                    Expr(\n                        value=Call(\n                            func=Name(\n                                \"print\",\n                                Load(),\n                                lineno=None,\n                                col_offset=None,\n                            ),\n                            args=[\n                                cdd.shared.ast_utils.set_value(\n                                    \"Base.metadata.create_all for\"\n                                ),\n                                Attribute(\n                                    value=Name(\n                                        id=\"engine\",\n                                        ctx=Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    ),\n                                    attr=\"name\",\n                                    ctx=Load(),\n                                    lineno=None,\n                                    col_offset=None,\n                                ),\n                                cdd.shared.ast_utils.set_value(\"-&gt; (\"),\n                                Call(\n                                    func=Attribute(\n                                        value=cdd.shared.ast_utils.set_value(\", \"),\n                                        attr=\"join\",\n                                        ctx=Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    ),\n                                    args=[\n                                        Call(\n                                            func=Attribute(\n                                                value=Attribute(\n                                                    value=Attribute(\n                                                        value=Name(\n                                                            id=\"Base\", ctx=Load()\n                                                        ),\n                                                        attr=\"metadata\",\n                                                        ctx=Load(),\n                                                        lineno=None,\n                                                        col_offset=None,\n                                                    ),\n                                                    attr=\"tables\",\n                                                    ctx=Load(),\n                                                    lineno=None,\n                                                    col_offset=None,\n                                                ),\n                                                attr=\"keys\",\n                                                ctx=Load(),\n                                                lineno=None,\n                                                col_offset=None,\n                                            ),\n                                            args=[],\n                                            keywords=[],\n                                        )\n                                    ],\n                                    keywords=[],\n                                ),\n                                cdd.shared.ast_utils.set_value(\") ;\"),\n                            ],\n                            keywords=[],\n                        )\n                    ),\n                    Expr(\n                        value=Call(\n                            func=Attribute(\n                                value=Attribute(\n                                    value=Name(\n                                        \"Base\",\n                                        Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    ),\n                                    attr=\"metadata\",\n                                    ctx=Load(),\n                                    lineno=None,\n                                    col_offset=None,\n                                ),\n                                attr=\"create_all\",\n                                ctx=Load(),\n                                lineno=None,\n                                col_offset=None,\n                            ),\n                            args=[\n                                Name(\n                                    \"engine\",\n                                    Load(),\n                                    lineno=None,\n                                    col_offset=None,\n                                )\n                            ],\n                            keywords=[],\n                        )\n                    ),\n                ],\n                orelse=[],\n            ),\n        ],\n        type_ignores=[],\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.generate_repr_method","title":"generate_repr_method","text":"<pre><code>generate_repr_method(params, cls_name, docstring_format, hybrid=False)\n</code></pre> <p>Generate a <code>__repr__</code> method with all params, using <code>str.format</code> syntax</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>OrderedDict</code> <p>an <code>OrderedDict</code> of form OrderedDict[str, {'typ': str, 'doc': Optional[str], 'default': Any}]</p> required <code>cls_name</code> <code>str</code> <p>Name of class</p> required <code>docstring_format</code> <code>Literal['rest', 'numpydoc', 'google']</code> <p>Format of docstring</p> required <code>hybrid</code> <code>bool</code> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>FunctionDef</code> <p><code>__repr__</code> method</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def generate_repr_method(params, cls_name, docstring_format, hybrid=False):\n    \"\"\"\n    Generate a `__repr__` method with all params, using `str.format` syntax\n\n    :param params: an `OrderedDict` of form\n        OrderedDict[str, {'typ': str, 'doc': Optional[str], 'default': Any}]\n    :type params: ```OrderedDict```\n\n    :param cls_name: Name of class\n    :type cls_name: ```str```\n\n    :param docstring_format: Format of docstring\n    :type docstring_format: ```Literal['rest', 'numpydoc', 'google']```\n\n    :param hybrid:\n    :type hybrid: ```bool```\n\n    :return: `__repr__` method\n    :rtype: ```FunctionDef```\n    \"\"\"\n    keys = tuple(params.keys())  # type: tuple[str, ...]\n    return FunctionDef(\n        name=\"__repr__\",\n        args=arguments(\n            posonlyargs=[],\n            arg=None,\n            args=[cdd.shared.ast_utils.set_arg(\"self\")],\n            kwonlyargs=[],\n            kw_defaults=[],\n            defaults=[],\n            vararg=None,\n            kwarg=None,\n        ),\n        body=[\n            Expr(\n                cdd.shared.ast_utils.set_value(\n                    \"\"\"\\n{sep}{_repr_docstring}\"\"\".format(\n                        sep=tab * 2,\n                        _repr_docstring=(\n                            docstring_repr_str\n                            if docstring_format == \"rest\"\n                            else docstring_repr_google_str\n                        ).lstrip(),\n                    )\n                ),\n                lineno=None,\n                col_offset=None,\n            ),\n            Return(\n                value=Call(\n                    func=Attribute(\n                        cdd.shared.ast_utils.set_value(\n                            \"{cls_name}({format_args})\".format(\n                                cls_name=cls_name,\n                                format_args=\", \".join(\n                                    map(\"{0}={{{0}!r}}\".format, keys)\n                                ),\n                            )\n                        ),\n                        \"format\",\n                        Load(),\n                        lineno=None,\n                        col_offset=None,\n                    ),\n                    args=[],\n                    keywords=list(\n                        map(\n                            lambda key: ast.keyword(\n                                arg=key,\n                                value=(\n                                    Attribute(\n                                        value=Attribute(\n                                            value=Attribute(\n                                                value=Name(id=\"self\", ctx=Load()),\n                                                attr=\"__table__\",\n                                                ctx=Load(),\n                                                lineno=None,\n                                                col_offset=None,\n                                            ),\n                                            attr=\"c\",\n                                            ctx=Load(),\n                                            lineno=None,\n                                            col_offset=None,\n                                        ),\n                                        attr=key,\n                                        ctx=Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    )\n                                    if hybrid\n                                    else Attribute(\n                                        Name(\n                                            \"self\", Load(), lineno=None, col_offset=None\n                                        ),\n                                        key,\n                                        Load(),\n                                        lineno=None,\n                                        col_offset=None,\n                                    )\n                                ),\n                                identifier=None,\n                            ),\n                            keys,\n                        )\n                    ),\n                    expr=None,\n                    expr_func=None,\n                    lineno=None,\n                    col_offset=None,\n                ),\n                expr=None,\n            ),\n        ],\n        decorator_list=[],\n        type_params=[],\n        arguments_args=None,\n        identifier_name=None,\n        stmt=None,\n        lineno=None,\n        returns=None,\n        **cdd.shared.ast_utils.maybe_type_comment,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.param_to_sqlalchemy_column_calls","title":"param_to_sqlalchemy_column_calls","text":"<pre><code>param_to_sqlalchemy_column_calls(name_param, include_name)\n</code></pre> <p>Turn a param into <code>Column(\u2026)</code>s</p> <p>Parameters:</p> Name Type Description Default <code>name_param</code> <code>dict</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> required <code>include_name</code> <code>bool</code> <p>Whether to include the name (exclude in declarative base)</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Iterable[Call]</code> <p>Iterable of elements in form of: <code>Column(\u2026)</code></p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def param_to_sqlalchemy_column_calls(name_param, include_name):\n    \"\"\"\n    Turn a param into `Column(\u2026)`s\n\n    :param name_param: Name, dict with keys: 'typ', 'doc', 'default'\n    :type name_param: ```tuple[str, dict]```\n\n    :param include_name: Whether to include the name (exclude in declarative base)\n    :type include_name: ```bool```\n\n    :return: Iterable of elements in form of: `Column(\u2026)`\n    :rtype: ```Iterable[Call]```\n    \"\"\"\n    if system() == \"Darwin\":\n        print(\"param_to_sqlalchemy_column_calls::include_name:\", include_name, \";\")\n    name, _param = name_param\n    del name_param\n\n    args, keywords, nullable = [], [], None\n\n    nullable, x_typ_sql = _handle_column_args(\n        _param, args, include_name, name, nullable\n    )\n\n    default = x_typ_sql.get(\"default\", _param.get(\"default\", ast))\n    has_default: bool = default is not ast\n    pk: bool = _param.get(\"doc\", \"\").startswith(\"[PK]\")\n    fk: bool = _param.get(\"doc\", \"\").startswith(\"[FK\")\n    if pk:\n        _param[\"doc\"] = _param[\"doc\"][4:].lstrip()\n        keywords.append(\n            ast.keyword(\n                arg=\"primary_key\",\n                value=cdd.shared.ast_utils.set_value(True),\n                identifier=None,\n            ),\n        )\n    elif fk:\n        end: int = _param[\"doc\"].find(\"]\") + 1\n        fk_val: str = _param[\"doc\"][len(\"[FK(\") : end - len(\")]\")]\n        _param[\"doc\"] = _param[\"doc\"][end:].lstrip()\n        args.append(\n            Call(\n                func=Name(\"ForeignKey\", Load(), lineno=None, col_offset=None),\n                args=[cdd.shared.ast_utils.set_value(fk_val)],\n                keywords=[],\n                lineno=None,\n                col_offset=None,\n            )\n        )\n    elif has_default and default not in none_types:\n        nullable: bool = False\n\n    keywords = _handle_column_keywords(\n        _param, default, has_default, keywords, nullable, x_typ_sql\n    )\n\n    # elif _param[\"doc\"]:\n    #     keywords.append(\n    #         ast.keyword(arg=\"comment\", value=set_value(_param[\"doc\"]), identifier=None)\n    #     )\n\n    # TODO:\n    # if multiple:\n    #     Call(\n    #         func=Name(\"Column\", Load(), lineno=None, col_offset=None),\n    #         args=args,\n    #         keywords=sorted(keywords, key=attrgetter(\"arg\")),\n    #         expr=None,\n    #         expr_func=None,\n    #         lineno=None,\n    #         col_offset=None,\n    #     )\n    return (\n        Call(\n            func=Name(\"Column\", Load(), lineno=None, col_offset=None),\n            args=args,\n            keywords=sorted(keywords, key=attrgetter(\"arg\")),\n            expr=None,\n            expr_func=None,\n            lineno=None,\n            col_offset=None,\n        ),\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.rewrite_fk","title":"rewrite_fk","text":"<pre><code>rewrite_fk(symbol_to_module, column_assign)\n</code></pre> <p>Rewrite of the form: <pre><code>column_name = Column(\n    TableName0,\n    ForeignKey(\"TableName0\"),\n    nullable=True,\n)\n</code></pre> To the following, inferring that the primary key field is <code>id</code> by resolving the symbol and <code>ast.parse</code>ing it: <pre><code>column_name = Column(Integer, ForeignKey(\"table_name0.id\"))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>symbol_to_module</code> <code>Dict[str,str]`</code> <p>Dictionary of symbol to module, like <code>{\"join\": \"os.path\"}</code></p> required <code>column_assign</code> <code>Assign</code> <p><code>column_name = Column()</code> in SQLalchemy with unresolved foreign key</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Assign</code> <p><code>Assign()</code> in SQLalchemy with resolved foreign key</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def rewrite_fk(symbol_to_module, column_assign):\n    \"\"\"\n    Rewrite of the form:\n    ```py\n    column_name = Column(\n        TableName0,\n        ForeignKey(\"TableName0\"),\n        nullable=True,\n    )\n    ```\n    To the following, inferring that the primary key field is `id` by resolving the symbol and `ast.parse`ing it:\n    ```py\n    column_name = Column(Integer, ForeignKey(\"table_name0.id\"))\n    ```\n\n    :param symbol_to_module: Dictionary of symbol to module, like `{\"join\": \"os.path\"}`\n    :type symbol_to_module: ```Dict[str,str]````\n\n    :param column_assign: `column_name = Column()` in SQLalchemy with unresolved foreign key\n    :type column_assign: ```Assign```\n\n    :return: `Assign()` in SQLalchemy with resolved foreign key\n    :rtype: ```Assign```\n    \"\"\"\n    assert (\n        isinstance(column_assign.value, Call)\n        and isinstance(column_assign.value.func, Name)\n        and column_assign.value.func.id == \"Column\"\n    ), 'Expected `Call.func.Name.id` of \"&lt;var&gt; = Column\" eval to `&lt;var&gt; = Column(...)` got `{code}`'.format(\n        code=cdd.shared.source_transformer.to_code(column_assign).rstrip()\n    )\n\n    def rewrite_fk_from_import(column_name, foreign_key_call):\n        \"\"\"\n        :param column_name: Field name\n        :type column_name: ```Name```\n\n        :param foreign_key_call: `ForeignKey` function call\n        :type foreign_key_call: ```Call```\n\n        :return:\n        :rtype: ```tuple[Name, Call]```\n        \"\"\"\n        assert isinstance(\n            column_name, Name\n        ), \"Expected `Name` got `{type_name}`\".format(\n            type_name=type(column_name).__name__\n        )\n        assert (\n            isinstance(foreign_key_call, Call)\n            and isinstance(foreign_key_call.func, Name)\n            and foreign_key_call.func.id == \"ForeignKey\"\n        ), 'Expected `Call.func.Name.id` of \"ForeignKey\" eval to `ForeignKey(...)` got `{code}`'.format(\n            code=cdd.shared.source_transformer.to_code(foreign_key_call).rstrip()\n        )\n        if column_name.id in symbol_to_module:\n            with open(\n                find_module_filepath(symbol_to_module[column_name.id], column_name.id),\n                \"rt\",\n            ) as f:\n                mod: Module = ast.parse(f.read())\n            matching_class: ClassDef = next(\n                filter(\n                    lambda node: isinstance(node, ClassDef)\n                    and node.name == column_name.id,\n                    mod.body,\n                )\n            )\n            pk_typ = get_pk_and_type(matching_class)  # type: tuple[str, str]\n            assert pk_typ is not None\n            pk, typ = pk_typ\n            del pk_typ\n            return Name(typ, Load(), lineno=None, col_offset=None), Call(\n                func=Name(\"ForeignKey\", Load(), lineno=None, col_offset=None),\n                args=[\n                    cdd.shared.ast_utils.set_value(\n                        \".\".join((get_table_name(matching_class), pk))\n                    )\n                ],\n                keywords=[],\n                lineno=None,\n                col_offset=None,\n            )\n        return column_name, foreign_key_call\n\n    column_assign.value.args = list(\n        chain.from_iterable(\n            (\n                rewrite_fk_from_import(*column_assign.value.args[:2]),\n                column_assign.value.args[2:],\n            )\n        )\n    )\n\n    return column_assign\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.sqlalchemy_class_to_table","title":"sqlalchemy_class_to_table","text":"<pre><code>sqlalchemy_class_to_table(class_def, parse_original_whitespace)\n</code></pre> <p>Convert SQLalchemy class to SQLalchemy Table expression</p> <p>Parameters:</p> Name Type Description Default <code>class_def</code> <code>ClassDef</code> <p>A class inheriting from declarative <code>Base</code>, where <code>Base = sqlalchemy.orm.declarative_base()</code></p> required <code>parse_original_whitespace</code> <code>bool</code> <p>Whether to parse original whitespace or strip it out</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Call</code> <p>SQLalchemy <code>Table</code> expression</p> Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def sqlalchemy_class_to_table(class_def, parse_original_whitespace):\n    \"\"\"\n    Convert SQLalchemy class to SQLalchemy Table expression\n\n    :param class_def: A class inheriting from declarative `Base`, where `Base = sqlalchemy.orm.declarative_base()`\n    :type class_def: ```ClassDef```\n\n    :param parse_original_whitespace: Whether to parse original whitespace or strip it out\n    :type parse_original_whitespace: ```bool```\n\n    :return: SQLalchemy `Table` expression\n    :rtype: ```Call```\n    \"\"\"\n    assert isinstance(\n        class_def, ClassDef\n    ), \"Expected `ClassDef` got `{type_name}`\".format(\n        type_name=type(class_def).__name__\n    )\n\n    # Hybrid SQLalchemy class/table handler\n    table_dunder: Optional[Call] = next(\n        filter(\n            lambda assign: any(\n                filter(\n                    partial(eq, \"__table__\"),\n                    map(attrgetter(\"id\"), assign.targets),\n                )\n            ),\n            filter(rpartial(isinstance, Assign), class_def.body),\n        ),\n        None,\n    )\n    if table_dunder is not None:\n        return table_dunder\n\n    # Parse into the same format that `sqlalchemy_table` can read, then return with a call to it\n\n    name: str = cdd.shared.ast_utils.get_value(\n        next(\n            filter(\n                lambda assign: any(\n                    filter(\n                        partial(eq, \"__tablename__\"),\n                        map(attrgetter(\"id\"), assign.targets),\n                    )\n                ),\n                filter(rpartial(isinstance, Assign), class_def.body),\n            )\n        ).value\n    )\n    doc_string: Optional[str] = ast.get_docstring(\n        class_def, clean=parse_original_whitespace\n    )\n\n    def _merge_name_to_column(assign):\n        \"\"\"\n        Merge `a = Column()` into `Column(\"a\")`\n\n        :param assign: Of form `a = Column()`\n        :type assign: ```Assign```\n\n        :return: Unwrapped Call with name prepended\n        :rtype: ```Call```\n        \"\"\"\n        assign.value.args.insert(\n            0, cdd.shared.ast_utils.set_value(assign.targets[0].id)\n        )\n        return assign.value\n\n    return Call(\n        func=Name(\"Table\", Load(), lineno=None, col_offset=None),\n        args=list(\n            chain.from_iterable(\n                (\n                    (\n                        cdd.shared.ast_utils.set_value(name),\n                        Name(\"metadata_obj\", Load()),\n                    ),\n                    map(\n                        _merge_name_to_column,\n                        filterfalse(\n                            lambda assign: any(\n                                map(\n                                    lambda target: target.id == \"__tablename__\"\n                                    or hasattr(target, \"value\")\n                                    and isinstance(target.value, Call)\n                                    and target.func.rpartition(\".\")[2] == \"Column\",\n                                    assign.targets,\n                                ),\n                            ),\n                            filter(rpartial(isinstance, Assign), class_def.body),\n                        ),\n                    ),\n                )\n            )\n        ),\n        keywords=list(\n            chain.from_iterable(\n                (\n                    (\n                        iter(())\n                        if doc_string is None\n                        else (\n                            keyword(\n                                arg=\"comment\",\n                                value=cdd.shared.ast_utils.set_value(doc_string),\n                                identifier=None,\n                            ),\n                        )\n                    ),\n                    (\n                        keyword(\n                            arg=\"keep_existing\",\n                            value=cdd.shared.ast_utils.set_value(True),\n                            identifier=None,\n                            expr=None,\n                            lineno=None,\n                            **cdd.shared.ast_utils.maybe_type_comment,\n                        ),\n                    ),\n                )\n            )\n        ),\n        expr=None,\n        expr_func=None,\n        lineno=None,\n        col_offset=None,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.sqlalchemy_table_to_class","title":"sqlalchemy_table_to_class","text":"<pre><code>sqlalchemy_table_to_class(table_expr_ass)\n</code></pre> <p>Convert <code>table_name = Table(column_name)</code> to `class table_name(Base): column_name</p> <p>Parameters:</p> Name Type Description Default Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def sqlalchemy_table_to_class(table_expr_ass):\n    \"\"\"Convert `table_name = Table(column_name)` to `class table_name(Base): column_name\"\"\"\n    assert isinstance(\n        table_expr_ass, Assign\n    ), \"Expected `Assign` got `{type_name}`\".format(\n        type_name=type(table_expr_ass).__name__\n    )\n    assert len(table_expr_ass.targets) == 1 and isinstance(\n        table_expr_ass.targets[0], Name\n    )\n    assert len(table_expr_ass.value.args) &gt; 1\n\n    return ClassDef(\n        name=table_expr_ass.targets[0].id,\n        bases=[Name(\"Base\", Load(), lineno=None, col_offset=None)],\n        keywords=[],\n        body=list(\n            chain.from_iterable(\n                (\n                    (\n                        Assign(\n                            targets=[\n                                Name(\n                                    \"__tablename__\",\n                                    Store(),\n                                    lineno=None,\n                                    col_offset=None,\n                                )\n                            ],\n                            value=cdd.shared.ast_utils.set_value(\n                                cdd.shared.ast_utils.get_value(\n                                    table_expr_ass.value.args[0]\n                                )\n                            ),\n                            expr=None,\n                            lineno=None,\n                            **cdd.shared.ast_utils.maybe_type_comment,\n                        ),\n                    ),\n                    map(\n                        lambda column_call: Assign(\n                            targets=[\n                                Name(\n                                    cdd.shared.ast_utils.get_value(column_call.args[0]),\n                                    Store(),\n                                    lineno=None,\n                                    col_offset=None,\n                                )\n                            ],\n                            value=Call(\n                                func=column_call.func,\n                                args=(\n                                    column_call.args[1:]\n                                    if len(column_call.args) &gt; 1\n                                    else []\n                                ),\n                                keywords=column_call.keywords,\n                                expr=None,\n                                expr_func=None,\n                            ),\n                            expr=None,\n                            lineno=None,\n                            **cdd.shared.ast_utils.maybe_type_comment,\n                        ),\n                        filter(\n                            lambda node: isinstance(node, Call)\n                            and isinstance(node.func, Name)\n                            and node.func.id == \"Column\",\n                            table_expr_ass.value.args[2:],\n                        ),\n                    ),\n                )\n            )\n        ),\n        decorator_list=[],\n        type_params=[],\n        expr=None,\n        lineno=None,\n        col_offset=None,\n        end_lineno=None,\n        end_col_offset=None,\n        identifier_name=None,\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.update_fk_for_file","title":"update_fk_for_file","text":"<pre><code>update_fk_for_file(filename)\n</code></pre> <p>Given an existing filename, use its imports and to replace its foreign keys with the correct values</p> <p>This is subsequent phase process, and must be preceded by: - All SQLalchemy models being in the same directory as filename - Correct imports being added</p> <p>Then it can transform classes with members like: <pre><code>Column(\n        TableName0,\n        ForeignKey(\"TableName0\"),\n        nullable=True,\n    )\n</code></pre> To the following, inferring that the primary key field is <code>id</code> by resolving the symbol and <code>ast.parse</code>ing it: <pre><code>Column(Integer, ForeignKey(\"table_name0.id\"))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filename</p> required Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def update_fk_for_file(filename):\n    \"\"\"\n    Given an existing filename, use its imports and to replace its foreign keys with the correct values\n\n    This is subsequent phase process, and must be preceded by:\n    - All SQLalchemy models being in the same directory as filename\n    - Correct imports being added\n\n    Then it can transform classes with members like:\n    ```py\n    Column(\n            TableName0,\n            ForeignKey(\"TableName0\"),\n            nullable=True,\n        )\n    ```\n    To the following, inferring that the primary key field is `id` by resolving the symbol and `ast.parse`ing it:\n    ```py\n    Column(Integer, ForeignKey(\"table_name0.id\"))\n    ```\n\n    :param filename: Filename\n    :type filename: ```str```\n    \"\"\"\n    with open(filename, \"rt\") as f:\n        mod: Module = ast.parse(f.read())\n\n    def handle_sqlalchemy_cls(symbol_to_module, sqlalchemy_class_def):\n        \"\"\"\n        Ensure the SQLalchemy classes have their foreign keys resolved properly\n\n        :param symbol_to_module: Dictionary of symbol to module, like `{\"join\": \"os.path\"}`\n        :type symbol_to_module: ```Dict[str,str]````\n\n        :param sqlalchemy_class_def: SQLalchemy `class`\n        :type sqlalchemy_class_def: ```ClassDef```\n\n        :return: SQLalchemy with foreign keys resolved properly\n        :rtype: ```ClassDef```\n        \"\"\"\n        sqlalchemy_class_def.body = list(\n            map(\n                lambda outer_node: (\n                    rewrite_fk(symbol_to_module, outer_node)\n                    if isinstance(outer_node, Assign)\n                    and isinstance(outer_node.value, Call)\n                    and isinstance(outer_node.value.func, Name)\n                    and outer_node.value.func.id == \"Column\"\n                    and any(\n                        filter(\n                            lambda node: isinstance(node, Call)\n                            and isinstance(node.func, Name)\n                            and node.func.id == \"ForeignKey\",\n                            outer_node.value.args,\n                        )\n                    )\n                    else outer_node\n                ),\n                sqlalchemy_class_def.body,\n            )\n        )\n        return sqlalchemy_class_def\n\n    symbol2module: Dict[str, Any] = dict(\n        chain.from_iterable(\n            map(\n                lambda import_from: map(\n                    lambda _alias: (_alias.name, import_from.module), import_from.names\n                ),\n                filterfalse(\n                    lambda import_from: import_from.module == \"sqlalchemy\",\n                    filter(\n                        rpartial(isinstance, ImportFrom),\n                        ast.walk(mod),\n                    ),\n                ),\n            )\n        )\n    )\n\n    mod.body = list(\n        map(\n            lambda node: (\n                handle_sqlalchemy_cls(symbol2module, node)\n                if isinstance(node, ClassDef)\n                and any(\n                    filter(\n                        lambda base: isinstance(base, Name) and base.id == \"Base\",\n                        node.bases,\n                    )\n                )\n                else node\n            ),\n            mod.body,\n        )\n    )\n\n    with open(filename, \"wt\") as f:\n        f.write(cdd.shared.source_transformer.to_code(mod))\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.emit_utils.update_with_imports_from_columns","title":"update_with_imports_from_columns","text":"<pre><code>update_with_imports_from_columns(filename)\n</code></pre> <p>Given an existing filename, figure out its relative imports</p> <p>This is subsequent phase process, and must be preceded by: - All SQLalchemy models being in the same directory as filename</p> <p>It will take: <pre><code>Column(TableName0,\n       ForeignKey(\"TableName0\"),\n       nullable=True)\n</code></pre> \u2026and add this import: <pre><code>from `basename(filename)`.table_name import TableName0\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Python filename containing SQLalchemy <code>class</code>(es)</p> required Source code in <code>cdd/sqlalchemy/utils/emit_utils.py</code> <pre><code>def update_with_imports_from_columns(filename):\n    \"\"\"\n    Given an existing filename, figure out its relative imports\n\n    This is subsequent phase process, and must be preceded by:\n    - All SQLalchemy models being in the same directory as filename\n\n    It will take:\n    ```py\n    Column(TableName0,\n           ForeignKey(\"TableName0\"),\n           nullable=True)\n    ```\n    \u2026and add this import:\n    ```py\n    from `basename(filename)`.table_name import TableName0\n    ```\n\n    :param filename: Python filename containing SQLalchemy `class`(es)\n    :type filename: ```str```\n    \"\"\"\n    with open(filename, \"rt\") as f:\n        mod: Module = ast.parse(f.read())\n\n    candidates = sorted(\n        frozenset(\n            filter(\n                str.istitle,\n                filterfalse(\n                    frozenset(\n                        (\"complex\", \"float\", \"int\", \"list\", \"long\", \"self\", \"string\")\n                    ).__contains__,\n                    filterfalse(\n                        sqlalchemy_top_level_imports.__contains__,\n                        map(\n                            attrgetter(\"id\"),\n                            filter(\n                                rpartial(isinstance, Name),\n                                ast.walk(\n                                    Module(\n                                        body=list(\n                                            filter(\n                                                rpartial(isinstance, Call),\n                                                ast.walk(mod),\n                                            )\n                                        ),\n                                        type_ignores=[],\n                                        stmt=None,\n                                    )\n                                ),\n                            ),\n                        ),\n                    ),\n                ),\n            )\n        )\n    )\n\n    module: str = path.basename(path.dirname(filename))\n    mod.body = list(\n        chain.from_iterable(\n            (\n                map(\n                    lambda class_name: ImportFrom(\n                        module=\".\".join(\n                            (module, namespaced_upper_camelcase_to_pascal(class_name))\n                        ),\n                        names=[\n                            alias(\n                                class_name,\n                                None,\n                                identifier=None,\n                                identifier_name=None,\n                            )\n                        ],\n                        level=0,\n                    ),\n                    candidates,\n                ),\n                mod.body,\n            )\n        )\n    )\n\n    with open(filename, \"wt\") as f:\n        f.write(cdd.shared.source_transformer.to_code(mod))\n</code></pre>"},{"location":"api/#cddsqlalchemyutilsparse_utils","title":"<code>cdd.sqlalchemy.utils.parse_utils</code>","text":""},{"location":"api/#cdd.sqlalchemy.utils.parse_utils","title":"cdd.sqlalchemy.utils.parse_utils","text":"<p>Utility functions for <code>cdd.parse.sqlalchemy</code></p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.column_call_name_manipulator","title":"column_call_name_manipulator","text":"<pre><code>column_call_name_manipulator(call, operation='remove', name=None)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Call``</code> <p><code>Column</code> function call within SQLalchemy</p> required <code>operation</code> <code>Literal[\"remove\", \"add\"]</code> required <code>name</code> <code>str</code> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Call</code> <p>Column call</p> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def column_call_name_manipulator(call, operation=\"remove\", name=None):\n    \"\"\"\n    :param call: `Column` function call within SQLalchemy\n    :type call: ```Call``\n\n    :param operation:\n    :type operation: ```Literal[\"remove\", \"add\"]```\n\n    :param name:\n    :type name: ```str```\n\n    :return: Column call\n    :rtype: ```Call```\n    \"\"\"\n    assert (\n        isinstance(call, Call)\n        and isinstance(call.func, Name)\n        and call.func.id == \"Column\"\n    )\n    if isinstance(call.args[0], (Constant, Str)) and operation == \"remove\":\n        del call.args[0]\n    elif operation == \"add\" and name is not None:\n        call.args.insert(0, Name(name, Load()))\n    return call\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.column_call_to_param","title":"column_call_to_param","text":"<pre><code>column_call_to_param(call)\n</code></pre> <p>Parse column call <code>Call(func=Name(\"Column\", Load(), \u2026)</code> into param</p> <p>Parameters:</p> Name Type Description Default <code>call</code> <code>Call</code> <p>Column call from SQLAlchemy <code>Table</code> construction</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, dict]</code> <p>Name, dict with keys: 'typ', 'doc', 'default'</p> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def column_call_to_param(call):\n    \"\"\"\n    Parse column call `Call(func=Name(\"Column\", Load(), \u2026)` into param\n\n    :param call: Column call from SQLAlchemy `Table` construction\n    :type call: ```Call```\n\n    :return: Name, dict with keys: 'typ', 'doc', 'default'\n    :rtype: ```tuple[str, dict]```\n    \"\"\"\n    assert call.func.id == \"Column\", \"{} != Column\".format(call.func.id)\n    assert (\n        len(call.args) &lt; 4\n    ), \"Complex column parsing not implemented for: Column({})\".format(\n        \", \".join(map(repr, map(cdd.shared.ast_utils.get_value, call.args)))\n    )\n\n    _param = dict(\n        filter(\n            None,\n            chain.from_iterable(\n                (\n                    map(column_parse_arg, enumerate(call.args)),\n                    map(column_parse_extra_sql, enumerate(call.args)),\n                    map(column_parse_kwarg, call.keywords),\n                )\n            ),\n        )\n    )\n    if \"comment\" in _param and \"doc\" not in _param:\n        _param[\"doc\"] = _param.pop(\"comment\")\n\n    if \"server_default\" in _param:\n        append_to_dict(\n            _param,\n            [\"x_typ\", \"sql\", \"constraints\", \"server_default\"],\n            _param[\"server_default\"],\n        )\n\n    for shortname, longname in (\"PK\", \"primary_key\"), (\n        \"FK({})\".format(_param.get(\"foreign_key\")),\n        \"foreign_key\",\n    ):\n        if longname in _param:\n            _param[\"doc\"] = (\n                \"[{}] {}\".format(shortname, _param[\"doc\"])\n                if _param.get(\"doc\")\n                else \"[{}]\".format(shortname)\n            )\n            del _param[longname]\n\n    def _handle_null():\n        \"\"\"\n        Properly handle null condition\n        \"\"\"\n        if not _param[\"typ\"].startswith(\"Optional[\"):\n            _param[\"typ\"] = \"Optional[{}]\".format(_param[\"typ\"])\n\n    if \"nullable\" in _param:\n        not _param[\"nullable\"] or _handle_null()\n        del _param[\"nullable\"]\n\n    if (\n        \"default\" in _param\n        and not cdd.shared.ast_utils.get_value(call.args[0]).endswith(\"kwargs\")\n        and \"doc\" in _param\n    ):\n        _param[\"doc\"] += \".\"\n\n    return cdd.shared.ast_utils.get_value(call.args[0]), _param\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.column_parse_arg","title":"column_parse_arg","text":"<pre><code>column_parse_arg(idx_arg)\n</code></pre> <p>Parse Column arg</p> <p>Parameters:</p> Name Type Description Default <code>idx_arg</code> <code>int</code> <p>argument number, node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Tuple[str, AST]]</code> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def column_parse_arg(idx_arg):\n    \"\"\"\n    Parse Column arg\n\n    :param idx_arg: argument number, node\n    :type idx_arg: ```tuple[int, AST]```\n\n    :rtype: ```Optional[Tuple[str, AST]]```\n    \"\"\"\n    idx, arg = idx_arg\n    if idx &lt; 2 and isinstance(arg, Name):\n        return \"typ\", column_type2typ.get(arg.id, arg.id)\n    elif isinstance(arg, Call):\n        func_id = arg.func.id.rpartition(\".\")[2]\n        if func_id == \"Enum\":\n            return \"typ\", \"Literal{}\".format(\n                list(map(cdd.shared.ast_utils.get_value, arg.args))\n            )\n        elif func_id == \"ForeignKey\":\n            return \"foreign_key\", \",\".join(\n                map(cdd.shared.ast_utils.get_value, arg.args)\n            )\n        else:\n            return \"typ\", cdd.shared.source_transformer.to_code(idx_arg[1]).replace(\n                \"\\n\", \"\"\n            )\n\n    val = cdd.shared.ast_utils.get_value(arg)\n    assert val != arg, \"Unable to parse {!r}\".format(arg)\n    return None if idx == 0 else (None, val)\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.column_parse_extra_sql","title":"column_parse_extra_sql","text":"<pre><code>column_parse_extra_sql(idx_arg)\n</code></pre> <p>Parse Column arg into extra sql type information</p> <p>Parameters:</p> Name Type Description Default <code>idx_arg</code> <code>int</code> <p>argument number, node</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Optional[Tuple[str, dict]]</code> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def column_parse_extra_sql(idx_arg):\n    \"\"\"\n    Parse Column arg into extra sql type information\n\n    :param idx_arg: argument number, node\n    :type idx_arg: ```tuple[int, AST]```\n\n    :rtype: ```Optional[Tuple[str, dict]]```\n    \"\"\"\n    idx, arg = idx_arg\n    if idx &lt; 2 and isinstance(arg, Name) and arg.id in column_type2typ:\n        return \"x_typ\", {\"sql\": {\"type\": arg.id}}\n    return None\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.column_parse_kwarg","title":"column_parse_kwarg","text":"<pre><code>column_parse_kwarg(key_word)\n</code></pre> <p>Parse Column kwarg</p> <p>Parameters:</p> Name Type Description Default <code>key_word</code> <code>ast.keyword</code> <p>The keyword argument</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, Any]</code> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def column_parse_kwarg(key_word):\n    \"\"\"\n    Parse Column kwarg\n\n    :param key_word: The keyword argument\n    :type key_word: ```ast.keyword```\n\n    :rtype: ```tuple[str, Any]```\n    \"\"\"\n    val = cdd.shared.ast_utils.get_value(key_word.value)\n\n    # Checking that the keyword.value has a value OR is a function call.\n    assert val != key_word.value or isinstance(\n        key_word.value, Call\n    ), \"Unable to parse {!r} of {}\".format(\n        key_word.arg, cdd.shared.source_transformer.to_code(key_word.value)\n    )\n    return key_word.arg, val\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.concat_with_whitespace","title":"concat_with_whitespace","text":"<pre><code>concat_with_whitespace(a, b)\n</code></pre> <p>Concatenate a with b with correct whitespace around and within each</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>str</code> <p>first string</p> required <code>b</code> <code>str</code> <p>second string</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>combined strings with correct whitespace around and within</p> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def concat_with_whitespace(a, b):\n    \"\"\"\n    Concatenate a with b with correct whitespace around and within each\n\n    :param a: first string\n    :type a: ```str```\n\n    :param b: second string\n    :type b: ```str```\n\n    :return: combined strings with correct whitespace around and within\n    :rtype: ```str```\n    \"\"\"\n    b_splits = b.split(\"\\n{tab}\".format(tab=tab))\n    res = \"{a}{snd}\\n{tab}{end}{tab}\".format(\n        a=a, tab=tab, snd=b_splits[0], end=\"\\n\".join(b_splits[1:])\n    )\n    return indent_all_but_first(res, indent_level=1, sep=tab)\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.get_pk_and_type","title":"get_pk_and_type","text":"<pre><code>get_pk_and_type(sqlalchemy_class)\n</code></pre> <p>Get the primary key and its type from an SQLalchemy class</p> <p>Parameters:</p> Name Type Description Default <code>sqlalchemy_class</code> <code>ClassDef</code> <p>SQLalchemy class</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>tuple[str, str]</code> <p>Primary key and its type</p> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def get_pk_and_type(sqlalchemy_class):\n    \"\"\"\n    Get the primary key and its type from an SQLalchemy class\n\n    :param sqlalchemy_class: SQLalchemy class\n    :type sqlalchemy_class: ```ClassDef```\n\n    :return: Primary key and its type\n    :rtype: ```tuple[str, str]```\n    \"\"\"\n    assert isinstance(\n        sqlalchemy_class, ClassDef\n    ), \"Expected `ClassDef` got `{type_name}`\".format(\n        type_name=type(sqlalchemy_class).__name__\n    )\n    return (\n        lambda assign: (\n            assign\n            if assign is None\n            else (\n                assign.targets[0].id,\n                assign.value.args[0].id,  # First arg is type\n            )\n        )\n    )(\n        next(\n            filter(\n                lambda assign: any(\n                    filter(\n                        lambda key_word: key_word.arg == \"primary_key\"\n                        and cdd.shared.ast_utils.get_value(key_word.value) is True,\n                        assign.value.keywords,\n                    )\n                ),\n                filter(\n                    lambda assign: isinstance(assign.value, Call)\n                    and isinstance(assign.value.func, Name)\n                    and assign.value.func.id == \"Column\",\n                    filter(rpartial(isinstance, Assign), sqlalchemy_class.body),\n                ),\n            ),\n            None,\n        )\n    )\n</code></pre>"},{"location":"api/#cdd.sqlalchemy.utils.parse_utils.get_table_name","title":"get_table_name","text":"<pre><code>get_table_name(sqlalchemy_class)\n</code></pre> <p>Get the primary key and its type from an SQLalchemy class</p> <p>Parameters:</p> Name Type Description Default <code>sqlalchemy_class</code> <code>ClassDef</code> <p>SQLalchemy class</p> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>str</code> <p>Primary key and its type</p> Source code in <code>cdd/sqlalchemy/utils/parse_utils.py</code> <pre><code>def get_table_name(sqlalchemy_class):\n    \"\"\"\n    Get the primary key and its type from an SQLalchemy class\n\n    :param sqlalchemy_class: SQLalchemy class\n    :type sqlalchemy_class: ```ClassDef```\n\n    :return: Primary key and its type\n    :rtype: ```str```\n    \"\"\"\n    return next(\n        map(\n            lambda assign: cdd.shared.ast_utils.get_value(assign.value),\n            filter(\n                lambda node: next(\n                    filter(lambda target: target.id == \"__tablename__\", node.targets),\n                    None,\n                )\n                and node,\n                filter(\n                    lambda node: isinstance(node, Assign)\n                    and isinstance(node.value, (Str, Constant)),\n                    sqlalchemy_class.body,\n                ),\n            ),\n        ),\n        sqlalchemy_class.name,\n    )\n</code></pre>"},{"location":"api/#cddsqlalchemyutilsshared_utils","title":"<code>cdd.sqlalchemy.utils.shared_utils</code>","text":""},{"location":"api/#cdd.sqlalchemy.utils.shared_utils","title":"cdd.sqlalchemy.utils.shared_utils","text":"<p>Shared utility functions for SQLalchemy</p> <p>Parameters:</p> Name Type Description Default"},{"location":"api/#cdd.sqlalchemy.utils.shared_utils.update_args_infer_typ_sqlalchemy","title":"update_args_infer_typ_sqlalchemy","text":"<pre><code>update_args_infer_typ_sqlalchemy(_param, args, name, nullable, x_typ_sql)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>_param</code> <code>dict</code> <p>Param with typ</p> required <code>args</code> <code>list</code> required <code>name</code> <code>str</code> required <code>nullable</code> <code>Optional[bool]</code> <p>Whether it is NULL-able</p> required <code>x_typ_sql</code> <code>dict</code> required <p>Returns:</p> Name Type Description <code>return_type</code> <code>Tuple[bool, Optional[Union[List[AST], Tuple[AST]]]]</code> <p>Whether the type is nullable, possibly a list/tuple of types to generate columns for</p> Source code in <code>cdd/sqlalchemy/utils/shared_utils.py</code> <pre><code>def update_args_infer_typ_sqlalchemy(_param, args, name, nullable, x_typ_sql):\n    \"\"\"\n    :param _param: Param with typ\n    :type _param: ```dict```\n\n    :param args:\n    :type args: ```list```\n\n    :param name:\n    :type name: ```str```\n\n    :param nullable: Whether it is NULL-able\n    :type nullable: ```Optional[bool]```\n\n    :param x_typ_sql:\n    :type x_typ_sql: ```dict```\n\n    :return: Whether the type is nullable, possibly a list/tuple of types to generate columns for\n    :rtype: ```Tuple[bool, Optional[Union[List[AST], Tuple[AST]]]]```\n    \"\"\"\n    if _param[\"typ\"] is None:\n        return _param.get(\"default\") == cdd.shared.ast_utils.NoneStr, None\n    elif _param[\"typ\"].startswith(\"Optional[\"):\n        _param[\"typ\"] = _param[\"typ\"][len(\"Optional[\") : -1]\n        nullable: bool = True\n    if \"Literal[\" in _param[\"typ\"]:\n        parsed_typ: Call = cast(\n            Call, cdd.shared.ast_utils.get_value(ast.parse(_param[\"typ\"]).body[0])\n        )\n        assert parsed_typ.value.id == \"Literal\", \"Expected `Literal` got: {!r}\".format(\n            parsed_typ.value.id\n        )\n        val = cdd.shared.ast_utils.get_value(parsed_typ.slice)\n        (\n            args.append(\n                Call(\n                    func=Name(\"Enum\", Load(), lineno=None, col_offset=None),\n                    args=val.elts,\n                    keywords=[\n                        ast.keyword(\n                            arg=\"name\",\n                            value=cdd.shared.ast_utils.set_value(name),\n                            identifier=None,\n                        )\n                    ],\n                    expr=None,\n                    expr_func=None,\n                    lineno=None,\n                    col_offset=None,\n                )\n            )\n            if hasattr(val, \"elts\")\n            else _update_args_infer_typ_sqlalchemy_for_scalar(_param, args, x_typ_sql)\n        )\n    elif _param[\"typ\"].startswith(\"List[\"):\n        after_generic: str = _param[\"typ\"][len(\"List[\") :]\n        if \"struct\" in after_generic:  # \",\" in after_generic or\n            name: Name = Name(id=\"JSON\", ctx=Load(), lineno=None, col_offset=None)\n        else:\n            list_typ: Expr = cast(Expr, ast.parse(_param[\"typ\"]).body[0])\n            assert isinstance(\n                list_typ, Expr\n            ), \"Expected `Expr` got `{type_name}`\".format(\n                type_name=type(list_typ).__name__\n            )\n            assert isinstance(\n                list_typ.value, Subscript\n            ), \"Expected `Subscript` got `{type_name}`\".format(\n                type_name=type(list_typ.value).__name__\n            )\n            name: Optional[Name] = next(\n                filter(rpartial(isinstance, Name), ast.walk(list_typ.value.slice)), None\n            )\n            assert name is not None, \"Could not find a type in {!r}\".format(\n                cdd.shared.source_transformer.to_code(list_typ.value.slice)\n            )\n        args.append(\n            Call(\n                func=Name(id=\"ARRAY\", ctx=Load(), lineno=None, col_offset=None),\n                args=[\n                    Name(\n                        id=cdd.sqlalchemy.utils.emit_utils.typ2column_type.get(\n                            name.id, name.id\n                        ),\n                        ctx=Load(),\n                    )\n                ],\n                keywords=[],\n                expr=None,\n                expr_func=None,\n                lineno=None,\n                col_offset=None,\n            )\n        )\n    elif (\n        \"items\" in _param\n        and _param[\"items\"].get(\"type\", False)\n        in cdd.sqlalchemy.utils.emit_utils.typ2column_type\n    ):\n        args.append(\n            Call(\n                func=Name(id=\"ARRAY\", ctx=Load(), lineno=None, col_offset=None),\n                args=[\n                    Name(\n                        id=cdd.sqlalchemy.utils.emit_utils.typ2column_type[\n                            _param[\"items\"][\"type\"]\n                        ],\n                        ctx=Load(),\n                    )\n                ],\n                keywords=[],\n                expr=None,\n                expr_func=None,\n                lineno=None,\n                col_offset=None,\n            )\n        )\n    elif _param.get(\"typ\").startswith(\"Union[\"):\n        args.append(_handle_union_of_length_2(_param[\"typ\"]))\n    else:\n        _update_args_infer_typ_sqlalchemy_for_scalar(_param, args, x_typ_sql)\n    return nullable, None\n</code></pre>"}]}